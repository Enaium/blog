<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://blog.enaium.cn/</link><description>Recent content on</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Sat, 03 Aug 2024 18:15:46 +0800</lastBuildDate><atom:link href="https://blog.enaium.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>星露谷模组开发教程#2 创建一个模组项目</title><link>https://blog.enaium.cn/post/2024-8-3-%E6%98%9F%E9%9C%B2%E8%B0%B7%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%232-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E7%BB%84%E9%A1%B9%E7%9B%AE/</link><pubDate>Sat, 03 Aug 2024 18:15:46 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-8-3-%E6%98%9F%E9%9C%B2%E8%B0%B7%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%232-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E7%BB%84%E9%A1%B9%E7%9B%AE/</guid><description>创建模组项目 经过之前的配置，现在可以创建模组项目了，我们可以创建一个空白的文件夹，然后用Visual Studio Code打开它，之后使用dotnet new classlib来创建一个项目。
我们可以看到，项目中有一个Class1.cs文件，这个就是C#的源文件，还有一个awesome.csproj文件，这个是C#项目的配置文件。
我们可以将Class1.cs名称改为我们想要的名称，比如这里我就叫ModEntry.cs，之后将源文件里的类名也改为ModEntry。
之后需要添加模组需要用到的NuGet包，我们可以使用命令dotnet add package Pathoschild.Stardew.ModBuildConfig来添加模组所需用的包。
编写模组代码 首先进入到ModEntry之中，之后继承Mod这个抽象类，这里如果Visual Studio Code没有提示，可以重新打开。
using StardewModdingAPI; namespace awesome; public class ModEntry : Mod { } 这里由于是抽象类，我们需要实现它的抽象的方法，这里Visual Studio Code会在ModEntry上提示，在这里使用快捷键Shift+Alt+.可以使用快速修复。
using StardewModdingAPI; namespace awesome; public class ModEntry : Mod { public override void Entry(IModHelper helper) { throw new NotImplementedException(); } } 这样它就会实现一个方法，这个方法会在模组加载时调用，我们可以打印一个日志来测试一下。
using StardewModdingAPI; namespace awesome; public class ModEntry : Mod { public override void Entry(IModHelper helper) { Monitor.Log(&amp;#34;Hello SMAPI!.&amp;#34;, LogLevel.</description></item><item><title>星露谷模组开发教程#1 配置开发环境</title><link>https://blog.enaium.cn/post/2024-8-3-%E6%98%9F%E9%9C%B2%E8%B0%B7%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 03 Aug 2024 16:56:31 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-8-3-%E6%98%9F%E9%9C%B2%E8%B0%B7%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>安装.NET SDK 首先我们需要下载.NET SDK，这里当前最新的LTS是.NET 8，我们选择.NET 8进行下载。
点击Download .NET SDK x64进行下载。
下载完成之后点击安装
输入命令dotnet --version，如果安装成功你就会看到终端中会输出当前的版本号。
安装Visual Studio Code 接着进入Visual Studio Code的下载页面
选择对应的版本进行下载。
接受之后一直下一步到完成。
配置Visual Studio Code 进入到插件管理搜索C#，点击安装。
好了，这样我们配置环境这一步就大功告成了。
安装SMAPI 这里大家肯定都装了，应该还没有连模组都不会装就来看模组开发了吧。</description></item><item><title>Windows下Rust OpenCV环境配置</title><link>https://blog.enaium.cn/post/2024-7-28-windows%E4%B8%8Brust-opencv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 28 Jul 2024 21:14:31 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-7-28-windows%E4%B8%8Brust-opencv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>安装Chocolatey 首先我们需要安装Chocolatey，Chocolatey是一个Windows的包管理器。
我们点击右上角的Install进入到Installing Chocolatey，选择Individual
复制命令
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&amp;#39;https://community.chocolatey.org/install.ps1&amp;#39;)) 使用管理员模式打开PowerShell，粘贴命令，等待安装完成。
安装llvm和opencv 安装过程中可能会由于网络问题导致安装失败，可以多次尝试。
choco install llvm opencv 配置环境变量 首先设置OPENCV_INCLUDE_PATHS环境变量，值为C:\tools\opencv\build\include，然后设置OPENCV_LINK_PATHS环境变量，值为C:\tools\opencv\build\x64\vc16\lib，接着设置OPENCV_LINK_LIBS环境变量，值为opencv_worldxxxx，xxxx是你的OpenCV版本号，例如opencv_world4100。
最后我们需要将C:\tools\opencv\build\x64\vc16\bin添加到Path环境变量中。
配置Cargo.toml 在Cargo.toml中添加如下内容：
[dependencies] opencv = &amp;#34;0.92.1&amp;#34; 测试 use opencv::{Error, highgui, imgcodecs}; fn main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; { let image_path = &amp;#34;images/mugshot.png&amp;#34;; let image = imgcodecs::imread(&amp;amp;image_path, imgcodecs::IMREAD_COLOR)?; highgui::imshow(&amp;#34;trump.png&amp;#34;, &amp;amp;image)?; highgui::wait_key(0)?; return Ok(()); } 运行cargo run，如果一切正常，你将看到一张图片弹出。</description></item><item><title>Vue项目整合Cordova一键打包apk</title><link>https://blog.enaium.cn/post/2024-7-13-vue%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88cordova%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85apk/</link><pubDate>Sat, 13 Jul 2024 23:40:06 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-7-13-vue%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88cordova%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85apk/</guid><description>Cordova是一个依赖于Node.js的工具，它可以将HTML页面打包为apk等移动端应用，本篇文章将介绍如何使用Cordova将Vue项目打包为apk。
创建Corodva项目 首先，我们需要安装Cordova，可以使用npm进行安装：
npm install -g cordova 安装完成后，我们可以使用cordova create命令创建一个Cordova项目：
cordova create test 之后进入到test目录，添加到Android平台：
cd test cordova platform add android 这样就可以测试Cordova项目了，可以使用cordova build进行打包。
在打包之前需要注意以下几点：
如果之前没有使用过Java编程语言，则需要安装JDK，并且版本需要大于等于11。
如果之前没有使用过Gradle，则需要安装Gradle，并配置它的bin目录到PATH环境变量。
如果之前没有开发过Android项目，则需要安装Android Studio，并下载Android SDK，然后配置ANDROID_HOME环境变量。
如果过程顺利，那么会在app/build/outputs目录下生成apk文件。
整合Vue项目 首先我们可以将vue和cordova当成一个子项目，之后统一打包。
这里我们可以将cordova项目中的config.xml文件复制到一个空白的node项目中，之后创建一个空白的www目录，之后添加cordova依赖，这样就可以直接使用npx cordova add platform android添加android平台，通过npx cordova build进行打包。
之后通过修改vite.config.ts配置文件，将outputDir修改为www目录，这样就可以将vue项目打包到cordova项目中。
export default defineConfig({ build: { outDir: &amp;#34;../cordova/www&amp;#34; } }) 这样vue和cordova就整合到一起了。
一键打包 我们可以通过配置根项目的package.json文件，添加scripts命令，这样就可以一键打包apk了。
Cordova:
{ &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;cordova build android&amp;#34;, &amp;#34;run&amp;#34;: &amp;#34;cordova run android&amp;#34; } } Vue: 默认
{ &amp;#34;workspaces&amp;#34;: [&amp;#34;packages/vue&amp;#34;, &amp;#34;packages/cordova&amp;#34;], &amp;#34;scripts&amp;#34;: { &amp;#34;vue:dev&amp;#34;: &amp;#34;cd packages/vue &amp;amp;&amp;amp; yarn dev&amp;#34;, &amp;#34;vue:build&amp;#34;: &amp;#34;cd packages/vue &amp;amp;&amp;amp; yarn build&amp;#34;, &amp;#34;cordova:build&amp;#34;: &amp;#34;cd packages/cordova &amp;amp;&amp;amp; yarn build&amp;#34;, &amp;#34;cordova:run&amp;#34;: &amp;#34;cd packages/cordova &amp;amp;&amp;amp; yarn run&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;yarn vue:build &amp;amp;&amp;amp; yarn cordova:build&amp;#34; } }</description></item><item><title>Rust入门实战 编写Minecraft启动器#5启动游戏</title><link>https://blog.enaium.cn/post/2024-7-5-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%235%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</link><pubDate>Fri, 05 Jul 2024 20:19:35 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-7-5-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%235%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</guid><description>好了，我们已经完成了所有的准备工作，现在我们可以开始编写启动游戏的代码了。
首先我们需要添加几个依赖。
model = { path = &amp;#34;../model&amp;#34; } parse = { path = &amp;#34;../parse&amp;#34; } download = { path = &amp;#34;../download&amp;#34; } clap = { version = &amp;#34;4.5&amp;#34; } zip = &amp;#34;2.1&amp;#34; clap用于解析命令行参数，zip用于解压文件。
首先创建一个cli函数用于构建我们的命令行。
fn cli() -&amp;gt; Command { Command::new(&amp;#34;rmcl&amp;#34;) .about(&amp;#34;A Minecraft launcher written in Rust&amp;#34;) .version(&amp;#34;0.1.0&amp;#34;) .author(&amp;#34;Enaium&amp;#34;) .subcommand_required(true) .arg_required_else_help(true) .allow_external_subcommands(true) .subcommand( Command::new(&amp;#34;search&amp;#34;) .about(&amp;#34;Search Game&amp;#34;) .arg(arg!([VERSION] &amp;#34;Game version&amp;#34;)) .arg( arg!(-t --type &amp;lt;TYPE&amp;gt; &amp;#34;Game type&amp;#34;) .value_parser([&amp;#34;release&amp;#34;, &amp;#34;snapshot&amp;#34;, &amp;#34;old_beta&amp;#34;, &amp;#34;old_alpha&amp;#34;]) .require_equals(true) .</description></item><item><title>Rust入门实战 编写Minecraft启动器#4下载资源</title><link>https://blog.enaium.cn/post/2024-7-5-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%234%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</link><pubDate>Fri, 05 Jul 2024 19:58:57 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-7-5-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%234%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</guid><description>首先我们需要添加几个依赖。
model = { path = &amp;#34;../model&amp;#34; } parse = { path = &amp;#34;../parse&amp;#34; } reqwest = { version = &amp;#34;0.12&amp;#34;, features = [&amp;#34;blocking&amp;#34;, &amp;#34;json&amp;#34;] } file-hashing = { version = &amp;#34;0.1&amp;#34; } sha1 = { version = &amp;#34;0.10&amp;#34; } reqwest用于发送请求，file-hashing用于计算文件的hash，sha1用于计算sha1。
之后我们需要添加下载的trait。
pub trait Download { fn download(&amp;amp;self, game_dir: &amp;amp;Path) -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt;; } 接着我们需要使用Client::builder()来创建一个Client，因为默认的get方法会用有个超时时间，而我们需要设置超时时间为无限。
pub fn get&amp;lt;T: reqwest::IntoUrl&amp;gt;(url: T) -&amp;gt; reqwest::Result&amp;lt;reqwest::blocking::Response&amp;gt; { reqwest::blocking::Client::builder() .timeout(None) .build()? .get(url) .send() } 最后我们需要创建一个计算文件hash的函数。</description></item><item><title>Rust入门实战 编写Minecraft启动器#3解析资源配置</title><link>https://blog.enaium.cn/post/2024-7-4-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%233%E8%A7%A3%E6%9E%90%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 04 Jul 2024 23:29:27 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-7-4-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%233%E8%A7%A3%E6%9E%90%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/</guid><description>在上一篇文章中，我们已经建立了资源模型，接下来我们需要解析游戏的配置文件。
首先我们添加serde_json依赖和model依赖。
model = { path = &amp;#34;../model&amp;#34; } serde_json = &amp;#34;1.0&amp;#34; 之后我们在lib.rs中添加解析的trait。
pub trait Parse&amp;lt;T&amp;gt;: Sized { type Error; fn parse(value: T) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt;; } 之后将所有的model都实现这个trait，并测试它们。这里其实只用将需要手动解析的实现这个trait，其他的会在我们用reqwest下载的时候自动解析。
asset.rs
use model::asset::*; use crate::Parse; impl Parse&amp;lt;&amp;amp;str&amp;gt; for AssetIndex { type Error = serde_json::Error; fn parse(value: &amp;amp;str) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; { serde_json::from_str::&amp;lt;AssetIndex&amp;gt;(value) } } impl Parse&amp;lt;&amp;amp;str&amp;gt; for Index { type Error = serde_json::Error; fn parse(value: &amp;amp;str) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; { serde_json::from_str::&amp;lt;Index&amp;gt;(value) } } impl Parse&amp;lt;&amp;amp;str&amp;gt; for Object { type Error = serde_json::Error; fn parse(value: &amp;amp;str) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; { serde_json::from_str::&amp;lt;Object&amp;gt;(value) } } #[cfg(test)] mod tests { use super::*; #[test] fn test_asset_index() { let asset_index = AssetIndex::parse( r#&amp;#34;{&amp;#34;id&amp;#34;: &amp;#34;17&amp;#34;, &amp;#34;sha1&amp;#34;: &amp;#34;fab15439bdef669e389e25e815eee8f1b2aa915e&amp;#34;, &amp;#34;size&amp;#34;: 447033, &amp;#34;totalSize&amp;#34;: 799252591, &amp;#34;url&amp;#34;: &amp;#34;https://piston-meta.</description></item><item><title>Rust入门实战 编写Minecraft启动器#2建立资源模型</title><link>https://blog.enaium.cn/post/2024-6-30-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%232%E5%BB%BA%E7%AB%8B%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B/</link><pubDate>Sun, 30 Jun 2024 23:33:28 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-6-30-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%232%E5%BB%BA%E7%AB%8B%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B/</guid><description>我们需要声明几个结构体来存储游戏的资源信息，之后我们需要将json文件解析成这几个结构体，所以我们需要添加serde依赖。
serde = { version = &amp;#34;1.0&amp;#34;, features = [&amp;#34;derive&amp;#34;] } 资源相关asset.rs
use serde::Deserialize; use std::collections::HashMap; #[derive(Deserialize)] pub struct AssetIndex { pub id: String, pub sha1: String, pub size: u32, #[serde(alias = &amp;#34;totalSize&amp;#34;)] pub total_size: u32, pub url: String, } #[derive(Deserialize)] pub struct Index { pub objects: HashMap&amp;lt;String, Object&amp;gt;, } #[derive(Deserialize)] pub struct Object { pub hash: String, pub size: u32, } 游戏本体version.rs
use serde::Deserialize; use crate::{asset::AssetIndex, library::Library}; pub type Libraries = Vec&amp;lt;Library&amp;gt;; #[derive(Deserialize)] pub struct Version { #[serde(alias = &amp;#34;assetIndex&amp;#34;)] pub asset_index: AssetIndex, pub downloads: Download, pub id: String, pub libraries: Libraries, #[serde(alias = &amp;#34;mainClass&amp;#34;)] pub main_class: String, #[serde(alias = &amp;#34;releaseTime&amp;#34;)] pub release_time: String, pub time: String, #[serde(alias = &amp;#34;type&amp;#34;)] pub type_: String, } #[derive(Deserialize)] pub struct Download { pub client: Client, } #[derive(Deserialize)] pub struct Client { pub sha1: String, pub size: u32, pub url: String, } 游戏依赖库library.</description></item><item><title>Rust入门实战 编写Minecraft启动器#1启动方法</title><link>https://blog.enaium.cn/post/2024-6-23-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%231%E5%90%AF%E5%8A%A8%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 23 Jun 2024 22:12:39 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-6-23-rust%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%231%E5%90%AF%E5%8A%A8%E6%96%B9%E6%B3%95/</guid><description>引言 想必大家都知道Minecraft这个游戏，它是一个非常有趣的游戏，有没有想过它是如何启动的呢？在本系列中，我们将使用Rust编写一个简单的Minecraft启动器。
本系列文章涉及的Rust知识并不多，了解Rust的基本语法即可，如果你对Minecraft或者Java有一定了解，那么会更容易理解本系列的内容。
观前须知 本系列文章只考虑如何完成一个简单的Minecraft启动器，不考虑支持启动老的游戏版本，也不考虑第三方的客户端，更不会去考虑正版验证等等，只是一个简单的启动器。
启动方法 首先Minecarft是使用Java编写的，所以我们需要通过执行Java命令来启动Minecraft，并且也需要添加一些参数，比如游戏的一些资源文件，Java的一些参数等等。
大概就像这样：
java -Xmx10745m -cp &amp;#34;minecraft.jar;lib/*&amp;#34; -Djava.library.path=&amp;#34;natives&amp;#34; net.minecraft.client.main.Main --username yourname --version 1.21 下载资源 第一步我们需要下载Minecraft的资源文件，包括游戏本体、依赖库、资源文件。
http://launchermeta.mojang.com/mc/game/version_manifest.json这个地址可以读取到游戏所有版本。
https://piston-meta.mojang.com/v1/packages/&amp;lt;sha1&amp;gt;/&amp;lt;version&amp;gt;.json这个地址可以获取到游戏的配置信息。
http://resources.download.minecraft.net/&amp;lt;sha1_first_two&amp;gt;/&amp;lt;sha1&amp;gt;这个地址可以获取到游戏的资源文件。
https://libraries.minecraft.net/&amp;lt;group&amp;gt;/&amp;lt;artifact&amp;gt;/&amp;lt;version&amp;gt;/&amp;lt;artifact&amp;gt;-&amp;lt;version&amp;gt;.jar这个地址可以获取到游戏的依赖库。
游戏目录结构 首先游戏的所有资源都在一个目录中，这个目录包括libraries、assets、versions等文件夹，这个目录通常是.minecraft。
libraries文件夹存放游戏的依赖库，目录结构和Maven的目录结构类似。
assets文件夹存放游戏的资源文件，其中包括objects和indexes，objects存放资源文件，所有的资源文件都是以sha1命名的，所以objects文件夹下有一个以 2 位sha1命名的文件夹，所有前两位sha1相同的资源文件都在这个文件夹下，indexes存放资源文件的索引文件，也就是包含了资源文件的真实名称和对应的sha1值。
versions文件夹存放游戏的版本文件，每个版本都有一个以版本号命名的文件夹，这个文件夹包括natives，它存放游戏的本地库文件，我们需要在游戏启动的时候将所有native的jar文件都解压到这个文件夹下，这个文件夹还包括&amp;lt;version&amp;gt;.json，这个文件包括了游戏的配置信息，比如mainClass，assets等等，还有&amp;lt;version&amp;gt;.jar，这个文件是游戏的本体文件。
拼接命令 完成以上步骤后，我们就可以拼接命令了，首先是java的程序路径，然后是JVM参数，然后是classpath，接着是main方法的类路径，最后是Minecraft的参数。
拼接完成之后就可以执行这个命令启动游戏了。
项目结构 本项目分为 4 个模块：download, launch, model, parse。
download模块用于下载游戏资源文件。
launch模块用于启动游戏。
model模块用建立游戏的数据模型。
parse模块用于解析游戏的配置文件。
流程 graph LR 建立资源模型 --&amp;gt; 解析资源配置 --&amp;gt; 下载游戏资源 --&amp;gt; 拼接启动命令 --&amp;gt; 启动游戏 结语 好了，本文就到这里了，之后的一些内容会在后续文章中介绍。
项目地址</description></item><item><title>使用Kotlin编写一个Http服务器</title><link>https://blog.enaium.cn/post/2024-6-8-%E4%BD%BF%E7%94%A8kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Sat, 08 Jun 2024 20:04:11 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-6-8-%E4%BD%BF%E7%94%A8kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>引言 在本文中，我们将使用 Kotlin 编写一个简单的 HTTP 服务器。我们将使用 Java 的 ServerSocket 类来实现这个服务器。我们将创建一个简单的服务器，它将监听端口 8000，并在接收到请求时返回一个简单的响应。
Http 的格式 HTTP 请求和响应都是文本格式的。HTTP 请求由请求行、请求头和请求体组成。HTTP 响应由状态行、响应头和响应体组成。
具体可以到 MDN 查看。
代码实现 首先我们需要创建一个Method枚举和一个Version枚举，用于表示请求的方法和版本。
enum class Method { GET, POST, UNKNOWN; companion object { fun parse(method: String): Method = when (method) { &amp;#34;GET&amp;#34; -&amp;gt; GET &amp;#34;POST&amp;#34; -&amp;gt; POST else -&amp;gt; UNKNOWN } } } enum class Version { HTTP_1_1, UNKNOWN; companion object { fun parse(version: String): Version = when (version) { &amp;#34;HTTP/1.1&amp;#34; -&amp;gt; HTTP_1_1 else -&amp;gt; UNKNOWN } } override fun toString(): String { return when (this) { HTTP_1_1 -&amp;gt; &amp;#34;HTTP/1.</description></item><item><title>1小时学会SpringBoot3+Vue3前后端分离开发</title><link>https://blog.enaium.cn/post/2024-4-23-1%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aspringboot3-vue3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91/</link><pubDate>Tue, 23 Apr 2024 20:32:11 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-4-23-1%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aspringboot3-vue3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91/</guid><description>引言 大家可能刚学会Java和Vue之后都会想下一步是什么？那么就先把SpringBoot和Vue结合起来，做一个前后端分离的项目吧。
准备工作 首先你需要懂得Java和Vue的基础知识，环境这里就不多说了，直接开始。
创建 SpringBoot 项目 使用IDEA旗舰版的可以直接使用自带Spring Initializr创建项目，其他的可以使用Spring Initializr创建项目。
语言选择Java，类型选择Gradle-Kotlin，Java选择 21，其他的都随便填。
接下来选择依赖，这里选择web，lombok,数据库选择PostgreSQL，如果你使用的是MySQL就选它
之后点击创建自动打开项目，或者点击生成打开下载的项目
之后等待项目的依赖下载完成就好了
如果需要配置镜像那就在repositories中最上面添加腾讯云的镜像
repositories { maven { url = uri(&amp;#34;https://mirrors.cloud.tencent.com/nexus/repository/maven-public&amp;#34;) } mavenCentral() } 首先我们需要创建数据库，比如一个图书管理系统，需要有一张图书表，有一些字段，比如标题、作者、创建时间、等等。
我们使用数据库管理工具来创建一个表吧。
注意这里使用的是Postgres，如果是MySQL类型略有不同。
之后我们就可以创建实体类了，这里需要先引入ORM框架依赖，这里我为了方便引入写了一个Gradle插件，把它写入到plugins中，接着在刷新一下项目就可以继续编写代码了。
plugins { // 省略其他插件... id(&amp;#34;cn.enaium.jimmer.gradle&amp;#34;) version &amp;#34;0.0.11&amp;#34; } 我们创建一个接口Book添加一个Entity和Table注解，之后添加一些方法，名称就是根据数据库中字段名称一样，只不过要把蛇形命名改为小驼峰。
@Entity @Table(name = &amp;#34;book&amp;#34;) public interface Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) int id(); String title(); String author(); LocalDateTime createTime(); } 写完之后，我们按下编译的快捷键(默认是 Ctrl+F9)，之后就可以编写接口了。
@RestController @RequiredArgsConstructor public class BookController { private final JSqlClient sql; @GetMapping(&amp;#34;/book&amp;#34;) public List&amp;lt;Book&amp;gt; getBooks() { return sql.</description></item><item><title>使用Kotlin进行全栈开发 Ktor+Kotlin/JS</title><link>https://blog.enaium.cn/post/2024-4-13-%E4%BD%BF%E7%94%A8kotlin%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91-ktor-kotlin-js/</link><pubDate>Sat, 13 Apr 2024 21:50:28 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-4-13-%E4%BD%BF%E7%94%A8kotlin%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91-ktor-kotlin-js/</guid><description>前言 本文将介绍如何使用 Kotlin 全栈技术栈Ktor+Kotlin/JS来构建一个简单的全栈应用。
准备工作 创建项目 首先我们需要创建一个Kotlin项目，之后继续在其中新建两个子项目，一个是Kotlin/JS项目，另一个是Ktor项目。
添加依赖和插件 这里我使用了Gradle的catalog，在项目中的gradle目录下创建一个libs.versions.toml文件，用于管理项目中的依赖版本。
[versions] jimmer = &amp;#34;0.0.9&amp;#34; kotlin = &amp;#34;1.9.23&amp;#34; ktor = &amp;#34;2.3.9&amp;#34; ksp = &amp;#34;1.9.23-1.0.20&amp;#34; coroutines = &amp;#34;1.8.0&amp;#34; serialization = &amp;#34;1.6.3&amp;#34; wrappers = &amp;#34;1.0.0-pre.729&amp;#34; logback = &amp;#34;1.5.3&amp;#34; postgresql = &amp;#34;42.7.3&amp;#34; hikari = &amp;#34;5.1.0&amp;#34; koin = &amp;#34;3.5.6&amp;#34; [libraries] ktor-server-core = { module = &amp;#34;io.ktor:ktor-server-core-jvm&amp;#34;, version.ref = &amp;#34;ktor&amp;#34; } ktor-server-netty = { module = &amp;#34;io.ktor:ktor-server-netty-jvm&amp;#34;, version.ref = &amp;#34;ktor&amp;#34; } ktor-server-cors = { module = &amp;#34;io.ktor:ktor-server-cors&amp;#34;, version.</description></item><item><title>JDK22新特性Class-File API尝鲜</title><link>https://blog.enaium.cn/post/2024-3-4-jdk22%E6%96%B0%E7%89%B9%E6%80%A7class-file-api%E5%B0%9D%E9%B2%9C/</link><pubDate>Mon, 04 Mar 2024 12:14:18 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-3-4-jdk22%E6%96%B0%E7%89%B9%E6%80%A7class-file-api%E5%B0%9D%E9%B2%9C/</guid><description>前言 到目前为止JDK22已经Final Release Candidate了，不出意外的话，这个就是最终General Availability版本了，在本次更新有一个新的的特性也就是，Class-File API，不过还是在预览版中，不过我们可以尝鲜一下，也就是在未来的版本中可能会被删除或者修改，大家在之前可能使用过ASM等第三方库，但现在JDK是每6个月就会发布一个新的版本，第三方库可能会更新不及时，所以JDK内置了一个Class-File API，这样就可以更好的支持Java的新特性。
安装 我们先需要在jdk.java.net下载JDK22，之后再IntelliJ IDEA中开启22(Preview)，之后就可以使用Class-File API了。
使用 读取类信息 我们首先是读取一个class文件，也就是读取它的类信息，既然是读取类，我们就写一个类之后再编译。
public class Test { public String name = &amp;#34;Enaium&amp;#34;; public void render() { System.out.println(name); } } 之后我们在IntelliJ IDEA中编译一下，然后我们就可以读取这个class文件了。
void main() throws IOException { ClassFile.of().parse(Path.of(&amp;#34;out/production/untitled1/Test.class&amp;#34;)); ClassFile.of().parse(Files.readAllBytes(Path.of(&amp;#34;out/production/untitled1/Test.class&amp;#34;))); } 我们可以看到ClassFile有一个of方法，这个方法返回一个ClassFile对象，然后我们可以调用parse方法解析class文件，这里可以使用两种方法，一种是传入Path对象，一种是传入byte数组。
void main() throws IOException { final ClassModel parse = ClassFile.of().parse(Path.of(&amp;#34;out/production/untitled1/Test.class&amp;#34;)); System.out.println(parse.majorVersion()); System.out.println(parse.superclass().get().name()); for (PoolEntry poolEntry : parse.constantPool()) { System.out.println(STR.&amp;#34; \{poolEntry.toString()}&amp;#34;); } } 我们可以看到ClassFile有一个parse方法，这个方法返回一个ClassModel对象，然后我们可以调用majorVersion方法获取class文件的版本，superclass方法获取父类，constantPool方法获取常量池。
其中PoolEntry比较特殊，它是一个接口，所以我直接调用toString方法，这个方法返回一个String对象，这个对象就是常量池的内容，我们进入到JDK源码中，获取它有哪些实现类，ClassEntry、FieldRefEntry、MethodRefEntry等等。
读取字段信息 void main() throws IOException { final ClassModel parse = ClassFile.</description></item><item><title>一个脚本让您的Gradle项目下载速度起飞</title><link>https://blog.enaium.cn/post/2024-2-5-%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E8%AE%A9%E6%82%A8%E7%9A%84gradle%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%B5%B7%E9%A3%9E/</link><pubDate>Mon, 05 Feb 2024 15:56:36 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-2-5-%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E8%AE%A9%E6%82%A8%E7%9A%84gradle%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%B5%B7%E9%A3%9E/</guid><description>前言 Gradle是一个非常优秀的构建工具，但用过Maven的人都知道，Maven可以设置镜像，加速下载速度，而Gradle却没有这个功能。因为Gradle没有Maven这么死板的概念，在Gradle中大部分功能都是通过脚本实现的，所以我们可以通过脚本来实现镜像的功能。
首先需要了解一下什么是Initialization scripts，Initialization scripts是Gradle的初始化脚本，它可以在Gradle启动时执行，Gradle会在执行构建之前执行初始化脚本，也就是说我们可以在这个时候编写替换仓库地址的脚本，这样就可以实现镜像的功能。
脚本 首先我们需要再用户目录下的.gradle的目录下创建一个init.gradle.kts文件，然后在这个文件中编写脚本。
首先使用apply给脚本添加一个EnterpriseRepositoryPlugin插件，之后编写一个类实现Plugin接口，然后我们在apply方法中编写替换仓库地址的逻辑。
apply&amp;lt;EnterpriseRepositoryPlugin&amp;gt;() class EnterpriseRepositoryPlugin : Plugin&amp;lt;Gradle&amp;gt; { override fun apply(gradle: Gradle) { } } 首先我们创建一个派生类，在这个派生类中定义一些常量，这些常量是我们要替换的仓库地址。
companion object { const val CENTRAL = &amp;#34;https://maven.aliyun.com/repository/central&amp;#34; const val GRADLE_PLUGIN = &amp;#34;https://maven.aliyun.com/repository/gradle-plugin&amp;#34; } 之后在这里使用gradle.settingsEvaluated方法，这个方法会在settings.gradle文件被解析之后执行，我们可以在这个方法中编写替换插件仓库地址的逻辑。
gradle.settingsEvaluated { pluginManagement { repositories { all { if (this is MavenArtifactRepository) { val url = this.url.toString() if (url.startsWith(&amp;#34;https://repo1.maven.org/maven2&amp;#34;) || url.startsWith(&amp;#34;https://repo.maven.apache.org/maven2&amp;#34;)) { this.setUrl(CENTRAL) } if (url.startsWith(&amp;#34;https://plugins.gradle.org/m2&amp;#34;)) { this.setUrl(GRADLE_PLUGIN) } } } } } } 在完成插件的仓库地址替换之后，我们还需要替换项目的仓库地址，逻辑和替换插件的仓库地址一样。</description></item><item><title>Fabric模组开发中4个热重载的方法</title><link>https://blog.enaium.cn/post/2024-1-23-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E4%B8%AD4%E4%B8%AA%E7%83%AD%E9%87%8D%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Tue, 23 Jan 2024 00:15:06 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-23-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E4%B8%AD4%E4%B8%AA%E7%83%AD%E9%87%8D%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>前言 当你在开发Fabric模组时，你可能会遇到这样的情况：你修改了模组的资源、数据或者代码，但是你需要重启游戏才能看到效果。这样的话，你的开发效率就会大大降低。所以，这篇文章就是为了解决这个问题而写的，不过需要注意的是，代码部分需要以Debug模式运行，每次修改后都需要重新编译一下，IDEA的快捷键就是Ctrl+Shift+F9。
热重载资源 使用F3+T快捷键可以重载资源。
比如这里我给物品添加一个纹理：
热重载资源 使用/reload命令可以重载资源。
比如这里我修改一个合成表：
@@ -1,9 +1,8 @@ { &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shaped&amp;#34;, &amp;#34;pattern&amp;#34;: [ - &amp;#34;EEE&amp;#34;, - &amp;#34;EEE&amp;#34;, - &amp;#34;EEE&amp;#34; + &amp;#34;EE&amp;#34;, + &amp;#34;EE&amp;#34; ], &amp;#34;key&amp;#34;: { &amp;#34;E&amp;#34;: { 热重载代码 我们这里修改一个按钮的位置，然后到IDEA的源码文件中按下Ctrl+Shift+F9，然后就可以看到效果了。
@@ -12,6 +12,6 @@ @Override protected void init() { addDrawableChild(ButtonWidget.builder(Text.literal(&amp;#34;Button&amp;#34;), (button) -&amp;gt; { - }).dimensions(0, 0, 50, 20).build()); + }).dimensions(100, 100, 50, 20).build()); } } 这里需要点击一下reload按钮。
之后重新打开界面就可以看到效果了。
热重载Mixin 这个比较特殊，需要添加agent参数。
首先找到项目中对应的mixin依赖位置，之后给启动任务添加一个jvm参数。
tasks.named(&amp;#34;runClient&amp;#34;, JavaExec) { jvmArgs(&amp;#34;-javaagent:C:\\Users\\Enaium\\.gradle\\caches\\modules-2\\files-2.1\\net.fabricmc\\sponge-mixin\\0.12.5+mixin.0.8.5\\8d31fb97c3e0cd7c8dad3441851c523bcfae6d8e\\sponge-mixin-0.12.5+mixin.0.8.5.jar&amp;#34;) } 当然这个方法有点麻烦，需要手动的寻找jar包的位置，能不能让万能的Gradle自动帮我们找到并添加呢？答案是肯定的。</description></item><item><title>Minecraft Fabric模组开发教程#11 添加流体</title><link>https://blog.enaium.cn/post/2024-1-15-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%2311-%E6%B7%BB%E5%8A%A0%E6%B5%81%E4%BD%93/</link><pubDate>Mon, 15 Jan 2024 15:45:08 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-15-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%2311-%E6%B7%BB%E5%8A%A0%E6%B5%81%E4%BD%93/</guid><description>前言 本教程将会教你如何添加流体，什么是流体呢？就是像水、熔岩这样的东西，我们将会添加一种新的流体。
创建流体 在原版中流体都继承了net.minecraft.fluid.FlowableFluid，所以我们也继承它。
首先创建一个抽象类AwesomeFluid，然后继承FlowableFluid，然后实现一些方法。
matchesType：判断流体是否是我们的流体 isInfinite：是否是无限流体，就是像水一样，无限多 beforeBreakingBlock：当流体破坏方块时，会调用这个方法，我们在这里把方块掉落，比如火把被水破坏时，会掉落火把 canBeReplacedWith：是否可以被替换 getFlowSpeed：流体流动速度 getLevelDecreasePerBlock：水返回 1，熔岩在主世界时返回 2 并且在下界时返回 1 getTickRate：水返回 5，熔岩在主世界时返回 30 并且在下界时返回 10 getBlastResistance：爆炸抗性，水和熔岩都是 100 public abstract class AwesomeFluid extends FlowableFluid { @Override public boolean matchesType(Fluid fluid) { return fluid == getStill() || fluid == getFlowing(); } @Override protected boolean isInfinite(World world) { return true; } @Override protected void beforeBreakingBlock(WorldAccess world, BlockPos pos, BlockState state) { final BlockEntity blockEntity = state.hasBlockEntity() ? world.getBlockEntity(pos) : null; Block.</description></item><item><title>Minecraft Fabric模组开发教程#10 添加矿物</title><link>https://blog.enaium.cn/post/2024-1-14-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%2310-%E6%B7%BB%E5%8A%A0%E7%9F%BF%E7%89%A9/</link><pubDate>Sun, 14 Jan 2024 14:44:09 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-14-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%2310-%E6%B7%BB%E5%8A%A0%E7%9F%BF%E7%89%A9/</guid><description>注册矿物 我们都知道，在矿物被挖掘之后，会掉落经验，所以我们需要使用ExperienceDroppingBlock来创建方块对象，之后需要创建两种矿物，一种是普通的矿物，一种是深层矿物。
ExperienceDroppingBlock的构造函数需要两个参数，第一个是掉落的经验数量，这里也就是创建了一个随机为 10-17 的经验掉落，第二个参数是方块的设置，这里设置了方块的颜色，敲击音效，硬度抗性，必须使用工具，以及挖掘音效。
public static final Block END_HEART_ORE = new ExperienceDroppingBlock(UniformIntProvider.create(10, 17), AbstractBlock.Settings.create().mapColor(MapColor.STONE_GRAY).instrument(Instrument.BASEDRUM).requiresTool().strength(3.0f, 3.0f).sounds(BlockSoundGroup.NETHER_ORE)); 深层矿物的设置和普通矿物差不多，只不过需要调用copy方法。
public static final Block DEEPSLATE_END_HEART_ORE = new ExperienceDroppingBlock(UniformIntProvider.create(10, 17), AbstractBlock.Settings.copy(END_HEART_ORE).mapColor(MapColor.DEEPSLATE_GRAY).instrument(Instrument.BASEDRUM).requiresTool().strength(4.5f, 3.0f).sounds(BlockSoundGroup.DEEPSLATE)); 最后，我们需要注册这两个矿物。
Registry.register(Registries.BLOCK, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;end_heart_ore&amp;#34;), END_HEART_ORE); Registry.register(Registries.BLOCK, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;deepslate_end_heart_ore&amp;#34;), DEEPSLATE_END_HEART_ORE); 注册矿物物品 使用之前学习的方法，我们可以很容易的注册矿物物品。
矿物纹理 使用之前学习的方法，我们可以很容易的注册矿物纹理。
多语言文件 { &amp;#34;item.awesome.end_heart_ore&amp;#34;: &amp;#34;End Heart Ore&amp;#34;, &amp;#34;item.awesome.deepslate_end_heart_ore&amp;#34;: &amp;#34;Deepslate End Heart Ore&amp;#34;, &amp;#34;block.awesome.end_heart_ore&amp;#34;: &amp;#34;End Heart Ore&amp;#34;, &amp;#34;block.awesome.deepslate_end_heart_ore&amp;#34;: &amp;#34;Deepslate End Heart Ore&amp;#34; } 掉落物 这里会比较复杂，需要考虑精准采集和时运的影响，但我们可以使用原版中已经存在的配置。
我们进入到原版游戏中的data/minecraft/loot_tables/blocks/diamond_ore.json和data/minecraft/loot_tables/blocks/deepslate_diamond_ore.json将钻石矿的掉落配置加以修改。
@@ -24,7 +24,7 @@ } } ], - &amp;#34;name&amp;#34;: &amp;#34;minecraft:diamond_ore&amp;#34; + &amp;#34;name&amp;#34;: &amp;#34;awesome:end_heart_ore&amp;#34; }, { &amp;#34;type&amp;#34;: &amp;#34;minecraft:item&amp;#34;, @@ -38,7 +38,7 @@ &amp;#34;function&amp;#34;: &amp;#34;minecraft:explosion_decay&amp;#34; } ], - &amp;#34;name&amp;#34;: &amp;#34;minecraft:diamond&amp;#34; + &amp;#34;name&amp;#34;: &amp;#34;awesome:end_heart&amp;#34; } ] } @@ -46,5 +46,5 @@ &amp;#34;rolls&amp;#34;: 1.</description></item><item><title>Minecraft Fabric模组开发教程#9 添加附魔书</title><link>https://blog.enaium.cn/post/2024-1-13-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%239-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</link><pubDate>Sat, 13 Jan 2024 15:17:47 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-13-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%239-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</guid><description>创建附魔类 public class FireBoomEnchantment extends Enchantment { public FireBoomEnchantment(Rarity rarity, EnchantmentTarget target, EquipmentSlot[] slotTypes) { super(rarity, target, slotTypes); } } 如果目标被攻击，目标就会爆炸，这里直接使用FireballEntity类中onCollision方法的部分代码。
@Override public void onTargetDamaged(LivingEntity user, Entity target, int level) { if (target instanceof LivingEntity) { boolean bl = user.getWorld().getGameRules().getBoolean(GameRules.DO_MOB_GRIEFING); user.getWorld().createExplosion(target, target.getX(), target.getY(), target.getZ(), 1, bl, World.ExplosionSourceType.MOB); } } 注册附魔 创建FireBoomEnchantment对象的时候，需要传入Enchantment.Rarity、EnchantmentTarget和EquipmentSlot[]，其中VERY_RARE表示非常稀有，EnchantmentTarget.WEAPON表示只能附魔武器，EquipmentSlot[]表示只能附魔主手。
public static final FireBoomEnchantment FIRE_BOOM = Registry.register(Registries.ENCHANTMENT, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;fire_boom&amp;#34;), new FireBoomEnchantment(Enchantment.Rarity.VERY_RARE, EnchantmentTarget.WEAPON, new EquipmentSlot[]{ EquipmentSlot.MAINHAND })); 多语言 { &amp;#34;enchantment.</description></item><item><title>Minecraft Fabric模组开发教程#8 添加武器</title><link>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%238-%E6%B7%BB%E5%8A%A0%E6%AD%A6%E5%99%A8/</link><pubDate>Wed, 10 Jan 2024 16:00:24 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%238-%E6%B7%BB%E5%8A%A0%E6%AD%A6%E5%99%A8/</guid><description>工具材料 和添加盔甲差不多，需要创建一个EndToolMaterial类，之后实现ToolMaterial接口，这样我们就可以创建武器了。
public enum EndToolMaterial implements ToolMaterial { ; @Override public int getDurability() { return 0; } @Override public float getMiningSpeedMultiplier() { return 0; } @Override public float getAttackDamage() { return 0; } @Override public int getMiningLevel() { return 0; } @Override public int getEnchantability() { return 0; } @Override public Ingredient getRepairIngredient() { return null; } } 之后仿照net.minecraft.item.ToolMaterials枚举类完成这些方法。
package com.example.tool; +import com.example.ExampleMod; import net.minecraft.item.ToolMaterial; import net.minecraft.recipe.Ingredient; +import java.util.function.Supplier; + public enum EndToolMaterial implements ToolMaterial { - ; + END(5, 2592, 17.</description></item><item><title>Minecraft Fabric模组开发教程#7 添加盔甲</title><link>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%237-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</link><pubDate>Wed, 10 Jan 2024 14:53:56 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%237-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</guid><description>盔甲材料 我们创建一个EndArmorMaterial枚举类，之后实现ArmorMaterial接口，这样我们就可以创建盔甲了。
package com.example.armor; import net.minecraft.item.ArmorItem; import net.minecraft.item.ArmorMaterial; import net.minecraft.recipe.Ingredient; import net.minecraft.sound.SoundEvent; public enum EndArmorMaterial implements ArmorMaterial { ; @Override public int getDurability(ArmorItem.Type type) { return 0; } @Override public int getProtection(ArmorItem.Type type) { return 0; } @Override public int getEnchantability() { return 0; } @Override public SoundEvent getEquipSound() { return null; } @Override public Ingredient getRepairIngredient() { return null; } @Override public String getName() { return null; } @Override public float getToughness() { return 0; } @Override public float getKnockbackResistance() { return 0; } } 之后仿照net.</description></item><item><title>Minecraft Fabric模组开发教程#6 多语言 合成表 提示</title><link>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%236-%E5%A4%9A%E8%AF%AD%E8%A8%80-%E5%90%88%E6%88%90%E8%A1%A8-%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</link><pubDate>Wed, 10 Jan 2024 02:49:55 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-10-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%236-%E5%A4%9A%E8%AF%AD%E8%A8%80-%E5%90%88%E6%88%90%E8%A1%A8-%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</guid><description>多语言 在之前我们已经添加了物品、物品组和方快，但是它们还没有名称，这里可以使用多语言来为它们添加名称。
我们在assets/awesome/lang目录下创建一个en_us.json文件，这个文件就是英文语言文件，我们可以在这个文件中添加多语言。
{ &amp;#34;item.awesome.end_heart&amp;#34;: &amp;#34;End Heart&amp;#34;, &amp;#34;item.awesome.end_heart_block&amp;#34;: &amp;#34;End Heart Block&amp;#34;, &amp;#34;block.awesome.end_heart_block&amp;#34;: &amp;#34;End Heart Block&amp;#34;, &amp;#34;itemGroup.awesome.item_group&amp;#34;: &amp;#34;Awesome&amp;#34; } 合成表 合成表是用来合成物品的，我们可以在这里设置合成物品的配方。
在data\awesome\recipes创建一个end_heart_block.json文件，也就是如何在工作台中合成end_heart_block.json。
其中type是合成表的类型，pattern是合成表的合成模式，也就是在工作台中的物品摆放位置，key是合成表的材料，result是合成表的结果。
{ &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shaped&amp;#34;, &amp;#34;pattern&amp;#34;: [ &amp;#34;EEE&amp;#34;, &amp;#34;EEE&amp;#34;, &amp;#34;EEE&amp;#34; ], &amp;#34;key&amp;#34;: { &amp;#34;E&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;awesome:end_heart&amp;#34; } }, &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;awesome:end_heart_block&amp;#34;, &amp;#34;count&amp;#34;: 1 } } 接着我们需要再添加一个分解的合成表，也就是如何将end_heart_block分解成end_heart。
在data\awesome\recipes创建一个end_heart.json文件。
和之前的合成表不同的是，这个合成表的type是minecraft:crafting_shapeless，也就是无序合成表，ingredients是合成表的材料，result是合成表的结果。
{ &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shapeless&amp;#34;, &amp;#34;ingredients&amp;#34;: [ { &amp;#34;item&amp;#34;: &amp;#34;awesome:end_heart_block&amp;#34; } ], &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;awesome:end_heart&amp;#34;, &amp;#34;count&amp;#34;: 9 } } 提示 我们可以在方块上添加提示，当玩家将鼠标悬停在方块上时，就会显示提示。</description></item><item><title>Minecraft Fabric模组开发教程#5 添加方块</title><link>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%235-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</link><pubDate>Wed, 10 Jan 2024 01:53:12 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%235-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</guid><description>注册方块 和注册物品相同，我们先声明一个方块对象，和物品不同的是，方块有一个strength属性，这个属性代表方块的硬度，也就是玩家破坏方块需要花费的时间，这个属性的值越大，方块的硬度越高，破坏方块需要花费的时间越长。
public static final Block END_HEART_BLOCK = new Block(FabricBlockSettings.create().strength(4.0f)); 之后我们需要注册这个方块，和注册物品相同，我们需要在onInitialize方法中注册方块。
@@ -31,5 +31,6 @@ @Override public void onInitialize() { + Registry.register(Registries.BLOCK, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;end_heart_block&amp;#34;), END_HEART_BLOCK); } } 虽然说已经将方块注册到了游戏中，但是我们还是获取不到这个方块的物品，因为我们还没有注册这个方块的物品。
@@ -32,5 +32,6 @@ @Override public void onInitialize() { Registry.register(Registries.BLOCK, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;end_heart_block&amp;#34;), END_HEART_BLOCK); + Registry.register(Registries.ITEM, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;end_heart_block&amp;#34;), new BlockItem(END_HEART_BLOCK, new FabricItemSettings())); } } 添加纹理 需要方快的状态配置、方快模型配置、方快物品模型配置和方快纹理。
方块状态配置 位置:assets/awesome/blockstates/end_heart_block.json
{ &amp;#34;variants&amp;#34;: { &amp;#34;&amp;#34;: { &amp;#34;model&amp;#34;: &amp;#34;awesome:block/end_heart_block&amp;#34; } } } 方块模型配置 位置:assets/awesome/models/block/end_heart_block.json</description></item><item><title>Minecraft Fabric模组开发教程#4 添加物品</title><link>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%234-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</link><pubDate>Tue, 09 Jan 2024 22:38:21 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%234-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</guid><description>注册物品 首先在ExampleMod类中声明Item对象。
接着在onInitialize方法中注册物品。
import net.fabricmc.api.ModInitializer; +import net.fabricmc.fabric.api.item.v1.FabricItemSettings; +import net.minecraft.item.Item; +import net.minecraft.registry.Registries; +import net.minecraft.registry.Registry; +import net.minecraft.util.Identifier; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ExampleMod implements ModInitializer { public static final Logger LOGGER = LoggerFactory.getLogger(&amp;#34;awesome&amp;#34;); + public static final Item END_HEART = new Item(new FabricItemSettings()); + @Override public void onInitialize() { - LOGGER.info(&amp;#34;Hello Fabric world!&amp;#34;); + Registry.register(Registries.ITEM, new Identifier(&amp;#34;awesome&amp;#34;, &amp;#34;end_heart&amp;#34;), END_HEART); } } 其中Registry.register方法的第一个参数是注册的类型，第二个参数是注册的ID(格式为modid:itemid)，第三个参数是注册的对象。
进入游戏后使用命令将这个物品添加到背包中
give Player590 awesome:end_heart 我们可以直接调用Registry.register方法来注册物品。
public class ExampleMod implements ModInitializer { public static final Logger LOGGER = LoggerFactory.</description></item><item><title>Minecraft Fabric模组开发教程#3 编写简单的代码</title><link>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%233-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81/</link><pubDate>Tue, 09 Jan 2024 21:50:27 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%233-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81/</guid><description>前言 在上篇文章中我们已经了解了模组和项目的基本信息，这篇文章我们将会编写一些简单的代码。
调整模组信息 我们首先删除无用的文件。
删除client文件夹 删除之后我们还需要调整其他地方。
删除build.gradle中的client部分，由于之后不需要区分客户端和服务端，所以就把loom的一整块代码删除。 删除src/main/resources中的fabric.mod.json中的client部分。 &amp;#34;entrypoints&amp;#34;: { &amp;#34;main&amp;#34;: [ &amp;#34;com.example.ExampleMod&amp;#34; - ], - &amp;#34;client&amp;#34;: [ - &amp;#34;com.example.ExampleModClient&amp;#34; ] }, &amp;#34;mixins&amp;#34;: [ - &amp;#34;modid.mixins.json&amp;#34;, - { - &amp;#34;config&amp;#34;: &amp;#34;modid.client.mixins.json&amp;#34;, - &amp;#34;environment&amp;#34;: &amp;#34;client&amp;#34; - } + &amp;#34;modid.mixins.json&amp;#34; ], &amp;#34;depends&amp;#34;: { &amp;#34;fabricloader&amp;#34;: &amp;#34;&amp;gt;=0.15.0&amp;#34;, 修改模组信息 修改id、name、description、authors、icon。 { &amp;#34;schemaVersion&amp;#34;: 1, - &amp;#34;id&amp;#34;: &amp;#34;modid&amp;#34;, + &amp;#34;id&amp;#34;: &amp;#34;awesome&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;${version}&amp;#34;, - &amp;#34;name&amp;#34;: &amp;#34;Example mod&amp;#34;, - &amp;#34;description&amp;#34;: &amp;#34;This is an example description! Tell everyone what your mod is about!</description></item><item><title>Minecraft Fabric模组开发教程#2 了解模组和项目</title><link>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%232-%E4%BA%86%E8%A7%A3%E6%A8%A1%E7%BB%84%E5%92%8C%E9%A1%B9%E7%9B%AE/</link><pubDate>Tue, 09 Jan 2024 21:18:20 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%232-%E4%BA%86%E8%A7%A3%E6%A8%A1%E7%BB%84%E5%92%8C%E9%A1%B9%E7%9B%AE/</guid><description>前言 在上篇文章中我们已经完成了开发环境的配置，这篇文章我们将会介绍一下模组和项目的基本信息。
目录结构 点击左上角的Project按钮，可以看到项目的目录结构，之后我们展开src中的所有文件夹。
├─client │ ├─java │ │ └─com │ │ └─example │ │ │ ExampleModClient.java │ │ │ │ │ └─mixin │ │ └─client │ │ ExampleClientMixin.java │ │ │ └─resources │ modid.client.mixins.json │ └─main ├─java │ └─com │ └─example │ │ ExampleMod.java │ │ │ └─mixin │ ExampleMixin.java │ └─resources │ fabric.mod.json │ modid.mixins.json │ └─assets └─modid icon.png 我们可以看到src下有两个文件夹，client和main，这两个文件夹分别对应客户端和任意端，他们分别有自己的java和resources文件夹，java文件夹中存放的是 Java 代码，resources文件夹中存放的是资源文件。
模组信息 在main文件夹下的resources文件夹中有一个fabric.mod.json文件，这个文件就是模组的信息文件，我们可以在这里修改模组的信息。
{ &amp;#34;schemaVersion&amp;#34;: 1, &amp;#34;id&amp;#34;: &amp;#34;modid&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;${version}&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Example mod&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;This is an example description!</description></item><item><title>Minecraft Fabric模组开发教程#1 配置开发环境</title><link>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 09 Jan 2024 18:17:05 +0800</pubDate><guid>https://blog.enaium.cn/post/2024-1-9-minecraft-fabric%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>前言 在几年前我已经写过很多关于Mincraft开发相关的文章，今年已经是2024年了所以我决定重新写一遍，这次我会更加详细的介绍一些内容。
安装JDK 由于最新的Minecraft最低只支持JDK17，所以我们需要安装JDK17，这里我选择下载Libreica OpenJDK 17。
这里选择Full JDK之后点击后缀为msi的文件下载，下载完成后双击安装即可。
安装IDEA 这里我选择下载IDEA，选择Community版本即可。
下载完成后双击安装即可。
下载项目模板 这里需要到Fabric的GitHub仓库下载模板，点击这里进入仓库，点击Code按钮，选择Download ZIP下载。
运行项目 下载完成后解压，打开IDEA，选择Open，选择解压后的文件夹，点击OK，最后点击Trust Project。
这样就算是将项目导入IDEA了，接下来只需等待IDEA加载完成即可，如果是第一次开发Fabric模组，可能会需要下载一些依赖，这个过程可能会比较慢，需要耐心等待。
点击左下角有一个Build图标的按钮，之后再右侧出现BUILD SUCCESSFUL时，说明项目已经完成构建，可以运行了。
之后点击右上角的Gradle图标的按钮，展开之后找到Tasks下的fabric，点击runClient，等待运行完成即可。</description></item><item><title>Gradle极简入门</title><link>https://blog.enaium.cn/post/2023-6-2-gradle%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 02 Jun 2023 09:18:47 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-6-2-gradle%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</guid><description>什么是 Gradle Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，而不是传统的XML。Gradle构建脚本是用Groovy编写的，也可以使用Kotlin编写，两者都是基于JVM的语言。
安装 Gradle 在开始之前，想必大家已经学会了Java或者Kotlin，现在大家都在使用Android Studio开发Android应用，Android Studio是基于IntelliJ IDEA开发的，但现在不从Android Studio的角度来讲，也不从IntelliJ IDEA的角度来讲，而是从Gradle的角度来讲，所以我们需要去官网下载Gradle，然后在IntelliJ IDEA中去使用Gradle。
首先去官网下载Gradle，下载地址：https://gradle.org/releases/，之后点击最新版本中的binary-only，这会直接下载一个zip压缩包，下载完成后解压到一个目录，然后再配置环境变量到bin目录，这样就可以在Terminal中使用gradle命令了，因为Java跨平台的缘故，在其他的操作系统上配置环境变量的方式都是大相不差的，这里我就不再赘述了，如果不会配置环境变量的话，可以去网上搜索一下，这里我就不再赘述了。
配置好环境变量之后，打开Terminal，输入gradle -v，如果出现下面的信息，说明Gradle安装成功了。
------------------------------------------------------------ Gradle 8.1 ------------------------------------------------------------ Build time: 2023-04-12 12:07:45 UTC Revision: 40ba32cde9d6daf2b92c39376d2758909dd6b813 Kotlin: 1.8.10 Groovy: 3.0.15 Ant: Apache Ant(TM) version 1.10.11 compiled on July 10 2021 JVM: 17.0.6 (BellSoft 17.0.6+10-LTS) OS: Windows 10 10.0 amd64 创建 Hello World 项目 创建一个文件夹，然后在文件夹中打开Terminal，输入gradle init，之后按照我的步骤来。
Select type of project to generate: 1: basic 2: application 3: library 4: Gradle plugin Enter selection (default: basic) [1.</description></item><item><title>Jimmer VS MyBatisPlus查询自关联表</title><link>https://blog.enaium.cn/post/2023-5-30-jimmer-vs-mybatisplus%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%85%B3%E8%81%94%E8%A1%A8/</link><pubDate>Tue, 30 May 2023 09:48:17 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-30-jimmer-vs-mybatisplus%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%85%B3%E8%81%94%E8%A1%A8/</guid><description>本文是对Jimmer文档中对象抓取器-自关联递归抓取部分的介绍,之后会对比MyBatisPlus的查询自关联表的能力。
对象抓取器是 jimmer-sql 一个非常强大的特征，具备可媲美 GraphQL 的能力。 即使用户不采用任何 GraphQL 相关的技术栈，也能在 SQL 查询层面得到和 GraphQL 相似的对象图查询能力。
准备数据库和实体类 create table tree_node( node_id bigint not null, name varchar(20) not null, parent_id bigint ); alter table tree_node add constraint pk_tree_node primary key(node_id); alter table tree_node add constraint uq_tree_node unique(parent_id, name); alter table tree_node add constraint fk_tree_node__parent foreign key(parent_id) references tree_node(node_id); insert into tree_node( node_id, name, parent_id ) values (1, &amp;#39;Home&amp;#39;, null), (2, &amp;#39;Food&amp;#39;, 1), (3, &amp;#39;Drinks&amp;#39;, 2), (4, &amp;#39;Coca Cola&amp;#39;, 3), (5, &amp;#39;Fanta&amp;#39;, 3), (6, &amp;#39;Bread&amp;#39;, 2), (7, &amp;#39;Baguette&amp;#39;, 6), (8, &amp;#39;Ciabatta&amp;#39;, 6), (9, &amp;#39;Clothing&amp;#39;, 1), (10, &amp;#39;Woman&amp;#39;, 9), (11, &amp;#39;Casual wear&amp;#39;, 10), (12, &amp;#39;Dress&amp;#39;, 11), (13, &amp;#39;Miniskirt&amp;#39;, 11), (14, &amp;#39;Jeans&amp;#39;, 11), (15, &amp;#39;Formal wear&amp;#39;, 10), (16, &amp;#39;Suit&amp;#39;, 15), (17, &amp;#39;Shirt&amp;#39;, 15), (18, &amp;#39;Man&amp;#39;, 9), (19, &amp;#39;Casual wear&amp;#39;, 18), (20, &amp;#39;Jacket&amp;#39;, 19), (21, &amp;#39;Jeans&amp;#39;, 19), (22, &amp;#39;Formal wear&amp;#39;, 18), (23, &amp;#39;Suit&amp;#39;, 22), (24, &amp;#39;Shirt&amp;#39;, 22) ; @Entity public interface TreeNode { @Id @Column(name = &amp;#34;NODE_ID&amp;#34;) long id(); String name(); @Null @ManyToOne TreeNode parent(); @OneToMany(mappedBy = &amp;#34;parent&amp;#34;) List&amp;lt;TreeNode&amp;gt; childNodes(); } 指定查询的深度 我们可以看到，这是一个自关联的表，每个节点都有一个父节点，也可以有多个子节点。</description></item><item><title>Java革命性ORM框架Jimmer简单介绍</title><link>https://blog.enaium.cn/post/2023-5-27-java%E9%9D%A9%E5%91%BD%E6%80%A7orm%E6%A1%86%E6%9E%B6jimmer%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 27 May 2023 10:35:44 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-27-java%E9%9D%A9%E5%91%BD%E6%80%A7orm%E6%A1%86%E6%9E%B6jimmer%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>本文使用Jimmer的官方用例来介绍Jimmer的使用方法,Jimmer同时支持Java和Kotlin,本文使用Java来介绍,实际上Kotlin比Java使用起来更方便,这里为了方便大家理解,使用Java来介绍,本篇文章只是对Jimmer的一个简单介绍,更多的内容请参考官方文档
这里开始就不从实体类开始介绍了,这里简单的把用到的三张表之间的关系介绍一下:
BookStore书店 可以拥有多个Book Book书 可以属于多个BookStore,可以有多个Author Author作者 可以拥有多个Book,多对多书与作者的关系. 查询 Jimmer可以配合SpringData(不是SpringDataJPA),但这里先介绍脱离SpringData的使用方法,但还是在SpringBoot环境下,这里使用H2内存数据库,Jimmer支持H2,MySQL,PostgreSQL,Oracle等数据库,这里使用H2内存数据库.
这里的查询都使用Controller来演示.
查询所有书店 createQuery就是创建一个查询,select就是选择要查询的字段,这里直接传入了BookStoreTable表示查询所有字段.
这里用到的sql就是使用Jimmer的Sql对象,这个对象是Jimmer的核心对象,所有的查询都是通过这个对象来实现的,使用Spring的注入方式注入JSqlClient对象.
final BookStoreTable bookStore = BookStoreTable.$;//这里的$是一个静态方法,返回一个BookStoreTable对象 sql.createQuery(bookStore).select(bookStore).execute(); 查询结果如下:
[ { &amp;#34;createdTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;modifiedTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;O&amp;#39;REILLY&amp;#34;, &amp;#34;website&amp;#34;: null }, { &amp;#34;createdTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;modifiedTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;id&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;MANNING&amp;#34;, &amp;#34;website&amp;#34;: null } ] 指定查询字段 如何需要需要查询指定字段就可以这样,这里的name是BookStoreTable的一个字段,但这里的Controller返回的是BookStore对象,所以只好像上面的那样查询所有字段.
sql.createQuery(bookStore).select(bookStore.name()).execute(); 像上面的例子中如果我们非要查询指定字段又不想定义新的DTO对象,那么这种在Jimmer中也可以非常简单的实现,那就是使用Jimmer中的Fetchr
使用BookStore的Fetchr来指定查询的字段
sql.createQuery(bookStore).select(bookStore.fetch(BookStoreFetcher.$.name())).execute(); 查询结果如下:
[ { &amp;#34;id&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;MANNING&amp;#34; }, { &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;O&amp;#39;REILLY&amp;#34; } ] 惊奇的发现,Controller的返回类型是BookStore,但是查询结果中只有id和name字段.</description></item><item><title>使用SolidJS+SpringBoot写一个简单的个人博客</title><link>https://blog.enaium.cn/post/2023-5-23-%E4%BD%BF%E7%94%A8solidjs+springboot%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Tue, 23 May 2023 12:24:52 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-23-%E4%BD%BF%E7%94%A8solidjs+springboot%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>前言 前端我们使用了SolidJS来进行开发,它是一个新出的前端框架,它的特点是使用React Hooks的方式来进行开发,并且它的API和React的API非常相似,所以如果你会React的话,那么你就会SolidJS.
后端我们使用了SpringBoot来进行开发,数据库我们使用了MySQL来进行开发,这里我使用的是MariaDB来进行开发,ORM 框架使用的是Jimmer,这个框架它支持Java和Kotlin,这里为了简单起见就使用Java开发,但实际使用Koltin会更方便.
前端环境 首先呢,需要安装一下SolidJS的模板,这里我使用的是TypeScript和Bootstrap的模板
npx degit solidjs/templates/ts-bootstrap website cd website pmpm install # or npm install pmpm dev # or npm run dev 然后我们需要安装一下SolidJS的路由,这是一个官方的路由
pnpm install @solidjs/router 然后我们需要安装一下SolidJS的状态管理,这里我使用的是zustand
pnpm install zustand solid-zustand 然后我们需要安装一下Immer用于修改不可变数据
pnpm install solid-immer 然后我们需要安装solid-toast,这是一个用于显示提示的库
pnpm install solid-toast 最后我们需要安装TanStack Query,这是一个用于进行网络请求的库,同时支持React,Vue,Svelte当然也支持SolidJS
pnpm install @tanstack/solid-query 编写前端基础代码 现在我们开始编写前端代码
首先我们需要删掉模板中自带的样式,并且删除App.tsx中的内容,然后我们需要在App.tsx中引入Router组件,并且使用useRoutes来进行路由的渲染,这里我们需要传入一个路由数组,这个数组中包含了我们的路由信息,然后我们需要在App.tsx中使用Router组件来进行路由的渲染
import type { Component } from &amp;#34;solid-js&amp;#34; import { Router, useRoutes } from &amp;#34;@solidjs/router&amp;#34; import routes from &amp;#34;./router&amp;#34; //这里是路由数组 import { Toaster } from &amp;#34;solid-toast&amp;#34; //这个组件用于显示提示 const App: Component = () =&amp;gt; { const Routes = useRoutes(routes) return ( &amp;lt;&amp;gt; &amp;lt;Toaster /&amp;gt; &amp;lt;Router&amp;gt; &amp;lt;Routes /&amp;gt; &amp;lt;/Router&amp;gt; &amp;lt;/&amp;gt; ) } 之后新建views目录,在其中新家一个Login.</description></item><item><title>解决IDEA创建或打开项目时下载Gradle</title><link>https://blog.enaium.cn/post/2023-2-3-%E8%A7%A3%E5%86%B3idea%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8B%E8%BD%BDgradle/</link><pubDate>Fri, 03 Feb 2023 15:42:31 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-2-3-%E8%A7%A3%E5%86%B3idea%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8B%E8%BD%BDgradle/</guid><description>引言 我们在使用IDEA创建或打开一个Gradle项目时,IDEA会下载一个新或旧的Gradle版本,虽然下载很快,但到下次IDEA更新后又会是一个新版的Gradle版本,这样很影响我们的开发效率,所以我做了一个东西,可以让IDEA在创建或打开一个项目时使用自己指定的版本
使用 我做了一个Agent,可以让他来加载自己写的Transformer大大减少了开发时间,它叫做Cafully
首先下载它到任意位置
接着在给IDEA添加下面JVM参数(idea64.exe.vmoptions),agent的位置就是刚才下载的位置
--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED -javaagent:/absolute/path/to/cafully-agent.jar 安装插件 下载好后放入Agent同级目录下的plugin文件夹里面
cafully-plugin-asm 这个是ASM插件,用来生成和修改字节码
接下来下载解决这个问题的插件
KeepGradleVersion
配置 首先呢这个插件有一个配置,在Agent同级目录下的config文件夹里面放入keep-gradle-version.properties文件即可
#默认 7.6, Gradle的版本 version=7.6 #默认 false, 是否在当打开一个项目时使用指定的版本 open=true 这样IDEA无论在创建或打开一个项目时使用指定的版本了
视频</description></item><item><title>Hugo教程#5遍历页面</title><link>https://blog.enaium.cn/post/2022-12-7-hugo%E6%95%99%E7%A8%8B%235%E9%81%8D%E5%8E%86%E9%A1%B5%E9%9D%A2/</link><pubDate>Wed, 07 Dec 2022 11:28:02 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-12-7-hugo%E6%95%99%E7%A8%8B%235%E9%81%8D%E5%8E%86%E9%A1%B5%E9%9D%A2/</guid><description>引言 前面几期视频学习了一些布局和模板语法,其实Hugo的最终用法就是来写个人博客,需要遍历出所有的博客来呈现在网站的主页,Markdown文件都会创建一个页面,所以只需要把每个页面的地址遍历出来就行了
创建页面 首先在content/post创建多个页面,以此类推创建4个页面
# Post1 布局 因为要使用模板语法来遍历出这些页面,所以这里选择修改主页布局,使用with将当前目录改为/post,接着使用range来遍历.Pages,Title就是每个页面的标题,Permalink就是路径
{{ with .Site.GetPage &amp;#34;/post&amp;#34; }} {{ range .Pages }} &amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;{{ .Permalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt; {{ end }} {{ end }}</description></item><item><title>Hugo教程#4基础布局</title><link>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B%234%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/</link><pubDate>Thu, 24 Nov 2022 11:30:04 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B%234%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/</guid><description>引言 前几期学习了布局,本期学习一下布局更多的用法,比如partial和block,其中partial可以吧每个布局引用,block可作为布局的扩展
布局 layouts/_default里有一个baseof.html布局,初始内容是
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; {{- partial &amp;#34;head.html&amp;#34; . -}} &amp;lt;body&amp;gt; {{- partial &amp;#34;header.html&amp;#34; . -}} &amp;lt;div id=&amp;#34;content&amp;#34;&amp;gt; {{- block &amp;#34;main&amp;#34; . }}{{- end }} &amp;lt;/div&amp;gt; {{- partial &amp;#34;footer.html&amp;#34; . -}} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 除了基本的html代码,还有一些使用{{}}包起来的东西,这些都是hugo的模板语法
partial可以将对应的布局引用过来
block可以让这个部分被扩展,对应的子布局需要使用define来进行扩展
首先来看partial
在static中写一个css
static └── css └── style.css .red { color: red; } 在layouts/partials/head.html的布局中引入css,需要注意的是static是在根目录下,所以不用写,直接从static里的路径开始引用就行了,其实partials就相当于把部分文件内容给放到另一个文件中了,然后使用partial来引用这个文件的内容
&amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/css/style.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; 现在将single.html中的内容改为,别忘了要使用define来扩展baseof.html里的block,不然使用的就是single.html这个布局,而不是使用了扩展了baseof.html布局的single.html布局
{{ define &amp;#34;main&amp;#34; }} &amp;lt;div class=&amp;#34;red&amp;#34;&amp;gt; {{ .Content }} &amp;lt;/div&amp;gt; {{ end }}</description></item><item><title>Hugo教程#3单页面布局</title><link>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B%233%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</link><pubDate>Thu, 24 Nov 2022 10:58:26 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B%233%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</guid><description>引言 上集我们学习了如何创建一个index的布局,那么是不是所有的页面都要创建一个布局,那肯定不是的,那样的话实在太麻烦,因为只显对应页面的markdown里面的内容,所以创建一个single.html布局就可以了,所有的页面都可以使用这个布局
布局 在layouts/_default里有一个single.html的布局,默认是空的,我们只需要读取到markdown的内容,之后呈现在页面中
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;{{ .Title }}&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; {{ .Content }} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 测试 在home.md里面写一些内容
# Home ## Single 好了现在所有的页面都可以使用single.html这个布局了</description></item><item><title>Hugo教程#2布局</title><link>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B%232%E5%B8%83%E5%B1%80/</link><pubDate>Mon, 21 Nov 2022 09:16:06 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B%232%E5%B8%83%E5%B1%80/</guid><description>引言 从本集开始,就开始和布局打交道了,所以我们需要学习Hugo的模板语法,其实也刚开始一步一步来,不需要一次学一堆
那如何知道布局的模板是什么呢,其实hugo内置了一个功能,可以创建一个空白主题
创建主题 hugo new theme default 其中default就是主题名
创建好后我们发目录结构基本上和创建一个site(页面项目)的结构一样,只不过layouts里面有一堆html文件,这个就是默认的模板
检查一些主题的theme.toml文件内容,发现友好多内容,其实都是字面意思,没必要太多纠结
再来看layouts里的index.html文件
像平常写html一样写一些基本内容
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;This is a home page&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 之后在项目的配置文件中使用这个主题
baseURL = &amp;#39;http://example.org/&amp;#39; languageCode = &amp;#39;en-us&amp;#39; title = &amp;#39;My New Hugo Site&amp;#39; baseURL = &amp;#39;http://example.org/&amp;#39; languageCode = &amp;#39;en-us&amp;#39; title = &amp;#39;My New Hugo Site&amp;#39; theme = &amp;#39;default&amp;#39; # 添加的主题 项目运行后可以正常显示我们写的内容
其实也可以直接将主题default中的layouts内容全部复制到site的layouts中
default ├── archetypes │ └── default.</description></item><item><title>Hugo教程#1配置开发环境</title><link>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 21 Nov 2022 08:28:43 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>引言 前段时间我把我的博客的生成器从Jekyll换到了Gatsby后来发现并不好用,又想回到Jekyll,最后由于ruby的gem安装老是出错,所以我试了一下Hugo
好了废话不多说,开始配置Hugo的开发环境吧
配置环境 安装 Linux Linux用户可以直接使用包管理器安装apt,yum,dnf,zypper,pacman等等,包名就是hugo
Windows Windows用户可以在GitHub的release下载对应的平台,hugo也支持arm64
创建项目 使用命令hugo new site blog既可在blog下创建一个hugo项目,hugo可以换成自己想在的目录下,如果想在当前目录下创建需要加上--force参数,也就是hugo new site . --force
目录结构 . 当前目录 ├── archetypes 原型模板 使用new 文件名.md参数的时候会在content下创建一个md文件 │ └── default.md 默认模板 ├── config.toml 配置文件 ├── content 内容基本上所有的内容都写在这里面 ├── data 数据 ├── layouts 布局 ├── public 生成的页面 ├── static 静态资源 └── themes 主题 创建内容 使用hugo new 默认创建项目后使用的是yaml的写法,当然也可以使用json和toml的写法,如果是toml的写法那就吧---换成+++
--- title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; # 标题 date: {{ .</description></item><item><title>联系</title><link>https://blog.enaium.cn/contact/</link><pubDate>Fri, 18 Nov 2022 15:37:34 +0800</pubDate><guid>https://blog.enaium.cn/contact/</guid><description>联系 GitHub BiliBili</description></item><item><title>关于</title><link>https://blog.enaium.cn/about/</link><pubDate>Wed, 16 Nov 2022 09:24:55 +0800</pubDate><guid>https://blog.enaium.cn/about/</guid><description>关于 生成器:Hugo
UI:Bootstrap</description></item><item><title>解决Debian网速慢问题</title><link>https://blog.enaium.cn/post/2022-10-07-%E8%A7%A3%E5%86%B3debian%E7%BD%91%E9%80%9F%E6%85%A2%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 07 Oct 2022 15:12:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-10-07-%E8%A7%A3%E5%86%B3debian%E7%BD%91%E9%80%9F%E6%85%A2%E9%97%AE%E9%A2%98/</guid><description>最近在我的笔记本上换了Debian，装上驱动后发现网速很慢，后来换了Ubuntu，Ubuntu自带了网卡驱动，测试了一下网速发现网速还是很慢，只要是基于Debian的系统，或者基于Ubuntu的Mint也是慢
后来在bing上搜了一下，在Ubuntu的论坛上找到了解决方法，其实内核5.15这个版本有问题，我升级到了5.17后发现好了点，不过网速还是慢，所以我将内核直接升级到6.0，测试了一下网速发现网速是可以跑满了
接下来说下更新方法
进入到Ubuntu的内核列表里，下载找到大于当前5.15的6.0，最近6.0刚更新
进入到6.0后最上面有4个deb文件是amd64的，其他处理器可以在下面找到，下载下来后全部安装后重启就可以了
cd ~/Downloads wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-headers-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-headers-6.0.0-060000_6.0.0-060000.202210022231_all.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-image-unsigned-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-modules-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb sudo dpkg -i *.deb 查看内核版本命令
uname -r</description></item><item><title>如何使用Gatsby创建自己的博客</title><link>https://blog.enaium.cn/post/2022-9-28%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gatsby%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</link><pubDate>Wed, 28 Sep 2022 11:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-9-28%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gatsby%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</guid><description>首先使用npm安装gatsby，使用gatsby –version命令可以查看是否安装
npm install -g gatsby-cli 使用new命令后面跟着目录名，即可创建一个gatsby项目
gatsby new website 使用develop参数即可启用gatsby服务
gatsby develop 进入到8000端口后即可访问默认的页面，不过本文章是创建个人博客
在创建项目时后面跟着一个github地址，这个是gatsby官方的一个博客模板
gatsby new blog https://github.com/gatsbyjs/gatsby-starter-blog 这个是项目的目录结构
C:. ├─content │ └─blog │ ├─hello-world │ ├─my-second-post │ └─new-beginnings ├─src │ ├─components │ ├─images │ ├─pages │ └─templates └─static content下主要是markdown文件，但如果要被识别为blog还需要在blog里创建markdown文件
主要看blog里都有哪些文件，每个文件夹下都有一个index.md文件，这里会根据文件夹的名称来决定地址名是什么
C:. ├─hello-world │ index.md │ salty_egg.jpg │ ├─my-second-post │ index.md │ └─new-beginnings index.md 这里可以直接在blog中创建markdown文件，地址名就是markdown文件名
每个markdown文件的前几行都会有用3个横杠抱起来的内容，这个就是Front-matter格式，博客的信息都会从这里获取，title是博客的标题，date是发布时间，description是描述，其中时间必须遵守正确的格式
--- title: &amp;#34;如何使用Gatsby创建自己的博客&amp;#34; date: 2022-09-28T11:16:00+0800 categroy: javascript --- 现在来介绍如何使用GitHub的pages服务，首先需要在项目下安装gh-pages
npm install gh-pages --save-dev 在项目的gatsby的config文件中添加pathPrefix，这里选择没前缀</description></item><item><title>Netty手写RPC框架</title><link>https://blog.enaium.cn/post/2022-3-14-netty%E6%89%8B%E5%86%99rpc%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 14 Mar 2022 14:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-14-netty%E6%89%8B%E5%86%99rpc%E6%A1%86%E6%9E%B6/</guid><description>协议就用上篇文章的协议
public class Message implements Serializable { private final long order; public Message(long order) { this.order = order; } public long getOrder() { return order; } } 只不过Message加了个Order熟悉,
创建Request类,继承Message,klass是调用的Class目标,name,parameterType,argument分别是方法名称,参数类型,参数
public class Request extends Message { private final String klass; private final String name; private final Class&amp;lt;?&amp;gt;[] parameterType; private final Object[] argument; public Request(long order, String klass, String name, Class&amp;lt;?&amp;gt;[] parameterType, Object[] argument) { super(order); this.klass = klass; this.name = name; this.</description></item><item><title>Netty自定义协议</title><link>https://blog.enaium.cn/post/2022-3-12-netty%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 12 Mar 2022 19:21:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-12-netty%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</guid><description>先写一个Messsage类,解码的时候将要把ByteBuf解码为Message
public class Message implements Serializable { private final String data; public Message(String data) { this.data = data; } @Override public String toString() { return &amp;#34;Message{&amp;#34; + &amp;#34;data=&amp;#39;&amp;#34; + data + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 之后创建MessageCodec类,继承MessageToMessageCodec
入站为ByteBuf解码为Message,出站为Message编码为ByteBuf
重写编码的解码方法
public class MessageCodec extends MessageToMessageCodec&amp;lt;ByteBuf, Message&amp;gt; { @Override public void encode(ChannelHandlerContext channelHandlerContext, Message message, List&amp;lt;Object&amp;gt; list) throws Exception { } @Override public void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&amp;lt;Object&amp;gt; list) throws Exception { } } 这里用四个字节表示内容的长度,最后是所有内容,这里使用JDK来序列化</description></item><item><title>Token+Redis登录认证</title><link>https://blog.enaium.cn/post/2022-3-10-token-redis%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</link><pubDate>Thu, 10 Mar 2022 19:17:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-10-token-redis%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</guid><description>首先需要了解一下大概的步骤
登录生成一个Token存入Redis有效期为30分钟,返回到前端 之后前端每次请求,带上登录时返回的Token 服务器判断前端带来的Token是否在Redis服务器中 存在放行并且重置Token有效期,不存在拦截 一个简简单单的登录请求
@RequestMapping(&amp;#34;/login&amp;#34;) @ResponseBody public Result&amp;lt;String&amp;gt; login(@RequestBody UserDTO userDTO) { var byUsernameAndPassword = mapper.getByUsernameAndPassword(userDTO.getUsername(), userDTO.getPassword()); if (byUsernameAndPassword != null) { return new Result&amp;lt;&amp;gt;(true, &amp;#34;login success&amp;#34;); } return new Result&amp;lt;&amp;gt;(false, &amp;#34;wrong username or password&amp;#34;); } 生成一个UUID存入Redis,值为用户的ID,并且设置有效期为30分钟
var uuid = &amp;#34;user-token:&amp;#34; + UUID.randomUUID(); redisTemplate.opsForValue().set(uuid, byUsernameAndPassword.getId().toString(), 30, TimeUnit.MINUTES); return new Result&amp;lt;&amp;gt;(true, uuid); 接下来直写拦截器,重写addInterceptors方法
@Configuration public class RequestInterceptor implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { } } 使用HandlerInterceptor重写preHandle方法,登录和注册不用拦截</description></item><item><title>实现JPanel切换</title><link>https://blog.enaium.cn/post/2022-2-28-%E5%AE%9E%E7%8E%B0jpanel%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 28 Feb 2022 17:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-2-28-%E5%AE%9E%E7%8E%B0jpanel%E5%88%87%E6%8D%A2/</guid><description>public static void main(String[] args) { JFrame jFrame = new JFrame(&amp;#34;Test&amp;#34;); jFrame.setSize(500, 500); jFrame.setLocationRelativeTo(jFrame.getOwner()); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jFrame.setLayout(new BorderLayout()); var jPanel = new JPanel(new BorderLayout()); jFrame.add(jPanel, BorderLayout.CENTER); AtomicBoolean b = new AtomicBoolean(false); jFrame.add(new JButton(&amp;#34;Switch&amp;#34;) { { addActionListener(e -&amp;gt; { b.set(!b.get()); jPanel.removeAll(); jPanel.repaint(); jPanel.revalidate(); jPanel.add(b.get() ? new JPanel() { @Override protected void paintComponent(Graphics g) { setBackground(Color.RED); super.paintComponent(g); } } : new JPanel() { @Override protected void paintComponent(Graphics g) { setBackground(Color.GREEN); super.paintComponent(g); } }); jPanel.</description></item><item><title>Minecraft模组加载器开发教程#1基本介绍</title><link>https://blog.enaium.cn/post/2022-1-21-minecraft%E6%A8%A1%E7%BB%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link><pubDate>Fri, 21 Jan 2022 12:23:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-1-21-minecraft%E6%A8%A1%E7%BB%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%231%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid><description>学习之前，应该先了解一下这些东西
一、	什么是模组加载器
二、	他们是如何修改Minecraft的
三、	修改Minecraft的原理是什么
四、	什么是混淆
五、	如何修改Minecraft
1．	类似于Fabric、Forge，等等，这些都是模组加载器
2．	他们都会通过重新设置类加载器，而重新加载所有类，除了java.lang，java.xxx 之类的核心类，因为java不允许这些类重新加载，当然也可以通过bootclasspath来强制修改java核心类，这些都是后话了, 我们可以使用Mojang官方的LegacyLauncher，这个依赖来在运行的时候重新加载，但年代太久没更新，已经不支持Java9以上的版本，不过修复它也很简单
3．	当类被重新加载的时候，有一个过程，会将二进制文件读取，在读取后我们可以对它进行修改，可以通过ASM等框架，或者基于ASM框架的Mixin框架，之前我制作过这些ASM和Mixin的基础视频
4．	混淆就是把一个类名或者其他可见名，改为不能分辨的名字，比如一个Minecraft类，混淆之后会变成abc这个名字，并且所有的包名都会被去掉， Minecraft原版Jar文件都是混淆后的，只有类名、方法名、字段名被混淆了，再加上近几年官方都在放出每个版本的混淆映射，我们可以通过映射来返混淆，映射就是把每个混淆的名字，告诉你它之前是什么名字，Mojang不允许我们把反混淆后的源码放出来，所以一些客户端比如LiquidBounce使用Forge以Mod的形式来修改客户端
5．	我们可以先把Jar反混淆，之后我们依赖这个类，这样我们就可以正常依赖这个Jar，之后在用官方给的映射列表把写好的东西给重新混淆，这仅仅是不行的，我们还需要修改Java类，使用ASM或者Mixin，比如需要在游戏的onUpdate等方法里插入调用，来实现事件Event，这些操作都需要Gradle来完成，可以写一个Gradle插件来帮我们完成这些操作，比如在编译之后打包Jar之前，我们就可以对这些类重新混淆</description></item><item><title>Netty Http服务器接收请求</title><link>https://blog.enaium.cn/post/2021-7-19-netty-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82/</link><pubDate>Mon, 19 Jul 2021 15:38:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-19-netty-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82/</guid><description>public class Server { public static void main(String[] args) { EventLoopGroup eventLoopGroup = new NioEventLoopGroup(); ServerBootstrap serverBootstrap = new ServerBootstrap(); try { serverBootstrap.group(eventLoopGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new HttpRequestDecoder()); ch.pipeline().addLast(new HttpResponseEncoder()); ch.pipeline().addLast(new HttpObjectAggregator(65535)); ch.pipeline().addLast(new SimpleChannelInboundHandler&amp;lt;FullHttpRequest&amp;gt;() { @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception { ByteBuf byteBuf = Unpooled.wrappedBuffer(&amp;#34;Hello world!&amp;#34;.getBytes(StandardCharsets.UTF_8)); FullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf); fullHttpResponse.headers().set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain;charset=UTF-8&amp;#34;); fullHttpResponse.headers().set(&amp;#34;Content-Length&amp;#34;, byteBuf.readableBytes()); ctx.writeAndFlush(fullHttpResponse).addListener(ChannelFutureListener.CLOSE); } }); } }).</description></item><item><title>Java实现Autowired自动注入</title><link>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0autowired%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</link><pubDate>Fri, 16 Jul 2021 21:22:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0autowired%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</guid><description>继续使用上个文章的类容器
创建一个注解
@Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Autowired { } 遍历所有字段包括私有的
private void autowired() { for (Map.Entry&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; classObjectEntry : classes.entrySet()) { for (Field declaredField : classObjectEntry.getKey().getDeclaredFields()) { declaredField.setAccessible(true); if (classes.get(declaredField.getType()) != null) {//容器内是否有这个类的对象 try { //赋值 declaredField.set(classObjectEntry.getValue(), classes.get(declaredField.getType())); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } } 在加入到容器后就调用autowired
public ClassContainer() { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; scanClasses = new ArrayList&amp;lt;&amp;gt;(List.of(Test1.class, Test2.class));//注意这里Test2也被加入到了容器里 scanClasses.forEach(it -&amp;gt; { try { classes.put(it, it.getConstructor().newInstance()); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { e.</description></item><item><title>Java 实现一个类容器</title><link>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%B9%E5%99%A8/</link><pubDate>Fri, 16 Jul 2021 20:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%B9%E5%99%A8/</guid><description>新建2个类
public class Test1 { } public class Test2 { public void render() { System.out.println(&amp;#34;Test2&amp;#34;); } } public class ClassContainer { private final HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; classes = new HashMap&amp;lt;&amp;gt;(); public ClassContainer() { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; scanClasses = new ArrayList&amp;lt;&amp;gt;(List.of(Test1.class));//被扫描到的类 上个文章介绍了如何遍历类路径所有类 scanClasses.forEach(it -&amp;gt; { try { classes.put(it, it.getConstructor().newInstance());//创建对象 直接newInstance的方法被弃用 所以需要获取无参构造方法再创建对象 } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { e.printStackTrace(); } }); } public &amp;lt;T&amp;gt; T create(Class&amp;lt;T&amp;gt; klass, Object instance) { classes.</description></item><item><title>Java遍历类路径所有类</title><link>https://blog.enaium.cn/post/2021-7-16-java%E9%81%8D%E5%8E%86%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%80%E6%9C%89%E7%B1%BB/</link><pubDate>Fri, 16 Jul 2021 09:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E9%81%8D%E5%8E%86%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%80%E6%9C%89%E7%B1%BB/</guid><description>public class WalkClasspathAllClasses { public static void main(String[] args) throws URISyntaxException, IOException { List&amp;lt;URL&amp;gt; urls = new ArrayList&amp;lt;&amp;gt;(); //获取Classpath if (WalkClasspathAllClasses.class.getClassLoader() instanceof URLClassLoader) { Collections.addAll(urls, ((URLClassLoader) WalkClasspathAllClasses.class.getClassLoader()).getURLs()); } else { for (String s : System.getProperty(&amp;#34;java.class.path&amp;#34;).split(&amp;#34;;&amp;#34;)) { urls.add(new File(s).toURI().toURL()); } } //遍历所有类 walkAllClasses(urls).forEach(System.out::println); } private static Set&amp;lt;String&amp;gt; walkAllClasses(List&amp;lt;URL&amp;gt; urls) throws URISyntaxException, IOException { Set&amp;lt;String&amp;gt; classes = new HashSet&amp;lt;&amp;gt;(); for (URL url : urls) { if (url.toURI().getScheme().equals(&amp;#34;file&amp;#34;)) {//判断Scheme是不是file File file = new File(url.</description></item><item><title>Minecraft启动器开发#7正版登录</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%237%E6%AD%A3%E7%89%88%E7%99%BB%E5%BD%95/</link><pubDate>Sun, 16 May 2021 21:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%237%E6%AD%A3%E7%89%88%E7%99%BB%E5%BD%95/</guid><description>public static String doPost(URL url, String post) throws IOException { byte[] bytes = post.getBytes(StandardCharsets.UTF_8); HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.setRequestMethod(&amp;#34;POST&amp;#34;); con.setDoOutput(true); con.setRequestProperty(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json; charset=utf-8&amp;#34;); con.setRequestProperty(&amp;#34;Content-Length&amp;#34;, String.valueOf(bytes.length)); IOUtils.write(bytes, con.getOutputStream()); return IOUtils.toString(con.getInputStream(), StandardCharsets.UTF_8); } 发送post请求
请求地址https://authserver.mojang.com/authenticate
类型为application/json
{ &amp;#34;agent&amp;#34;: { // defaults to Minecraft &amp;#34;name&amp;#34;: &amp;#34;Minecraft&amp;#34;, // For Mojang&amp;#39;s other game Scrolls, &amp;#34;Scrolls&amp;#34; should be used &amp;#34;version&amp;#34;: 1 // This number might be increased // by the vanilla client in the future }, &amp;#34;username&amp;#34;: &amp;#34;mojang account name&amp;#34;, // Can be an email address or player name for // unmigrated accounts &amp;#34;password&amp;#34;: &amp;#34;mojang account password&amp;#34;, &amp;#34;clientToken&amp;#34;: &amp;#34;client identifier&amp;#34;, // optional &amp;#34;requestUser&amp;#34;: true // optional; default: false; true adds the user object to the response } 参数</description></item><item><title>Minecraft启动器开发#6下载Native</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%236%E4%B8%8B%E8%BD%BDnative/</link><pubDate>Sun, 16 May 2021 13:49:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%236%E4%B8%8B%E8%BD%BDnative/</guid><description>if (downloads.has(&amp;#34;classifiers&amp;#34;)) { var classifiers = downloads.get(&amp;#34;classifiers&amp;#34;).getAsJsonObject(); var nativeName = &amp;#34;natives-linux&amp;#34;; var osName = System.getProperty(&amp;#34;os.name&amp;#34;).toLowerCase(Locale.ROOT); if (osName.contains(&amp;#34;win&amp;#34;)) { nativeName = &amp;#34;natives-windows&amp;#34;; if (!classifiers.has(nativeName)) { nativeName = &amp;#34;natives-windows-64&amp;#34;; } } else if (osName.contains(&amp;#34;mac&amp;#34;)) { nativeName = &amp;#34;natives-osx&amp;#34;; if (!classifiers.has(nativeName)) { nativeName = &amp;#34;natives-macos&amp;#34;; } } if (!classifiers.has(&amp;#34;nativeName&amp;#34;)) { continue; } var path = new File(libraryDir, classifiers.get(nativeName).getAsJsonObject().get(&amp;#34;path&amp;#34;).getAsString()); var url = classifiers.get(nativeName).getAsJsonObject().get(&amp;#34;url&amp;#34;).getAsString(); if (!path.exists()) { FileUtils.writeByteArrayToFile(path, IOUtils.toByteArray(new URL(url))); } } 下载库的时候下载Native，osx在以后的版本会变成macos需要再次判断，windows还需要判断系统架构
if (!path.exists()) { FileUtils.</description></item><item><title>Minecraft启动器开发#5下载资源</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%235%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</link><pubDate>Sun, 16 May 2021 11:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%235%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</guid><description>var assetsDir = new File(gameDir, &amp;#34;assets&amp;#34;); 将资源目录改为.minecraft的assets目录
var indexDir = new File(assetsDir, &amp;#34;indexes&amp;#34;); if (!indexDir.exists()) { indexDir.mkdir(); } var objectDir = new File(assetsDir, &amp;#34;objects&amp;#34;); if (!objectDir.exists()) { objectDir.mkdir(); } 创建indexes和objects目录
public class AssetObject { private final String hash; private final long size; public AssetObject(String hash, long size) { this.hash = hash; this.size = size; } public String getHash() { return hash; } public long getSize() { return size; } } 创建AssetObject类</description></item><item><title>Minecraft启动器开发#4下载库</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%234%E4%B8%8B%E8%BD%BD%E5%BA%93/</link><pubDate>Sat, 15 May 2021 19:49:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%234%E4%B8%8B%E8%BD%BD%E5%BA%93/</guid><description>var libraryDir = new File(gameDir,&amp;#34;libraries&amp;#34;); 设置库的路径
for (JsonElement jsonElement : gameJson.get(&amp;#34;libraries&amp;#34;).getAsJsonArray()) { var downloads = jsonElement.getAsJsonObject().get(&amp;#34;downloads&amp;#34;).getAsJsonObject(); if (downloads.has(&amp;#34;artifact&amp;#34;)) { var artifact = downloads.get(&amp;#34;artifact&amp;#34;).getAsJsonObject(); var path = new File(libraryDir, artifact.get(&amp;#34;path&amp;#34;).getAsString()); if (!path.exists()) { FileUtils.writeByteArrayToFile(path,IOUtils.toByteArray(new URL(artifact.get(&amp;#34;url&amp;#34;).getAsString()))); } } } 遍历出所有库 获取url下载到指定路径
var libraryDir = new File(gameDir,&amp;#34;libraries&amp;#34;); for (JsonElement jsonElement : gameJson.get(&amp;#34;libraries&amp;#34;).getAsJsonArray()) { var downloads = jsonElement.getAsJsonObject().get(&amp;#34;downloads&amp;#34;).getAsJsonObject(); if (downloads.has(&amp;#34;artifact&amp;#34;)) { var artifact = downloads.get(&amp;#34;artifact&amp;#34;).getAsJsonObject(); var path = new File(libraryDir, artifact.get(&amp;#34;path&amp;#34;).getAsString()); libraries.append(path).append(&amp;#34;;&amp;#34;); if (!path.exists()) { FileUtils.</description></item><item><title>Minecraft启动器开发#3下载游戏</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%233%E4%B8%8B%E8%BD%BD%E6%B8%B8%E6%88%8F/</link><pubDate>Sat, 15 May 2021 16:31:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%233%E4%B8%8B%E8%BD%BD%E6%B8%B8%E6%88%8F/</guid><description>gameVersion改为titleVersion var gameVersion = &amp;quot;1.8.9&amp;quot;;声明变量，指定游戏版本
引入commons-io和gson
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 读取游戏列表访问https://launchermeta.mojang.com/mc/game/version_manifest_v2.json
var gson = new Gson(); var gameListJson = IOUtils.toString(new URL(&amp;#34;https://launchermeta.mojang.com/mc/game/version_manifest_v2.json&amp;#34;), StandardCharsets.UTF_8); var gameList = gson.fromJson(gameListJson, JsonObject.class).get(&amp;#34;versions&amp;#34;).getAsJsonArray(); var gameJsonURL = &amp;#34;&amp;#34;; for (JsonElement jsonElement : gameList) { if (jsonElement.getAsJsonObject().get(&amp;#34;id&amp;#34;).getAsString().equals(gameVersion)) { gameJsonURL = jsonElement.getAsJsonObject().get(&amp;#34;url&amp;#34;).getAsString(); } } if (gameJsonURL.equals(&amp;#34;&amp;#34;)) { throw new RuntimeException(gameVersion + &amp;#34; Not Found!&amp;#34;); } 获取versions遍历出所以版本，之后获取指定版本的json
如果没找到版本就抛出异常
var gameJson = gson.fromJson(IOUtils.toString(new URL(gameJsonURL), StandardCharsets.UTF_8), JsonObject.</description></item><item><title>Minecraft启动器开发#2启动游戏</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%232%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</link><pubDate>Sat, 15 May 2021 13:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%232%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</guid><description>var name = &amp;#34;mcc&amp;#34;; var version = &amp;#34;1.0&amp;#34;; var java = System.getProperty(&amp;#34;java.home&amp;#34;); var jvmArgs = &amp;#34;-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:G1NewSizePercent=20 -XX:G1ReservePercent=20 -XX:MaxGCPauseMillis=50 -XX:G1HeapRegionSize=16M -XX:-UseAdaptiveSizePolicy -XX:-OmitStackTraceInFastThrow -Xmn128m -Xmx1792m&amp;#34;; var natives = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/versions/1.8.9/natives&amp;#34;; var libraries = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/netty/1.6/netty-1.6.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/oshi-project/oshi-core/1.1/oshi-core-1.1.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/dev/jna/jna/3.4.0/jna-3.4.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/dev/jna/platform/3.4.0/platform-3.4.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/ibm/icu/icu4j-core-mojang/51.2/icu4j-core-mojang-51.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/codecjorbis/20101023/codecjorbis-20101023.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/codecwav/20101023/codecwav-20101023.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/libraryjavasound/20101123/libraryjavasound-20101123.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/librarylwjglopenal/20100824/librarylwjglopenal-20100824.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/soundsystem/20120107/soundsystem-20120107.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/google/guava/guava/17.0/guava-17.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-io/commons-io/2.4/commons-io-2.4.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-codec/commons-codec/1.9/commons-codec-1.9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/jinput/jinput/2.0.5/jinput-2.0.5.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/jutils/jutils/1.0.0/jutils-1.0.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/authlib/1.5.21/authlib-1.5.21.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/realms/1.7.59/realms-1.7.59.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/httpcomponents/httpclient/4.3.3/httpclient-4.3.3.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/httpcomponents/httpcore/4.3.2/httpcore-4.3.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/logging/log4j/log4j-api/2.0-beta9/log4j-api-2.0-beta9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/logging/log4j/log4j-core/2.0-beta9/log4j-core-2.0-beta9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl/2.9.4-nightly-20150209/lwjgl-2.9.4-nightly-20150209.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl_util/2.9.4-nightly-20150209/lwjgl_util-2.9.4-nightly-20150209.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/tv/twitch/twitch/6.5/twitch-6.5.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/versions/1.8.9/1.8.9.jar&amp;#34;; var mainClass = &amp;#34;net.minecraft.client.main.Main&amp;#34;; var username = &amp;#34;Enaium&amp;#34;; var gameVersion = &amp;#34;\&amp;#34; &amp;#34; + name + &amp;#34; &amp;#34; + version + &amp;#34; \&amp;#34;&amp;#34;; var gameDir = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft&amp;#34;; var assetsDir = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/assets&amp;#34;; var assetIndex = &amp;#34;1.8&amp;#34;; var uuid = &amp;#34;0&amp;#34;; var accessToken = &amp;#34;0&amp;#34;; var text = java + &amp;#34;/bin/java.</description></item><item><title>Minecraft启动器开发#1分析启动脚本</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%231%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</link><pubDate>Sat, 15 May 2021 11:11:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%231%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</guid><description>用HMCL生成启动脚本
var java = System.getProperty(&amp;#34;java.home&amp;#34;); 获取运行的java路径
-Dminecraft.client.jar=xxx没用可以删掉
-XX:xxJVM参数 可能需要
-Dfml.ignoreInvalidMinecraftCertificates=true -Dfml.ignorePatchDiscrepancies=true -XX:HeapDumpPath=MojangTricksIntelDriversForPerformance_javaw.exe_minecraft.exe.heapdump
这段可以直接删掉
-Djava.library.path navite 启动需要的native
-Dminecraft.launcher.brand启动器
-Dminecraft.launcher.version启动器版本
-cp classpath 启动需要的库
net.minecraft.client.main.Main 启动的主类
--username用户名(玩家名)
--version游戏左下角显示的版本
--gameDir游戏运行的目录save、log等文件会生成在这里
--assetsDir游戏资源路径
--assetIndex游戏资源的Index文件名
--uuid玩家的UUID
--accessToken Token会过期 每次登录都会重新生成
--userProperties {}玩家的资产 不用管
--userType玩家类型 mojang表示是mojang账户
--width 854 --height 480窗口的大小</description></item><item><title>[ASM教程]#6树API</title><link>https://blog.enaium.cn/post/2021-4-27-asm%E6%95%99%E7%A8%8B%236%E6%A0%91api/</link><pubDate>Tue, 27 Apr 2021 15:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-27-asm%E6%95%99%E7%A8%8B%236%E6%A0%91api/</guid><description>使用树API来生成一个类
public static void main(String[] args) { ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); ClassNode classNode = new ClassNode(); classNode.visit(V1_8, ACC_PUBLIC, &amp;#34;cn/enaium/learn/asm/learn6/Learn6Test&amp;#34;, null, &amp;#34;java/lang/Object&amp;#34;, null); MethodNode methodNode = new MethodNode(ACC_PUBLIC + ACC_STATIC, &amp;#34;render&amp;#34;, &amp;#34;()V&amp;#34;, null, null);//一个方法 methodNode.instructions.add(new FieldInsnNode(GETSTATIC, &amp;#34;java/lang/System&amp;#34;, &amp;#34;out&amp;#34;, &amp;#34;Ljava/io/PrintStream;&amp;#34;)); methodNode.instructions.add(new LdcInsnNode(&amp;#34;Hello ASM!&amp;#34;)); methodNode.instructions.add(new MethodInsnNode(INVOKEVIRTUAL, &amp;#34;java/io/PrintStream&amp;#34;, &amp;#34;println&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false)); methodNode.visitMaxs(2, 1); methodNode.instructions.add(new InsnNode(RETURN)); classNode.methods.add(methodNode);//添加方法 classNode.accept(classWriter); String name = Learn2.class.getResource(&amp;#34;/cn/enaium/learn/asm/learn6/&amp;#34;).getPath() + &amp;#34;Learn6Test.class&amp;#34;; try { FileOutputStream out = new FileOutputStream(name); out.write(classWriter.toByteArray()); out.close(); } catch (Exception e) { e.</description></item><item><title>120行代码手写一个简单的MyBatis实现简单的CRUD</title><link>https://blog.enaium.cn/post/2021-4-21-120%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mybatis%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84crud/</link><pubDate>Wed, 21 Apr 2021 20:57:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-21-120%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mybatis%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84crud/</guid><description>不用XML只用注解
首先需要创建6个注解
SQL用于输入SQL语句
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface SQL { String[] value(); } 用来表示这个方法是Update
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Update { } 用来表示这个方法是Select
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Select { } 用来表示这个方法是Insert
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Insert { } 用来表示这个方法是Delete
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Delete { } 用来表示方法参数名
@Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface Param { String value(); } 好了注解写完了
开始写主类
用map实现简单的配置，然后读取配置连接数据库，然后程序关闭的时候关闭连接。
public class Satis { private final Statement statement; public Satis(Map&amp;lt;String, String&amp;gt; config) throws Exception { Class.</description></item><item><title>详细介绍如何发布到Maven中央仓库</title><link>https://blog.enaium.cn/post/2021-4-15-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</link><pubDate>Thu, 15 Apr 2021 11:10:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-15-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</guid><description>注册账户 https://issues.sonatype.org
发布问题(创建新的工程) https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134
摘要:项目名称
Group Id:组名 这里要用自己的域名的话一定要保证有域名的所有权,后面会让你添加dns记录来验证
Project URL仓库地址 SCM URL git地址
之后创建
等待回复 会让你添加DNS记录
添加后回复,这个地址要使用这个工具才能访问,直接执行命令后面跟着地址就行
等待回复之后就能上传了,他说上传之后回复
这里我使用Gradle
加上这2个插件
plugins { id &amp;#39;maven-publish&amp;#39; id &amp;#39;signing&amp;#39; } doc 和 source
java { withJavadocJar() withSourcesJar() } 发布配置 配置后先别刷新
publishing { //配置仓库 repositories { //本地仓库 def ENV = System.getenv() if (ENV.MAVEN_URL) { maven { url ENV.MAVEN_URL } } //远程仓库 maven { url &amp;#34;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&amp;#34; credentials { username ossrhUsername password ossrhPassword } } } publications { mavenJava(MavenPublication) { groupId project.</description></item><item><title>[ASM教程]#5字符串混淆</title><link>https://blog.enaium.cn/post/2021-3-19-asm%E6%95%99%E7%A8%8B%235%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/</link><pubDate>Fri, 19 Mar 2021 20:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-19-asm%E6%95%99%E7%A8%8B%235%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/</guid><description>测试类，需要混淆这里所有的字符串，上一期我们学习了如果插入一个常量，那么拦截插入常量的时候判断是不是字符串，如果是就混淆它。
public class Learn5Test { private final String name = &amp;#34;Enaium&amp;#34;; private Learn5Test() { render(name); } private void render() { System.out.println(&amp;#34;obfuscatory by &amp;#34; + name); } private void render(String text) { System.out.println(text); } } 重写方法访问。
@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { return new MethodVisitor(api, super.visitMethod(access, name, desc, signature, exceptions)) { }; } 重写常量访问。
@Override public void visitLdcInsn(Object cst) { } @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { return new MethodVisitor(api, super.</description></item><item><title>[ASM教程]#4创建对象和数组</title><link>https://blog.enaium.cn/post/2021-3-3-asm%E6%95%99%E7%A8%8B%234%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</link><pubDate>Wed, 03 Mar 2021 14:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-3-asm%E6%95%99%E7%A8%8B%234%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</guid><description>这期我们要创建一个对象和数组。
MethodVisitor methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;()V&amp;#34;, null, null); methodVisitor.visitTypeInsn(NEW, &amp;#34;java/lang/String&amp;#34;);//插入一个对象，操作码是NEW，类型是String。 methodVisitor.visitLdcInsn(&amp;#34;Enaium&amp;#34;);//插入一个LDC常量。 methodVisitor.visitMethodInsn(INVOKESPECIAL, &amp;#34;java/lang/String&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false);//插入方法调用，调用String的构造方法。 //用刚才的方法创建。 methodVisitor.visitTypeInsn(NEW, &amp;#34;cn/enaium/learn/asm/learn4/Bean&amp;#34;); methodVisitor.visitLdcInsn(&amp;#34;Enaium&amp;#34;); methodVisitor.visitMethodInsn(INVOKESPECIAL, &amp;#34;cn/enaium/learn/asm/learn4/Bean&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false); methodVisitor.visitIntInsn(SIPUSH, 2);//先需要给一个数组长度。 methodVisitor.visitIntInsn(NEWARRAY, T_BYTE);//插入一个数组，类型是byte。 methodVisitor.visitInsn(DUP);//插入一个操作，将数据压入站。 methodVisitor.visitIntInsn(SIPUSH, 0);//插入数组0的位置。 methodVisitor.visitIntInsn(SIPUSH, 1);//插入一。 methodVisitor.visitInsn(AASTORE);//保存数据。 //重复这四个操作，在数组1的位置插入二。 methodVisitor.visitInsn(DUP); methodVisitor.visitIntInsn(SIPUSH, 1); methodVisitor.visitIntInsn(SIPUSH, 2); methodVisitor.visitInsn(AASTORE); methodVisitor.visitEnd(); Bean
public class Bean { private final String name; public Bean(String name) { this.name = name; } public String getName() { return name; } }</description></item><item><title>[ASM教程]#3增加移除类成员</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%233%E5%A2%9E%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%B1%BB%E6%88%90%E5%91%98/</link><pubDate>Tue, 02 Mar 2021 23:24:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%233%E5%A2%9E%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%B1%BB%E6%88%90%E5%91%98/</guid><description>可以委托一个ClassWriter。
public class MyClassVisitor extends ClassVisitor { public MyClassVisitor(ClassWriter classWriter) { super(ASM5, classWriter); } } 这样就可以把读取到的类转换为二进制文件了。
ClassReader classReader = new ClassReader(Learn3Test.class.getName()); ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); MyClassVisitor myClassVisitor = new MyClassVisitor(classWriter); classReader.accept(myClassVisitor, 0); classWriter.toByteArray(); 重写字段访问方法，如果字段的名字一致，就返回null。
@Override public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) { if (name.equals(&amp;#34;aBoolean&amp;#34;)) { return null; } return super.visitField(access, name, desc, signature, value); } 移除方法也是一样。
@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { if (name.</description></item><item><title>[ASM教程]#2生成类</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%232%E7%94%9F%E6%88%90%E7%B1%BB/</link><pubDate>Tue, 02 Mar 2021 15:31:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%232%E7%94%9F%E6%88%90%E7%B1%BB/</guid><description>public class Learn2 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); classWriter.visit(V1_8, ACC_PUBLIC, &amp;#34;cn/enaium/learn/asm/learn2/Learn2Test&amp;#34;, null, &amp;#34;java/lang/Object&amp;#34;, null);//类信息 MethodVisitor methodVisitor = classWriter.visitMethod(ACC_PUBLIC + ACC_STATIC, &amp;#34;render&amp;#34;, &amp;#34;()V&amp;#34;, null, null);//插入方法 methodVisitor.visitFieldInsn(GETSTATIC, &amp;#34;java/lang/System&amp;#34;, &amp;#34;out&amp;#34;, &amp;#34;Ljava/io/PrintStream;&amp;#34;);//插入字段 methodVisitor.visitLdcInsn(&amp;#34;Hello ASM!&amp;#34;);//插入LDC methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &amp;#34;java/io/PrintStream&amp;#34;, &amp;#34;println&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false);//插入方法 methodVisitor.visitMaxs(2, 1);//设置栈和局部变量大小 methodVisitor.visitInsn(RETURN);//插入返回 methodVisitor.visitEnd();//结束 classWriter.visitEnd();//结束 //生成类 try { FileOutputStream out = new FileOutputStream(Learn2.class.getResource(&amp;#34;/cn/enaium/learn/asm/learn2/&amp;#34;).getPath() + &amp;#34;Learn2Test.class&amp;#34;); out.write(classWriter.toByteArray()); out.close(); } catch (Exception e) { e.printStackTrace(); } } }</description></item><item><title>[ASM教程]#1分析类</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%231%E5%88%86%E6%9E%90%E7%B1%BB/</link><pubDate>Tue, 02 Mar 2021 14:07:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B%231%E5%88%86%E6%9E%90%E7%B1%BB/</guid><description>ASM是一种通用Java字节码操作和分析框架，它可以用于修改现有的class文件或动态生成class文件。
直接进入主题，分析这个类。
public class Learn1Test { public boolean aBoolean = false; public void render() { System.out.println(&amp;#34;Hello ASM&amp;#34;); } } 先创建一个MyClassVisitor类，继承ClassVisitor。
public class MyClassVisitor extends ClassVisitor { public MyClassVisitor() { super(ASM5); } @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) { System.out.println(name + &amp;#34; extends &amp;#34; + superName + &amp;#34; {&amp;#34;); super.visit(version, access, name, signature, superName, interfaces); } @Override public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) { System.</description></item><item><title>[LWJGL3 2D教程]#6VBO</title><link>https://blog.enaium.cn/post/2021-2-28-lwjgl3-2d%E6%95%99%E7%A8%8B%236vbo/</link><pubDate>Sun, 28 Feb 2021 21:33:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-28-lwjgl3-2d%E6%95%99%E7%A8%8B%236vbo/</guid><description>创建一个Model类
public class Model { private int draw_count; private int v_id; private int t_id; public Model(float[] vertices, float[] tex_coords) { draw_count = vertices.length / 3; v_id = glGenBuffers(); glBindBuffer(GL_ARRAY_BUFFER, v_id);//绑定 glBufferData(GL_ARRAY_BUFFER, createFloatBuffer(vertices), GL_STATIC_DRAW);//静态绘制 t_id = glGenBuffers(); glBindBuffer(GL_ARRAY_BUFFER, t_id);//绑定 glBufferData(GL_ARRAY_BUFFER, createFloatBuffer(tex_coords), GL_STATIC_DRAW);//静态绘制 glBindBuffer(GL_ARRAY_BUFFER, 0);//取消绑定 } public void render() { glEnableClientState(GL_VERTEX_ARRAY);//启用顶点数组 glEnableClientState(GL_TEXTURE_COORD_ARRAY);//启用坐标数组 glBindBuffer(GL_ARRAY_BUFFER, v_id);//绑定 glVertexPointer(3, GL_FLOAT, 0, 0);//顶点 glBindBuffer(GL_ARRAY_BUFFER, t_id);//绑定 glTexCoordPointer(2, GL_FLOAT, 0, 0);// 坐标 glDrawArrays(GL_TRIANGLES, 0, draw_count);//绘制数组 glBindBuffer(GL_ARRAY_BUFFER, 0);//取消绑定 glDisableClientState(GL_VERTEX_ARRAY);//禁用顶点数组 glDisableClientState(GL_TEXTURE_COORD_ARRAY);//禁用坐标数组 } //创建缓冲区 private FloatBuffer createFloatBuffer(float[] data) { FloatBuffer buffer = BufferUtils.</description></item><item><title>自写一个EventBus</title><link>https://blog.enaium.cn/post/2021-2-23-%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAeventbus/</link><pubDate>Tue, 23 Feb 2021 22:09:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-23-%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAeventbus/</guid><description>EventBus，什么是EventBus。
EventBus是事件发布-订阅总线，简单来说监听一个事件，一个方法订阅这个事件，如果事件调用，那么订阅了这个事件的方法也会跟着调用，这就是EventBus。
创建一个注解，用于订阅事件，名字可以随便起，当然也可以叫Subscribe，我这里叫Event。
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Event { } 创建Listener监听器。
public class Listener { } 创建MethodBean类，来储存订阅方法，Object是订阅类的对象，Method就是被订阅的方法。
public class MethodBean { private final Object object; private final Method method; public MethodBean(Object object, Method method) { this.object = object; this.method = method; } public Object getObject() { return object; } public Method getMethod() { return method; } } 创建一个EventManager，来管理订阅的事件。
public class EventManager { } 创建一个HashMap合集K是监听器，V是被调用的方法，因为一个监听器可能有多个方法，并且要保证线程安全，需要使用CopyOnWriteArrayList。
public class EventManager { private final HashMap&amp;lt;Class&amp;lt;?</description></item><item><title>[CF4M教程]#5扩展</title><link>https://blog.enaium.cn/post/2021-2-22-cf4m%E6%95%99%E7%A8%8B%235%E6%89%A9%E5%B1%95/</link><pubDate>Mon, 22 Feb 2021 23:30:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-22-cf4m%E6%95%99%E7%A8%8B%235%E6%89%A9%E5%B1%95/</guid><description>现在CF4M已经更新到了1.4.7版本，现在不需用调用stop了。
public enum Example { INSTANCE; public void run() { CF4M.INSTANCE.run(this, Minecraft.getMinecraft().mcDataDir.toString() + &amp;#34;/Example&amp;#34;); } } 只需用在Module中创建一个变量，加上Setting注解即可。
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Setting(&amp;#34;test1&amp;#34;) private EnableSetting test1 = new EnableSetting(false); } CF4M没有附带Setting，需要自定义一个Setting。
public class EnableSetting { private boolean enable; public EnableSetting(boolean enable) { this.enable = enable; } public boolean getEnable() { return enable; } public void setEnable(boolean enable) { this.enable = enable; } } 自定义Event，继承Listener，要注意是CF4M的Listener，At这个参数是枚举型，分别是HEAD、TAIL和NONE，表示监听的位置，如果没有确定位置就用NONE。
要调用Call才能使Event监听这个事件。
public class Render2DEvent extends Listener { public Render2DEvent() { super(At.</description></item><item><title>[LWJGL3 2D教程]#5绘制纹理</title><link>https://blog.enaium.cn/post/2021-2-22-lwjgl3-2d%E6%95%99%E7%A8%8B%235%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 22 Feb 2021 15:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-22-lwjgl3-2d%E6%95%99%E7%A8%8B%235%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86/</guid><description>先说原理
读取一张图片，然后获取图片所有的像素，根据像素的rgba来绘制
先创建一个Texture类
public class Texture { private int id; public Texture (String path) { try { BufferedImage image = ImageIO.read(Texture.class.getResource(path)); int[] pixels = new int[image.getWidth() * image.getHeight()];//创建像素列表 image.getRGB(0, 0, image.getWidth(), image.getHeight(), pixels, 0, image.getWidth());//获取图片像素 ByteBuffer buffer = BufferUtils.createByteBuffer(image.getWidth() * image.getHeight() * 4);//创建字节缓冲区，*4是包含alpha *3不包含 //遍历图片像素转换为RGBA for (int y = 0; y &amp;lt; image.getHeight(); y++) { for (int x = 0; x &amp;lt; image.getWidth(); x++) { int pixel = pixels[y * image.</description></item><item><title>[LWJGL3 2D教程]#4按键</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%234%E6%8C%89%E9%94%AE/</link><pubDate>Sun, 21 Feb 2021 18:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%234%E6%8C%89%E9%94%AE/</guid><description>按键很简单，如果K按下，就会输出“K press“
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); if (glfwGetKey(window, GLFW_KEY_K) == GLFW_TRUE) { System.out.println(&amp;#34;K press&amp;#34;); } } 如果鼠标左键按下，就会输出“MouseLeft press“
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_TRUE) { System.out.println(&amp;#34;MouseLeft press&amp;#34;); } }</description></item><item><title>[LWJGL3 2D教程]#3绘制一个矩形</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%233%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2/</link><pubDate>Sun, 21 Feb 2021 17:50:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%233%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2/</guid><description>做一个当前上下文，创建一个createCapabilities。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); long window = glfwCreateWindow(640, 480, &amp;#34;My LWJGL Program&amp;#34;, 0, 0); if (window == NULL) { throw new RuntimeException(&amp;#34;Failed to create the GLFW window&amp;#34;); } glfwShowWindow(window); glfwMakeContextCurrent(window);//上下文 GL.createCapabilities();//createCapabilities while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } 绘制一个矩形
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); glClear(GL_COLOR_BUFFER_BIT);//清除缓冲区 glBegin(GL_QUADS);//绘制的形状(矩形) glColor4f(1, 0, 0, 0);//颜色 glVertex2d(-0.5f, 0.5f);//第一个点 glVertex2d(0.5f, 0.5f);//第二个点 glVertex2d(0.5f, -0.5f);//第三个点 glVertex2d(-0.5f, -0.5f);//第四个点 glEnd();//结束 glfwSwapBuffers(window);//交换缓冲区 }</description></item><item><title>[LWJGL3 2D教程]#2创建一个窗口</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%232%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</link><pubDate>Sun, 21 Feb 2021 16:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%232%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</guid><description>随便创建一个类，直接在main方法里执行就可以。
public static void main(String[] args) { } 先初始化，如果初始化失败，抛出异常。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } } 设置窗口默认状态。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); } 创建窗口，设置长、宽、标题，如果创建失败抛出异常。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); long window = glfwCreateWindow(640, 480, &amp;#34;My LWJGL Program&amp;#34;, NULL, NULL); if (window == NULL) { throw new RuntimeException(&amp;#34;Failed to create the GLFW window&amp;#34;); } glfwShowWindow(window); } 创建了一个窗口，但是很快就关闭了，可以在创建窗口后，使用死循环来保证窗口不会消失，当检测到窗口关闭时，退出循环。</description></item><item><title>[LWJGL3 2D教程]#1配置开发环境</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 21 Feb 2021 16:12:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>进入LWJGL下载
我这里选：Natives全选 使用Gradle Presets选择minimal OpenGL 版本3.2.3。
然后下面出现gradle的模板
新建一个Gradle项目，就叫lwjgl吧。
我的 build.gradle
plugins { id &amp;#39;java&amp;#39; } group &amp;#39;cn.enaium.learn&amp;#39; version &amp;#39;1.0-SNAPSHOT&amp;#39; import org.gradle.internal.os.OperatingSystem project.ext.lwjglVersion = &amp;#34;3.2.3&amp;#34; switch (OperatingSystem.current()) { case OperatingSystem.LINUX: def osArch = System.getProperty(&amp;#34;os.arch&amp;#34;) project.ext.lwjglNatives = osArch.startsWith(&amp;#34;arm&amp;#34;) || osArch.startsWith(&amp;#34;aarch64&amp;#34;) ? &amp;#34;natives-linux-${osArch.contains(&amp;#34;64&amp;#34;) || osArch.startsWith(&amp;#34;armv8&amp;#34;) ? &amp;#34;arm64&amp;#34; : &amp;#34;arm32&amp;#34;}&amp;#34; : &amp;#34;natives-linux&amp;#34; break case OperatingSystem.MAC_OS: project.ext.lwjglNatives = &amp;#34;natives-macos&amp;#34; break case OperatingSystem.WINDOWS: project.ext.lwjglNatives = System.getProperty(&amp;#34;os.arch&amp;#34;).contains(&amp;#34;64&amp;#34;) ? &amp;#34;natives-windows&amp;#34; : &amp;#34;natives-windows-x86&amp;#34; break } repositories { mavenCentral() } dependencies { implementation platform(&amp;#34;org.</description></item><item><title>[CF4M教程]#4写一个简单的Config</title><link>https://blog.enaium.cn/post/2021-2-21-cf4m%E6%95%99%E7%A8%8B%234%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84config/</link><pubDate>Sun, 21 Feb 2021 14:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-cf4m%E6%95%99%E7%A8%8B%234%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84config/</guid><description>创建一个ModuleConfig类。
public class ModuleConfig { } 加上Config注解。
@Config(&amp;#34;Modules&amp;#34;) public class ModuleConfig { } 加入2个方法，分别写上Load和Save注解，分别是启动和退出的时候调用。
@Config(&amp;#34;Modules&amp;#34;) public class ModuleConfig { @Load public void load() { } @Save public void save() { } } 这是加载的方法。
@Load public void load() { for (ModuleProvider module : CF4M.MODULE.getAll()) {//遍历所有Module JsonArray jsonArray = new JsonArray(); try { jsonArray = new Gson().fromJson(read(CF4M.CONFIG.getByInstance(this).getPath()), JsonArray.class);//读取配置文件并存入JsonArray } catch (IOException e) { e.printStackTrace(); } for (JsonElement jsonElement : jsonArray) {//遍历JsonArray JsonObject jsonObject = jsonElement.</description></item><item><title>[CF4M教程]#3写一个简单的Command</title><link>https://blog.enaium.cn/post/2021-2-18-cf4m%E6%95%99%E7%A8%8B%233%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84command/</link><pubDate>Thu, 18 Feb 2021 14:41:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-18-cf4m%E6%95%99%E7%A8%8B%233%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84command/</guid><description>创建一个简单的Command，就叫“ToggleCommand”吧。
public class ToggleCommand { } 添加一个Command注解，只有一个参数，所以value不用写，String数组类型，就是使用这个Command的命令，可以使用“h”或者“help”来使用，当然，也可以添加更多的。
@Command({&amp;#34;t&amp;#34;, &amp;#34;toggle&amp;#34;}) public class ToggleCommand { } 只需要一个方法，加上Exec注解，命令有几个参数，方法写几个参数，就可以。
@Command({&amp;#34;t&amp;#34;, &amp;#34;toggle&amp;#34;}) public class ToggleCommand { @Exec private void exec(@Param(&amp;#34;module&amp;#34;) String name) { Object module = CF4M.INSTANCE.module.getModule(name); if (module == null) { CF4M.INSTANCE.configuration.message(&amp;#34;The module with the name &amp;#34; + name + &amp;#34; does not exist.&amp;#34;); return; } CF4M.INSTANCE.module.enable(module); } } 那么这个“configuration.message”是什么呢？
我们需要重写配置接口，来进行文本输出，默认是在控制台输出，注意要加上“Configuration”
@Configuration public class ExampleConfig implements IConfiguration { @Override public void message(String message) { MinecraftClient.</description></item><item><title>[CF4M教程]#1准备</title><link>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B%231%E5%87%86%E5%A4%87/</link><pubDate>Tue, 16 Feb 2021 13:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B%231%E5%87%86%E5%A4%87/</guid><description>访问CF4M文档
CF4M(Client Minecraft for Minecraft)是Minecraft的客户端框架可以它可以便捷的写Module,Setting,Command,Config.等等
导入 添加maven仓库
allprojects { repositories { maven { url &amp;#39;https://maven.enaium.cn&amp;#39; } } } 使用最新的CF4M 写这个文档的时候最新版是 1.8.1
dependencies { implementation &amp;#39;cn.enaium.cf4m:cf4m:1.8.1&amp;#39; } Fabric 导入 如果您用的是Fabric请导入下面的
dependencies { modImplementation &amp;#39;cn.enaium.cf4m:cf4m-fabric:1.8.1&amp;#39; } 还需要您在fabric.mod.json文件里添加
&amp;#34;depends&amp;#34;: { &amp;#34;cf4m&amp;#34;: &amp;#34;&amp;gt;=1.8.1&amp;#34; } 当然还需用在mods文件夹放入这个mod
使用 public void run() { CF4M.run(this); //参数1:当前的主类,参数2:客户端的目录(游戏目录/客户端名) // CF4M.run(this, Minecraft.getMinecraft().mcDataDir.toString() + &amp;#34;/&amp;#34; + name); } public void stop() { CF4M.stop(); } 在游戏的启动和停止的时候调用run
之后写的Module Command Config 等等都要和主类在同一包下
需要注意的是,如果您使用的是Mixin注入的方式也要这样做. mixins的包也不要和主类在同一个包下.
✔正确示范</description></item><item><title>[CF4M教程]#2写一个简单的Module</title><link>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B%232%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84module/</link><pubDate>Tue, 16 Feb 2021 13:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B%232%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84module/</guid><description>创建一个Sprint类.
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { } 加上了一个@Module注解.
默认参数value 就是Module的名字.
打开或关闭 在加上2个方法 分别加上@Enable和@Disbale.
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Enable public void onEnable() { System.out.println(&amp;#34;onEnable&amp;#34;); } @Disable public void onDisable() { System.out.println(&amp;#34;onDisable&amp;#34;); } } 在这个Module打开或者关闭的时候,分别调用onEnable和onDisable. 当然方法名可以随别写.
事件 @Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Event private void onUpdate(UpdateEvent updateEvent) { Minecraft.getMinecraft().thePlayer.setSprinting(true);//设置疾跑状态为true } @Enable public void onEnable() { System.out.println(&amp;#34;onEnable&amp;#34;); } @Disable public void onDisable() { System.out.println(&amp;#34;onDisable&amp;#34;); } } 在已经打开这个Module的前提下,如果触发了这个事件,那么就会执行这个方法.
快捷键,分类,默认启用 @Module注解有4个值,其中3个值都有默认值
String value();//Module名无默认值,必须填写 boolean enable() default false;//如果需要默认启用的话那么就设置为true int key() default 0;//快捷键 Category category() default Category.</description></item><item><title>[BlocklyNukkit入门]#10高级工作台合成</title><link>https://blog.enaium.cn/post/2021-1-19-blocklynukkit%E5%85%A5%E9%97%A8%2310%E9%AB%98%E7%BA%A7%E5%B7%A5%E4%BD%9C%E5%8F%B0%E5%90%88%E6%88%90/</link><pubDate>Tue, 19 Jan 2021 18:34:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-1-19-blocklynukkit%E5%85%A5%E9%97%A8%2310%E9%AB%98%E7%BA%A7%E5%B7%A5%E4%BD%9C%E5%8F%B0%E5%90%88%E6%88%90/</guid><description>创建一个物品
item = blockitem.buildItem(280, 0, 1); item.setCustomName(&amp;#34;棍&amp;#34;); blockitem.setItemLore(item, &amp;#34;第一行;第二行;第三行;第四行&amp;#34;); 添加高级工作台合成，背包里有材料才会显示
参数1类别，参数2描述，参数3材料，参数4合成的东西，参数5用时，参数6概率最大为1
blockitem.addBNCraft(&amp;#34;锻造&amp;#34;, &amp;#34;合成棍&amp;#34;, Java.to([item = blockitem.buildItem(264, 0, 1), item = blockitem.buildItem(41, 0, 2)], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), Java.to([item], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), 160, 1.0) 打开高级工作台合成
manager.newCommand(&amp;#34;dz&amp;#34;, &amp;#34;锻造&amp;#34;, function (sender, args) { blockitem.openBNCraftForPlayer(&amp;#34;锻造&amp;#34;, sender.getPlayer()); })</description></item><item><title>[BlocklyNukkit入门]#9实体</title><link>https://blog.enaium.cn/post/2021-1-15-blocklynukkit%E5%85%A5%E9%97%A8%239%E5%AE%9E%E4%BD%93/</link><pubDate>Fri, 15 Jan 2021 15:03:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-1-15-blocklynukkit%E5%85%A5%E9%97%A8%239%E5%AE%9E%E4%BD%93/</guid><description>当玩家使用铁锭时,把掉落物传送到玩家的位置.
事件PlayerInteractEvent 玩家交互,比如使用等等.
function PlayerInteractEvent(e) { player = e.getPlayer()//获取事件的玩家 item = blockitem.getItemInHand(player)//获取玩家手中的物品 dropItems = blockitem.getDropItems(player.getPosition())//获取玩家所在世界的掉落物 if (item.getId() == 265) {//获取物品ID是否为铁锭 for (let index = 0; index &amp;lt; dropItems.length; index++) { const element = dropItems[index]; element.setPosition(player.getPosition())//设置物品位置到玩家的位置 } } }</description></item><item><title>[BlocklyNukkit入门]#8高级窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%238%E9%AB%98%E7%BA%A7%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:10:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%238%E9%AB%98%E7%BA%A7%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;test&amp;#34;, &amp;#34;test&amp;#34;, function (sender, args) { var test = window.getCustomWindowBuilder(&amp;#34;Title&amp;#34;);//创建一个高级窗口 test.buildLabel(&amp;#34;Label&amp;#34;);//创建一个标签,参数1标题 test.buildInput(&amp;#34;Input&amp;#34;, &amp;#34;Input&amp;#34;);//创建一个输入框,参数1标题,参数2提示 test.buildToggle(&amp;#34;Toggle&amp;#34;);//创建一个开关,参数1标题 test.buildDropdown(&amp;#34;Dropdown&amp;#34;, &amp;#34;A;B;C;D;E;F;G&amp;#34;);//创建一个下拉框,参数1标题,参数2元素列表,用分号隔开 test.buildSlider(&amp;#34;Slider&amp;#34;, 0.0, 100.0, 1.0);//创建一个滑块条,参数1标题,参数2最小的值,参数3最大的值,参数4刻度 test.buildStepSlider(&amp;#34;StepSlider&amp;#34;, &amp;#34;A;B;C;D&amp;#34;);//创建一个 步骤滑块条,参数1标题,参数2元素列表,用分号隔开 test.showToPlayer(sender, &amp;#34;Call&amp;#34;); }) function Call(e) { logger.info(window./* 获取元素,参数2元素位置,从0开始,参数3元素类型 */getEventCustomVar(e, 1, &amp;#34;input&amp;#34;)); logger.info(window.getEventCustomVar(e, 2, &amp;#34;dropdown&amp;#34;)); logger.info(window.getEventCustomVar(e, 3, &amp;#34;slider&amp;#34;)); logger.info(window.getEventCustomVar(e, 4, &amp;#34;stepSlider&amp;#34;)); logger.info(window.getEventCustomVar(e, 5, &amp;#34;toggle&amp;#34;)); }</description></item><item><title>[BlocklyNukkit入门]#7选择窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%237%E9%80%89%E6%8B%A9%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:07:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%237%E9%80%89%E6%8B%A9%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;test&amp;#34;, &amp;#34;test&amp;#34;, function (sender, args) { var test = window.getModalWindowBuilder(&amp;#34;Test&amp;#34;, &amp;#34;Select&amp;#34;);//创建选择窗口 test.setButton1(&amp;#34;A&amp;#34;);//设置按钮1 test.setButton2(&amp;#34;B&amp;#34;);//设置按钮2 test.showToPlayer(sender, &amp;#34;Call&amp;#34;);//显示给玩家 }); function Call(e) { e.getPlayer().sendMessage(window.getEventResponseModal(e));//给玩家发送选择的按钮的消息 }</description></item><item><title>[BlocklyNukkit入门]#6简单窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%236%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8%236%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;pa&amp;#34;, &amp;#34;pa&amp;#34;, function (sender, args) { var pa = window.getSimpleWindowBuilder(&amp;#34;Pa&amp;#34;, &amp;#34;选择一个玩家&amp;#34;);//创建一个简单的窗口 //遍历全服玩家 onlines = Java.type(&amp;#34;cn.nukkit.Server&amp;#34;).getInstance().getOnlinePlayers().values().toArray(); for (let index = 0; index &amp;lt; onlines.length; index++) { const element = onlines[index]; pa.buildButton(element.getName(), &amp;#34;&amp;#34;);//添加按钮 参数1标题 参数2图片 没有留空 } pa.showToPlayer(sender, &amp;#34;Call&amp;#34;);//参数1显示的玩家 参数2函数名 });//创建命令 function Call(e)//显示给玩家的函数 { server.getPlayer(window.getEventResponseText(e)/* 获取按下的按钮名 */)/* 获取玩家 */.sendMessage(&amp;#34;Pa!&amp;#34;);//给玩家发送消息 }</description></item><item><title>[BlocklyNukkit入门]#5自定义物品</title><link>https://blog.enaium.cn/post/2020-10-19-blocklynukkit%E5%85%A5%E9%97%A8%235%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E5%93%81/</link><pubDate>Mon, 19 Oct 2020 19:51:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-19-blocklynukkit%E5%85%A5%E9%97%A8%235%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E5%93%81/</guid><description>自定义物品 创建一个木棍 item = blockitem.buildItem(280, 0, 1); 设置名字
item.setCustomName(&amp;#34;棍&amp;#34;); 设置信息,用分号隔开换行
blockitem.setItemLore(item, &amp;#34;第一行;第二行;第三行;第四行&amp;#34;); 添加有序合成 添加有序合成,设置G为橡木原木的键,G就代表原木. 参数1用字符串数组类型,3个字符串代表合成台的3行,每一行有3个物品,用键来代表,空格代表没物品. 参数2是合成后的物品. 参数3是追加结果物品，物品数组类型，比如合成蛋糕会返给3个桶.
manager.putEasy(&amp;#34;G&amp;#34;, blockitem.buildItemFromBlock(blockitem.buildBlock(17, 0))); blockitem.addShapedCraft(Java.to([&amp;#34;G &amp;#34;, &amp;#34;G &amp;#34;, &amp;#34;G &amp;#34;], &amp;#34;java.lang.String[]&amp;#34;), item, Java.to([], &amp;#34;cn.nukkit.item.Item[]&amp;#34;)); 创建第二个木棍 superItem = blockitem.buildItem(369, 0, 1); superItem.setCustomName(&amp;#34;Super棍&amp;#34;); blockitem.setItemLore(superItem, &amp;#34;第五行;第六行;第七行;第八行;第九行&amp;#34;); 添加无序合成 参数1就是需要合成的配方，参数2就是合成后的物品
blockitem.addShapelessCraft(Java.to([item, blockitem.buildItemFromBlock(blockitem.buildBlock(41, 0))], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), superItem);</description></item><item><title>[BlocklyNukkit入门]#4创建命令</title><link>https://blog.enaium.cn/post/2020-10-18-blocklynukkit%E5%85%A5%E9%97%A8%234%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 18 Oct 2020 22:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-18-blocklynukkit%E5%85%A5%E9%97%A8%234%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</guid><description>喊话 创建一个命令
manager.newCommand(&amp;#34;shout&amp;#34;, &amp;#34;喊话&amp;#34;, function (sender, args) { }); Python可以吧function改为方法名 比如
manager.createCommand(&amp;#34;shout&amp;#34;, u&amp;#34;喊话&amp;#34;, &amp;#34;myCallBack&amp;#34;) def myCallBack(sender, args): pass 遍历全服玩家
alllist = Java.type(&amp;#34;cn.nukkit.Server&amp;#34;).getInstance().getOnlinePlayers().values().toArray(); 向全服玩家发送消息
for (var i = 0; i &amp;lt; alllist.length; i++) { alllist[i].sendMessage(args[0]); }</description></item><item><title>[BlocklyNukkit入门]#3玩家进服欢迎</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%233%E7%8E%A9%E5%AE%B6%E8%BF%9B%E6%9C%8D%E6%AC%A2%E8%BF%8E/</link><pubDate>Sat, 03 Oct 2020 21:09:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%233%E7%8E%A9%E5%AE%B6%E8%BF%9B%E6%9C%8D%E6%AC%A2%E8%BF%8E/</guid><description>进服欢迎 我们可以在bn的文档里查到PlayerJoinEvent玩家进入服务器的事件 这样我们就可以很“方便”的编写插件了
JavaScript function PlayerJoinEvent(e) { e.getPlayer().sendMessage(&amp;#34;欢迎&amp;#34; + e.getPlayer().getName() + &amp;#34;进入服务器！JavaScript&amp;#34;); } Python def PlayerJoinEvent(e): e.getPlayer().sendMessage(u&amp;#34;欢迎&amp;#34; + e.getPlayer().getName() + u&amp;#34;进入服务器！Python&amp;#34;) Lua function PlayerJoinEvent(e) e:getPlayer():sendMessage(&amp;#34;欢迎&amp;#34; .. e:getPlayer():getName() .. &amp;#34;进入服务器！Lua&amp;#34;) end</description></item><item><title>[BlocklyNukkit入门]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 03 Oct 2020 20:32:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>配置Nukkit 这里用PowerNukkit举例
下载好之后用java -jar nukkit.jar运行客户端 语言选自选
如果没正版把server.properties里的xbox-auth=on改成xbox-auth=off
配置BlocklyNukkit 下载BlocklyNukkit放到./plugins文件夹里面
完成</description></item><item><title>[BlocklyNukkit入门]#2HelloWorld</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%232helloworld/</link><pubDate>Sat, 03 Oct 2020 20:32:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8%232helloworld/</guid><description>编写插件 BlocklyNukkit以下简称bn
bn支持JavaScript、Python和Lua等脚本语言 也有图形编辑器
JavaScript logger.info(&amp;#34;Hello JavaScript!&amp;#34;); Python 注意！ 如果有汉字等特殊字符要加上# -*- encoding: utf-8 -*-注释
print u&amp;#34;Hello Python!&amp;#34; Lua logger:info(&amp;#34;Hello Lua!&amp;#34;) 使用插件 放入文件夹./plugin/BlocklyNukkit里面</description></item><item><title>[30天自制操作系统]第一天错误解决</title><link>https://blog.enaium.cn/post/2020-9-25-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E5%A4%A9%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</link><pubDate>Fri, 25 Sep 2020 17:14:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-25-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E5%A4%A9%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</guid><description>书里的
; hello-os ; TAB=4 ; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code DB	0xeb, 0x4e, 0x90 DB	&amp;#34;HELLOIPL&amp;#34;	; 启动扇区名称（8字节） DW	512	; 每个扇区（sector）大小（必须512字节） DB	1	; 簇（cluster）大小（必须为1个扇区） DW	1	; FAT起始位置（一般为第一个扇区） DB	2	; FAT个数（必须为2） DW	224	; 根目录大小（一般为224项） DW	2880	; 该磁盘大小（必须为2880扇区1440*1024/512） DB	0xf0	; 磁盘类型（必须为0xf0） DW	9	; FAT的长度（必须是9扇区） DW	18	; 一个磁道（track）有几个扇区（必须为18） DW	2	; 磁头数（必须是2） DD	0	; 不使用分区，必须是0 DD	2880	; 重写一次磁盘大小 DB	0,0,0x29	; 意义不明（固定） DD	0xffffffff	; （可能是）卷标号码 DB	&amp;#34;HELLO-OS &amp;#34;	; 磁盘的名称（必须为11字节，不足填空格） DB	&amp;#34;FAT12 &amp;#34;	; 磁盘格式名称（必须是8字节，不足填空格） RESB	18	; 先空出18字节 ; 程序主体 DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb DB	0xee, 0xf4, 0xeb, 0xfd ; 信息显示部分 DB	0x0a, 0x0a	; 换行两次 DB	&amp;#34;hello, world&amp;#34; DB	0x0a	; 换行 DB	0 RESB	RESB 0x1fe-$	; 填写0x00直到0x001fe DB	0x55, 0xaa ; 启动扇区以外部分输出 DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB	4600 DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB	1469432 作者用的是nask 那么用nasm的话会出现 问题 .</description></item><item><title>[Jekyll入门]#4条件、循环</title><link>https://blog.enaium.cn/post/2020-9-24-jekyll%E5%85%A5%E9%97%A8%234%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Thu, 24 Sep 2020 19:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-24-jekyll%E5%85%A5%E9%97%A8%234%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>条件 循环</description></item><item><title>[Jekyll入门]#3布局</title><link>https://blog.enaium.cn/post/2020-9-23-jekyll%E5%85%A5%E9%97%A8%233%E5%B8%83%E5%B1%80/</link><pubDate>Wed, 23 Sep 2020 19:14:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-23-jekyll%E5%85%A5%E9%97%A8%233%E5%B8%83%E5%B1%80/</guid><description>布局 自定义 创建_layouts目录 创建布局post.html 布局使用布局 在布局中也能使用其他布局
默认布局 所有布局都会使用一个default的布局</description></item><item><title>[Jekyll入门]#2配置、帖子、页面</title><link>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8%232%E9%85%8D%E7%BD%AE%E5%B8%96%E5%AD%90%E9%A1%B5%E9%9D%A2/</link><pubDate>Tue, 22 Sep 2020 22:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8%232%E9%85%8D%E7%BD%AE%E5%B8%96%E5%AD%90%E9%A1%B5%E9%9D%A2/</guid><description>配置 title: Myblog #标题 email: Myblog@example.com #邮箱 description: &amp;gt;- #说明 This is my blog. baseurl: &amp;#34;&amp;#34; #仓库名 比如 myblog url: &amp;#34;&amp;#34; #域名 twitter_username: Myblog #推特 github_username: Myblog #github # Build settings theme: minima #主题 plugins: #插件 - jekyll-feed 帖子 文件名 日期-文件名(标题) 用-代表空格
头部信息 --- layout: post #布局 title: &amp;#34;My first post!&amp;#34; #标题 date: 2020-09-22 22:19 #时间 categroy: jekyll update #分类 --- 页面 文件名 文件名和链接名一致
头部信息 --- layout: page #布局 title: Donation #标题 permalink: /donation/ #永久链接 ---</description></item><item><title>[Jekyll入门]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 22 Sep 2020 19:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>安装Ruby RubyInstaller
安装Jekyll jekyll new myblog cd myblog jekyll serve 预览 http://127.0.0.1:4000/</description></item><item><title>Java插件化开发</title><link>https://blog.enaium.cn/post/2020-5-4-java%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 04 May 2020 09:17:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-5-4-java%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>在java程序开发过程中. 可能需要加载插件的功能. 所以要动态加载Jar文件来实现插件的加载.
我这边用了Kotlin
一. 创建接口 interface PluginInitializer { fun onInitialize()//插件初始化 } 二. 加载插件 加载的插件可能会抛出什么异常所以要用try
private val file = File(&amp;#34;plugins&amp;#34;) private val plugins: ArrayList&amp;lt;PluginInitializer&amp;gt; = ArrayList() init { try { if (file.listFiles().isNotEmpty()) { for (f in file.listFiles()) { if (f.name.endsWith(&amp;#34;.jar&amp;#34;) {//判断文件后缀是否为.jar val u = URLClassLoader(arrayOf&amp;lt;URL&amp;gt;(f.toURL()), Thread.currentThread().contextClassLoader)//加载Jar plugins.add(u.loadClass(&amp;#34;cn.enaium.plugin.Test&amp;#34;).newInstance() as PluginInitializer)//加载主类 } } } if (plugins.isNotEmpty()) { for (p in plugins) { p.onInitialize()//初始化插件 } } } catch (e: Exception) { } } 三.</description></item><item><title>使用 SpringBoot+Vue 实现留言版</title><link>https://blog.enaium.cn/post/2020-4-20-%E4%BD%BF%E7%94%A8-springboot+vue-%E5%AE%9E%E7%8E%B0%E7%95%99%E8%A8%80%E7%89%88/</link><pubDate>Mon, 20 Apr 2020 17:29:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-4-20-%E4%BD%BF%E7%94%A8-springboot+vue-%E5%AE%9E%E7%8E%B0%E7%95%99%E8%A8%80%E7%89%88/</guid><description>完成源码 一.新建Vue项目和SpringBoot项目 新建Vue项目 新建文件夹SpringBoot-Vue-MessageBoard 创建Vue项目使用vue ui命令(需要vue 3.0 选择刚才的目录 名字为Vue创建后V还是小写 创建后可以改为大写 取消git初始化 手动配置 取消 打开 创建项目，不保存预设
新建SpringBoot项目 用IDEA打开SpringBoot-Vue-MessageBoard这个目录 创建SpringBoot项目 右键 选择Spring Initializr 选择这四个 名字改为SpringBoot
二. 后端 配置application.properties #Mysql spring.datasource.url=jdbc:mysql://localhost:3306/enaium?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.jpa.show-sql= true spring.jpa.properties.hibernate.format_sql = true #Server server.port=8181 写实体类 package cn.enaium.message.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.Entity; import javax.persistence.Id; /** * Project: message * ----------------------------------------------------------- * Copyright © 2020 | Enaium | All rights reserved. */ @Data @Entity @NoArgsConstructor @AllArgsConstructor public class Message { @Id private Long id; private String author; private String message; private String time; } 实体类Jpa package cn.</description></item><item><title>[全民写端第二季]#2移植</title><link>https://blog.enaium.cn/post/2020-3-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%232%E7%A7%BB%E6%A4%8D/</link><pubDate>Sat, 28 Mar 2020 18:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%232%E7%A7%BB%E6%A4%8D/</guid><description>一. 把第一季的源码复制过来
二. 注入
注入run 和 top @Mixin(Minecraft.class) public class MinecraftMixin { @Inject(at = @At(&amp;#34;RETURN&amp;#34;), method = &amp;#34;startGame&amp;#34;) private void startGame(CallbackInfo info) { FoxBase.instance.run(); } @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;shutdownMinecraftApplet&amp;#34;) private void stop(CallbackInfo info) { FoxBase.instance.stop(); } } 注入EventUpdate EventKeyboard EventRender2D @Mixin(Minecraft.class) public class MinecraftMixin { @Inject(at = @At(&amp;#34;RETURN&amp;#34;), method = &amp;#34;dispatchKeypresses&amp;#34;) private void dispatchKeypresses(CallbackInfo info) { if (Keyboard.getEventKeyState() &amp;amp;&amp;amp; Minecraft().getMinecraft().currentScreen == null) new EventKeyboard(Keyboard.getEventKey() == 0 ? Keyboard.getEventCharacter() + 256 : Keyboard,getEventKey()).</description></item><item><title>[全民写端第二季]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-3-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Wed, 25 Mar 2020 19:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>下载FoxBase 如果你想修改名字可以在gradle.build文件修改archivesBaseName
从项目的根目录运行以下命令: ./gradlew setupDevWorkspace idea genIntellijRuns build 打开 IntelliJ IDEA. Open Open =&amp;gt; Select FoxBase folder Click Import gradle project 添加VM options -Dfml.coreMods.load=cn.enaium.foxbase.injection.MixinLoader 完成！</description></item><item><title>[全民写端]#12绘制ClickGUI</title><link>https://blog.enaium.cn/post/2020-3-14-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2312-%E7%BB%98%E5%88%B6clickgui/</link><pubDate>Sat, 14 Mar 2020 17:52:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-14-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2312-%E7%BB%98%E5%88%B6clickgui/</guid><description>一. 先复制进去FontUtils
FontUtils package cn.enaium.coreium.utils; import net.minecraft.client.Minecraft; import net.minecraft.client.gui.FontRenderer; import net.minecraft.util.StringUtils; public class FontUtils { private static FontRenderer fontRenderer; public static void setupFontUtils() { fontRenderer = Minecraft.getMinecraft().fontRendererObj; } public static int getStringWidth(String text) { return fontRenderer.getStringWidth(StringUtils.stripControlCodes(text)); } public static int getFontHeight() { return fontRenderer.FONT_HEIGHT; } public static void drawString(String text, int x, int y, int color) { fontRenderer.drawString(text, x, y, color); } public static void drawStringWithShadow(String text, double x, double y, int color) { fontRenderer.</description></item><item><title>[全民写端]#11绘制主菜单</title><link>https://blog.enaium.cn/post/2020-3-3-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2311%E7%BB%98%E5%88%B6%E4%B8%BB%E8%8F%9C%E5%8D%95/</link><pubDate>Tue, 03 Mar 2020 11:01:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-3-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2311%E7%BB%98%E5%88%B6%E4%B8%BB%E8%8F%9C%E5%8D%95/</guid><description>一. 搜索GuiMainMenu这个类
二. 删除drawScreen方法内所有
三. 删除无用方法(显示为灰色的方法)
四. 在drawScreen方法绘制
public void drawScreen(int mouseX, int mouseY, float partialTicks) { //获取屏幕长和高 ScaledResolution s = new ScaledResolution(mc); //绑定纹理(材质) mc.getTextureManager().bindTexture(new ResourceLocation(&amp;#34;coreium/background.jpg&amp;#34;)); //绘制纹理(材质) Gui.drawModalRectWithCustomSizedTexture(0, 0, 0, 0, s.getScaledWidth(), s.getScaledHeight(), s.getScaledWidth(), s.getScaledHeight()); //绘制标题 fontRendererObj.drawString(Coreium.INSTANCE.name, s.getScaledWidth() / 2 - fontRendererObj.getStringWidth(Coreium.INSTANCE.name) / 2, 30, new Color(30, 0, 255).getRGB()); super.drawScreen(mouseX, mouseY, partialTicks); } 五. 放入纹理(材质) 在assets.minecraft新建一个coreium包 放入背景 完成</description></item><item><title>用Gitee搭建私有Maven仓库</title><link>https://blog.enaium.cn/post/2020-3-1-%E7%94%A8gitee%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89maven%E4%BB%93%E5%BA%93/</link><pubDate>Sun, 01 Mar 2020 19:53:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-1-%E7%94%A8gitee%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89maven%E4%BB%93%E5%BA%93/</guid><description>一. 新建仓库
二. 上传index
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Enaium&amp;#39;s maven repository &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 三. 开通Gitee Pages
四. 上传文件
五. 部署
⚠上传的文件部署后才能从Gitee Pages中下载到</description></item><item><title>[全民写端]#10绘制ToggleModules</title><link>https://blog.enaium.cn/post/2020-2-29%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2310%E7%BB%98%E5%88%B6togglemodules/</link><pubDate>Sat, 29 Feb 2020 18:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-29%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%2310%E7%BB%98%E5%88%B6togglemodules/</guid><description>一.添加EventRender2D
public class EventRender2D extends Event { public EventRender2D() { super(Type.PRE); } } 二.钩子
搜索GuiIngame这个类打开 找到renderGameOverlay这个类 在if (this.mc.playerController.isSpectator()){[...]}else{[...]}后面添加 GlStateManager.pushMatrix(); new EventRender2D().call(); GlStateManager.popMatrix(); 三. 绘制HUD
新建HUD类 在onRender方法里面写绘制 添加到loadModsthis.addModule(new HUD()); package cn.enaium.coreium.module.render; import cn.enaium.coreium.event.EventTarget; import cn.enaium.coreium.event.events.EventRender2D; import cn.enaium.coreium.module.Category; import cn.enaium.coreium.module.Module; import org.lwjgl.input.Keyboard; public class HUD extends Module { public HUD() { super(&amp;#34;HUD&amp;#34;, Keyboard.KEY_P, Category.RENDER); } @EventTarget public void onRender(EventRender2D e) { } } //字体 FontRenderer fr = mc.fontRendererObj; //获取屏幕长和高 ScaledResolution sr = new ScaledResolution(mc); ArrayList&amp;lt;Module&amp;gt; modules = new ArrayList(); for (Module m : Coreium.</description></item><item><title>[全民写端]#9添加配置</title><link>https://blog.enaium.cn/post/2020-2-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%239%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 28 Feb 2020 12:21:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%239%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/</guid><description>一. 添加Config
下载Config解压到你想要的目录
二.添加到Start
[...] public ConfigManager configManager; public void start() { [...] configManager = new ConfigManager(); Display.setTitle(Coreium.INSTANCE.name); [...] configManager.loadConfig(); } public void stop() { configManager.saveConfig(); }</description></item><item><title>[全民写端]#8简化代码</title><link>https://blog.enaium.cn/post/2020-2-26-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%238%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</link><pubDate>Wed, 26 Feb 2020 16:46:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-26-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%238%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</guid><description>一. 简化端名和版本
在INSTANCE写
public String name = &amp;#34;Coreium&amp;#34;; public String version = &amp;#34;B1&amp;#34;; 就可以直接使用Coreium.INSTANCE.name来获取
二. 简化Module
在Module类中加入protected Minecraft mc = Minecraft.getMinecraft(); mc.thePlayer.setSprinting(true);直接使用
三. 简化addSetting
protected void addSetting(Setting setting) { Coreium.INSTANCE.settingManager.addSetting(setting); }</description></item><item><title>[全民写端]#7添加Command</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%237%E6%B7%BB%E5%8A%A0command/</link><pubDate>Tue, 25 Feb 2020 18:34:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%237%E6%B7%BB%E5%8A%A0command/</guid><description>一. 添加Command
下载Command解压到你想要的目录
二. 添加到Start
[...] public CommandManager commandManager; public void start() { [...] commandManager = new CommandManager(); Display.setTitle(&amp;#34;Coreium&amp;#34;); moduleManager.loadMods(); commandManager.loadCommands(); [...] } [...] 三. 在ModuleManager中添加getModule方法
[...] public Module getModule(String name) { for (Module m : modules) { if (m.getName().equalsIgnoreCase(name)) return m; } return null; } [...] 四. 新建一个PlayerUtils类
package cn.enaium.coreium.utils; import com.mojang.realmsclient.gui.ChatFormatting; import net.minecraft.client.Minecraft; public class PlayerUtils { public static void tellPlayer(String text) { Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(new ChatComponentText( ChatFormatting.WHITE + &amp;#34;[&amp;#34; + ChatFormatting.</description></item><item><title>[全民写端]#6添加Setting</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%236%E6%B7%BB%E5%8A%A0setting/</link><pubDate>Tue, 25 Feb 2020 18:00:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%236%E6%B7%BB%E5%8A%A0setting/</guid><description>一. 写Setting类
package cn.enaium.coreium.setting; import cn.enaium.coreium.module.Module; import java.util.ArrayList; public class Setting { private Module module; private String name; private boolean toggle; private double currentValueDouble, minValueDouble, maxValueDouble; private int currentValueInt, minValueInt, maxValueInt; private float currentValueFloat, minValueFloat, maxValueFloat; private ArrayList&amp;lt;String&amp;gt; modes; private String currentMode; private Category category; public enum Category { BOOLEAN, VALUE_INT, VALUE_DOUBLE, VALUE_FLOAT, MODE; } public Setting(Module module, String name, boolean toggle) { this.module = module; this.name = name; this.toggle = toggle; this.</description></item><item><title>[全民写端]#5自动疾跑</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%235%E8%87%AA%E5%8A%A8%E7%96%BE%E8%B7%91/</link><pubDate>Tue, 25 Feb 2020 13:40:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%235%E8%87%AA%E5%8A%A8%E7%96%BE%E8%B7%91/</guid><description>一. 新建Sprint类
package cn.enaium.coreium.module.movement; import cn.enaium.coreium.event.EventTarget; import cn.enaium.coreium.event.events.EventUpdate; import cn.enaium.coreium.module.Category; import cn.enaium.coreium.module.Module; import net.minecraft.client.Minecraft; import org.lwjgl.input.Keyboard; public class Sprint extends Module { public Sprint() { super(&amp;#34;Sprint&amp;#34;, Keyboard.KEY_V, Category.MOVEMENT); } @EventTarget public void onUpdate(EventUpdate e) { Minecraft.getMinecraft().thePlayer.setSprinting(true); } } 二. 添加到loadModules
public void loadMods() { this.addModule(new Sprint()); } 三. 运行
按V打开</description></item><item><title>[全民写端]#4添加Event和Module</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%234%E6%B7%BB%E5%8A%A0event%E5%92%8Cmodule/</link><pubDate>Tue, 25 Feb 2020 13:03:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%234%E6%B7%BB%E5%8A%A0event%E5%92%8Cmodule/</guid><description>一. 添加Event
下载Event解压到你想要的目录 修改Event 二. 钩子
在EntityPlayerSP类里面找到onUpdate方法 在第一行写 new EventUpdate().call(); 在Minecraft类里找到runTick方法 找到Keyboard.next()循环 在if (k == 62 &amp;amp;&amp;amp; this.entityRenderer != null)下面写 new EventKeyboard(k).call(); public void onUpdate() { new EventUpdate().call(); if (k == 62 &amp;amp;&amp;amp; this.entityRenderer != null) { this.entityRenderer.switchUseShader(); } new EventKeyboard(k).call(); if (this.currentScreen != null) 三. 写Category枚举
package cn.enaium.coreium.module; public enum Category { COMBAT, RENDER, MOVEMENT, PLAYER, OTHER } 四. 写Module类
package cn.enaium.coreium.module; import cn.enaium.coreium.Coreium; public class Module { private boolean toggle; private String name; private int keyCode; private Category category; public Module(String name, int keyCode, Category category) { this.</description></item><item><title>[全民写端]#3添加OptiFine</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%233%E6%B7%BB%E5%8A%A0optifine/</link><pubDate>Tue, 25 Feb 2020 12:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%233%E6%B7%BB%E5%8A%A0optifine/</guid><description>一. 下载Optifine本站下载
二. 删除src\minecraft所有内容 将Optifine解压进去(保留你写的包)
三. 根据#2的方法修改Minecraft类调用Start 和 Stop
四. 导入vecmath包
五. 修改类名net.minecraft.client.renderer包下的EntityRenderer$1 EntityRenderer$2 改为EntityRenderer1 EntityRenderer2
六. 启动</description></item><item><title>[全民写端]#2设置启动和停止</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%232%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</link><pubDate>Tue, 25 Feb 2020 10:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%232%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</guid><description>一. 写启动和停止
在你想要的地方新建一个类 改为enum 写一个枚举 INSTANCE; 写两个方法分别是 start 和 stop
public enum Coreium { INSTANCE; public void start() { } public void stop() { } } 在启动和退出游戏的时候调用这2个类 搜索Minecraft 找到startGame在这个方法在最后面写Coreium.INSTANCE.start(); 找到shutdownMinecraftApplet在logger.info(&amp;quot;Stopping!&amp;quot;);后面写Coreium.INSTANCE.stop();
[...] this.renderGlobal.makeEntityOutlineShader(); Coreium.INSTANCE.start(); } private void registerMetadataSerializers() { [...] public void shutdownMinecraftApplet() { try { this.stream.shutdownStream(); logger.info(&amp;#34;Stopping!&amp;#34;); Coreium.INSTANCE.stop(); [...] 二. 修改游戏标题
在Minecraft类中我们搜索Display.Title会找到Display.setTitle(&amp;quot;Minecraft 1.8.8&amp;quot;);这个就是修改标题 我们现在知道了修改标题的方法
在start里面写Display.setTitle(&amp;quot;Coreium&amp;quot;);就是吧标题改为Coreium 运行</description></item><item><title>[全民写端]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-2-24-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 24 Feb 2020 18:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%231%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDEA
一. 下载MCP
二. 解压到你想要的路径,文件名你想起什么名字就起什么名字
三. 打开文件夹运行decompile.bat,Linux 或者Mac OS 运行decompile.sh(这一步必有正版启动器,而且默认目录%APPDATA%.minecraft\versions 必须要有MC1.8.8版本,运行前还要运行过1.8.8MC.)
反编译完成 四. 导入IDEA
Next Next Next Finish 填写你的导入的目录 这个目录将你以后的所有写端项目的目录,删除后除了重新设置目录你将无法读取到lib,(以后新建项目不会提示填写目录).
提示的1.6什么什么的错误信息不用管点OK就行了 五. 设置项目
全部点× 六. 运行
打开Start 选右上角的Setup SDK选中1.8 运行 七. 启动设置
运行后出现错误需要设置启动 -Djava.library.path=versions\1.8.8\1.8.8-natives</description></item><item><title>Minecraft Fabric 进阶教程 #2 绘制界面</title><link>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-%232-%E7%BB%98%E5%88%B6%E7%95%8C%E9%9D%A2/</link><pubDate>Mon, 24 Feb 2020 16:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-%232-%E7%BB%98%E5%88%B6%E7%95%8C%E9%9D%A2/</guid><description>绘制界面不需用注入Mixin
新建一个类 ExampleGui.java
继承Screen构造器
public ExampleGui() { super(new LiteralText(&amp;#34;&amp;#34;)); } 绘制 这是绘制一个背景
绘制背景这种全部覆盖时要在super上面不然按钮或者其他东西会被背景盖住
@Override public void render(int mouseX, int mouseY, float delta) { renderBackground(); super.render(mouseX, mouseY, delta); } 我们也可以添加一个按钮
@Override public void init() { super.init(); this.addButton(new ButtonWidget(20,20,100,20,&amp;#34;Done&amp;#34;,(action)-&amp;gt;{ })); } 打开界面
将上集绘制的按钮的action改为打开这个界面
@Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { this.addButton(new ButtonWidget(20,20,200,20,&amp;#34;233&amp;#34;,(action)-&amp;gt;{ MinecraftClient.getInstance().openScreen(new ExampleGui()); })); } 打开界面后我们发现只能用ESC来关闭界面
接下来我们要写返回上一界面的功能
在构造器里传入上个界面Screen
private Screen screen; public ExampleGui(Screen screen) { super(new LiteralText(&amp;#34;&amp;#34;)); this.</description></item><item><title>Minecraft Fabric 进阶教程 #1 绘制按钮</title><link>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-%231-%E7%BB%98%E5%88%B6%E6%8C%89%E9%92%AE/</link><pubDate>Mon, 24 Feb 2020 13:56:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-%231-%E7%BB%98%E5%88%B6%E6%8C%89%E9%92%AE/</guid><description>在Mixin包里新建一个类 注入到TitleScreen.class里
注入到这个类的init的方法的头部也就是最上面所以at是HEAD
因为init方法没有参数所以方法就是init()V
因为注入都有一个回调信息所以要有一个回调参数CallbackInfo
@Mixin(TitleScreen.class) public class TitleMixin { @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { } } 用IDEA反编译TitleScreen.classinit方法可以看到this.addButton这个就是添加按钮
所以我们要在Mixin里面写添加按钮
需要继承Screen类
按照提示生成构造器就行了
protected TitleMixin(Text title) { super(title); } 现在添加按钮 @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { this.addButton(new ButtonWidget(20,20,200,20,&amp;#34;233&amp;#34;,(action)-&amp;gt;{ System.out.println(&amp;#34;By Enaium&amp;#34;); })); } 在x20 y20处绘制一个长200高20(高必须为20)的按钮标题为“233”点击触发action输出By Enaium
添加到mixin.json
我们运行一下看看
成功</description></item><item><title>星露谷MOD开发教程 #1 配置开发环境</title><link>https://blog.enaium.cn/post/2020-2-9-%E6%98%9F%E9%9C%B2%E8%B0%B7-mod-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 09 Feb 2020 19:00:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-9-%E6%98%9F%E9%9C%B2%E8%B0%B7-mod-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>要求 安装了SMAPI IDE (推荐使用Visual Studio或者Rider) 准备 创建一个类库项目 引用Pathoschild.Stardew.ModBuildConfigNuget包 创建一个类 新建manifest.json文件 格式
{ &amp;#34;Name&amp;#34;: &amp;#34;&amp;lt;your project name&amp;gt;&amp;#34;, &amp;#34;Author&amp;#34;: &amp;#34;&amp;lt;your name&amp;gt;&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;Description&amp;#34;: &amp;#34;&amp;lt;One or two sentences about the mod&amp;gt;&amp;#34;, &amp;#34;UniqueID&amp;#34;: &amp;#34;&amp;lt;your name&amp;gt;.&amp;lt;your project name&amp;gt;&amp;#34;, &amp;#34;EntryDll&amp;#34;: &amp;#34;&amp;lt;your project name&amp;gt;.dll&amp;#34;, &amp;#34;MinimumApiVersion&amp;#34;: &amp;#34;2.10.0&amp;#34;, &amp;#34;UpdateKeys&amp;#34;: [] } 开始 继承父类Mod
添加一个事件
using StardewModdingAPI; using StardewModdingAPI.Events; namespace NewMod { public class NewMod : Mod { public override void Entry(IModHelper helper) { helper.Events.Input.ButtonPressed += onButtonPressed; } private void onButtonPressed(object sender, ButtonPressedEventArgs e) { //如果世界没有完成返回 if(!</description></item><item><title>使用WPF设计工具-MaterialDesignInXamlToolkit</title><link>https://blog.enaium.cn/post/2020-2-3-%E4%BD%BF%E7%94%A8wpf%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7-materialdesigninxamltoolkit/</link><pubDate>Mon, 03 Feb 2020 10:18:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-3-%E4%BD%BF%E7%94%A8wpf%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7-materialdesigninxamltoolkit/</guid><description>MaterialDesignInXamlToolkit
安装Nuget包MaterialDesignThemes 添加到App.xaml &amp;lt;ResourceDictionary&amp;gt; &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml&amp;#34; /&amp;gt; &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;/ResourceDictionary&amp;gt; 加入Window中 xmlns:materialDesign=&amp;quot;http://materialdesigninxaml.net/winfx/xaml/themes&amp;quot;
完成</description></item><item><title>Minecraft Fabric Client 教程 #5 添加Event、Sprint和ToggleCommand</title><link>https://blog.enaium.cn/post/2020-1-20-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%235-%E6%B7%BB%E5%8A%A0eventsprint%E5%92%8Ctogglecommand/</link><pubDate>Mon, 20 Jan 2020 13:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-20-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%235-%E6%B7%BB%E5%8A%A0eventsprint%E5%92%8Ctogglecommand/</guid><description>添加Event 下载
放在cn.enaium.excel里
然后在Excel.java里面添加EventManager
public enum Excel { [...] public EventManager eventManager; public void onEnable() { eventManager = new EventManager(); commandManager = new CommandManager(); moduleManager = new ModuleManager(); moduleManager.loadModules(); } [...] } 在Module.java里面添加Event、onEnable()、onDisable()、Toggle()
public class Module { [...] public void Toggle() { this.toggled = !this.toggled; if (this.toggled) { onEnable(); } else { onDisable(); } } public void onEnable() { Excel.INSTANCE.eventManager.register(this); } public void onDisable() { Excel.INSTANCE.eventManager.unregister(this); } } 注入Mixin 在 ClientPlayerEntityMixin.</description></item><item><title>解决Gradle不能构建问题</title><link>https://blog.enaium.cn/post/2020-1-12-%E8%A7%A3%E5%86%B3gradle%E4%B8%8D%E8%83%BD%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 12 Jan 2020 15:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-12-%E8%A7%A3%E5%86%B3gradle%E4%B8%8D%E8%83%BD%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98/</guid><description>绝大数的gradle项目用的都是私服并且换上镜像也没用因为私服的东西镜像没有
而且非私服的速度也不是很慢
我这里找到了一个解决办法就是用国际浏览手机自带的国际上网功能
购买国际上网的国内流量也不贵也就是5元3G左右
购买流量后开启它然后打开手机热点给电脑供网 USB/热点 供网
开始构建
虽然不是很快但是总比以前的不能构建强很多</description></item><item><title>Minecraft Fabric Client 教程 #4 添加Modules</title><link>https://blog.enaium.cn/post/2020-1-9-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%234-%E6%B7%BB%E5%8A%A0modules/</link><pubDate>Thu, 09 Jan 2020 10:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-9-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%234-%E6%B7%BB%E5%8A%A0modules/</guid><description>在cn.enaium.excel下新建一个包module
在module包里新建Module、ModuleManager这2个类 然后再新建一个Category枚举
Module内容
package cn.enaium.excel.module; /** * @Author Enaium * @Date 2020/1/9 11:03 */ public class Module { private String name; private Category category; private boolean toggled; public Module(String name,Category category) { this.name = name; this.category = category; this.toggled = false; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Category getCategory() { return category; } public void setCategory(Category category) { this.</description></item><item><title>解决IDEA Push rejected问题</title><link>https://blog.enaium.cn/post/2020-1-6-%E8%A7%A3%E5%86%B3idea-push-rejected%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 06 Jan 2020 11:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-6-%E8%A7%A3%E5%86%B3idea-push-rejected%E9%97%AE%E9%A2%98/</guid><description>右击目录选择Git Bash Here
依次输入以下命令
git pull git pull origin master git pull origin master --allow-unrelated-histories 再次推送</description></item><item><title>Minecraft Fabric Client 教程 #3 添加自定义Command</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%233-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89command/</link><pubDate>Sun, 05 Jan 2020 12:52:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%233-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89command/</guid><description>添加ChatUtils 先在cn.enaium.excel里新建一个包utils
然后创建一个ChatUtils.java类
内容
package cn.enaium.excel.utils; import net.minecraft.client.MinecraftClient; import net.minecraft.client.gui.hud.ChatHud; import net.minecraft.text.LiteralText; import net.minecraft.text.Text; /** * @Author Enaium * @Date 2020/1/5 12:54 */ public class ChatUtils { public static void component(Text component) { ChatHud chatHud = MinecraftClient.getInstance().inGameHud.getChatHud(); LiteralText prefix = new LiteralText(&amp;#34;\u00a7c[\u00a76Excel\u00a7c]\u00a7r &amp;#34;); chatHud.addMessage(prefix.append(component)); } public static void message(String message) { component(new LiteralText(message)); } } 添加自定义command 先在cn.enaium.excel里新建一个包command
下载
将压缩包里面的内容全部放进去
然后再Excel.java里添加command
public CommandManager commandManager; public void onEnable() { commandManager = new CommandManager(); commandManager.</description></item><item><title>Minecraft Fabric Client 教程 #2 修改文件和目录名添加run和stop</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%232-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%90%8D%E6%B7%BB%E5%8A%A0run%E5%92%8Cstop/</link><pubDate>Sat, 04 Jan 2020 23:08:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%232-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%90%8D%E6%B7%BB%E5%8A%A0run%E5%92%8Cstop/</guid><description>修改 包名、json文件、添加run stop 首先先修改包名
将ExampleMod.java改为ExcelInitializer.java
修改json文件modid.mixins.json和fabric.mod.json
将modid.mixins.json改为excel.mixins.json
excel.mixins.json内容：
{ &amp;#34;required&amp;#34;: true, &amp;#34;package&amp;#34;: &amp;#34;cn.enaium.excel.mixin&amp;#34;, &amp;#34;compatibilityLevel&amp;#34;: &amp;#34;JAVA_8&amp;#34;, &amp;#34;mixins&amp;#34;: [ ], &amp;#34;client&amp;#34;: [ &amp;#34;ExampleMixin&amp;#34;, &amp;#34;MinecraftClientMixin&amp;#34; ], &amp;#34;injectors&amp;#34;: { &amp;#34;defaultRequire&amp;#34;: 1 } } packagemixin的包名
client mixin的类名
compatibilityLevel java版本
fabric.mod.json内容：
{ &amp;#34;schemaVersion&amp;#34;: 1, &amp;#34;id&amp;#34;: &amp;#34;excel&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Excel&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;!&amp;#34;, &amp;#34;authors&amp;#34;: [ &amp;#34;Enaium!&amp;#34; ], &amp;#34;contact&amp;#34;: { &amp;#34;homepage&amp;#34;: &amp;#34;https://fabricmc.net/&amp;#34;, &amp;#34;sources&amp;#34;: &amp;#34;https://github.com/FabricMC/fabric-example-mod&amp;#34; }, &amp;#34;license&amp;#34;: &amp;#34;CC0-1.0&amp;#34;, &amp;#34;icon&amp;#34;: &amp;#34;assets/excel/icon.png&amp;#34;, &amp;#34;environment&amp;#34;: &amp;#34;*&amp;#34;, &amp;#34;entrypoints&amp;#34;: { &amp;#34;main&amp;#34;: [ &amp;#34;cn.enaium.excel.ExcelInitializer&amp;#34; ] }, &amp;#34;mixins&amp;#34;: [ &amp;#34;excel.</description></item><item><title>Minecraft Fabric Client 教程 #1 配置开发环境</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 04 Jan 2020 22:08:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDE
首先下载github 上的项目 fabric-example-mod 有以下方法:
用IDE 克隆 库 直接导入IDE 运行bat ./gradlew idea然后导入IDE 推荐使用IDEA</description></item><item><title>Minecraft 搭建一个Paper服务器</title><link>https://blog.enaium.cn/post/2020-1-2-minecraft-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AApaper%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Thu, 02 Jan 2020 18:44:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-2-minecraft-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AApaper%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>下载核心 Downloads – PaperMC
我这里是1.15.1的版本
选最新版本就行了
运行 下载好后放到一个文件夹然后放到一个文件夹然后再新建一个bat文件Launcher.bat里面写
java -Xms512M -Xmx1024M -jar paper.jar
然后发现下载好后瞬间退出了是因为要同意一些eula
打开eula.exe将eula=false改成就好了
然后再次运行
这样一个服务器就开好了</description></item><item><title>Linux下制作Windows启动U盘</title><link>https://blog.enaium.cn/post/2019-12-28-linux%E4%B8%8B%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8u%E7%9B%98/</link><pubDate>Sat, 28 Dec 2019 21:24:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-28-linux%E4%B8%8B%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8u%E7%9B%98/</guid><description>安装WoeUsb sudo apt-get install woeusb
或者
WosUsb
找一个U盘 格式化为NTFS格式
制作 sudo woeusb -d /media/e/Enaium/镜像/windows64/win101909.iso /dev/sdb --target-filesystem NTFS
注意路径！
接下来等就好了</description></item><item><title>Minecraft Fabric 教程 #9 添加盔甲</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%239-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</link><pubDate>Mon, 16 Dec 2019 17:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%239-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</guid><description>创建一个盔甲类
public class EndArmorMaterials implements ArmorMaterial { [...] } 复制一下内容
private static final int[] BASE_DURABILITY = {13, 15, 16, 11}; private final String name; private final int durabilityMultiplier; private final int[] protectionAmounts; private final int enchantability; private final SoundEvent equipSound; private final float toughness; private final Lazy&amp;lt;Ingredient&amp;gt; repairIngredientSupplier; public EndArmorMaterials(String name, int durabilityMultiplier, int[] armorValueArr, int enchantability, SoundEvent soundEvent, float toughness, Supplier&amp;lt;Ingredient&amp;gt; repairIngredient) { this.name = name; this.durabilityMultiplier = durabilityMultiplier; this.</description></item><item><title>Minecraft Fabric 教程 #8 添加附魔书</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%238-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</link><pubDate>Mon, 16 Dec 2019 13:45:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%238-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</guid><description>创建一个附魔书类
public class FireBoomEnchantment extends Enchantment { [...] } 在类中添一下
@Override public int getMinimumPower(int level) { return 15; } @Override public int getMaximumLevel() { return 1; } @Override public void onTargetDamaged(LivingEntity user, Entity target, int level) { if(target instanceof LivingEntity) { World world = user.world; boolean bl = world.getGameRules().getBoolean(GameRules.MOB_GRIEFING); world.createExplosion(target, target.prevX, target.prevY, target.prevZ, 1.0f, bl, bl ? Explosion.DestructionType.DESTROY : Explosion.DestructionType.NONE); world.spawnEntity(target); } } 这就创建了一个FireBoom附魔书
onTargetDamaged //当目标被攻击
在mc FireballEntity类有一个 方法就是当火球碰撞了就创建一个火焰爆炸的效果
protected void onCollision(HitResult hitResult) { super.</description></item><item><title>Minecraft Fabric 教程 #7 添加工具提示</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%237-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</link><pubDate>Mon, 16 Dec 2019 12:30:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-%237-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</guid><description>添加工具提示 在EndHeart类中添加
@Override public void appendTooltip(ItemStack stack, World world, List&amp;lt;Text&amp;gt; tooltip, TooltipContext context) { tooltip.add(new TranslatableText(&amp;#34;tooltip.endarmor.end_heart&amp;#34;)); }</description></item><item><title>Minecraft Fabric 教程 #6 添加合成表</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%236-%E6%B7%BB%E5%8A%A0%E5%90%88%E6%88%90%E8%A1%A8/</link><pubDate>Sun, 15 Dec 2019 20:48:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%236-%E6%B7%BB%E5%8A%A0%E5%90%88%E6%88%90%E8%A1%A8/</guid><description>位置 src\main\resources\data\endarmor\recipes\end_heart_block.json
{ &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shaped&amp;#34;, &amp;#34;pattern&amp;#34;: [ &amp;#34;WWW&amp;#34;, &amp;#34;WWW&amp;#34;, &amp;#34;WWW&amp;#34; ], &amp;#34;key&amp;#34;: { &amp;#34;W&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;endarmor:end_heart&amp;#34; } }, &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;endarmor:end_heart_block&amp;#34;, &amp;#34;count&amp;#34;: 4 } } W就是key里面的物品如果是空的就打一个空格比如W W</description></item><item><title>Minecraft Fabric 教程 #5 添加语言文件</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%235-%E6%B7%BB%E5%8A%A0%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 15 Dec 2019 20:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%235-%E6%B7%BB%E5%8A%A0%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6/</guid><description>创建语言文件 lang也就是你模组的翻译比如 中文简体 zh_cn 中文正體 zh_tw 英文 en_us
resources/assets/endarmor/lang/zh_cn.json
{ &amp;#34;item.endarmor.end_heart&amp;#34;: &amp;#34;End心&amp;#34;, &amp;#34;block.endarmor.end_heart_block&amp;#34;: &amp;#34;End心块&amp;#34;, [...] } 格式 &amp;lt;object-type&amp;gt;.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt;
block.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; item.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; itemGroup.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; fluid.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; sound_event.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; mob_effect.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; enchantment.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; entity_type.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; potion.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; biome.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; 获取翻译文件的翻译
new TranslatableText(&amp;#34;item.tutorial.fabric_item.tooltip_1&amp;#34;)</description></item><item><title>Minecraft Fabric 教程 #4 添加分组</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%234-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%BB%84/</link><pubDate>Sun, 15 Dec 2019 19:56:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%234-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%BB%84/</guid><description>在 ItemGroup 显示 使用 FabricItemGroupBuilder
public static final ItemGroup END_ITEM_GROUP = FabricItemGroupBuilder.create( new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;endarmor&amp;#34;)) .icon(() -&amp;gt; new ItemStack(END_HEART)) .appendItems(stacks -&amp;gt; { stacks.add(new ItemStack(END_HEART)); stacks.add(new ItemStack(END_HEART_BLOCK)); }) .build(); 直接创建即可
new Identifier(&amp;ldquo;endarmor&amp;rdquo;, &amp;ldquo;endarmor&amp;rdquo;) //第一个参数modid 第二个参数名字 只能用的 [a-z0-9_.-] 不要使用其他符号</description></item><item><title>Minecraft Fabric 教程 #3 添加方块</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%233-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</link><pubDate>Sun, 15 Dec 2019 19:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%233-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</guid><description>创建方块 public class ExampleMod implements ModInitializer { // an instance of our new block public static final Block END_HEART_BLOCK = new Block(FabricBlockSettings.of(Material.METAL).build()); [...] } 注册 public class ExampleMod implements ModInitializer { // block creation […] @Override public void onInitialize() { Registry.register(Registry.BLOCK, new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;end_heart_block&amp;#34;), END_HEART_BLOCK); } } 运行游戏发现无法找到方块是因为没有创建方块物品 但是可以使用命令在创建这个方块
创建方块物品 直接注册就行
public class ExampleMod implements ModInitializer { // block creation […] @Override public void onInitialize() { // block registration [...] Registry.</description></item><item><title>Minecraft Fabric 教程 #2 添加物品</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%232-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</link><pubDate>Sun, 15 Dec 2019 19:06:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%232-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</guid><description>创建物品 public class ExampleMod implements ModInitializer { private static final Item END_HEART = new Item(new Item.Settings().group(ItemGroup.COMBAT).maxCount(32)); [...] } ItemGroup.COMBAT //分类为COMBAT
maxCount(32) //一组最大堆叠数 一组最大只能叠32个物品
注册物品 public class ExampleMod implements ModInitializer { private static final Item END_HEART = new Item(new Item.Settings().group(ItemGroup.COMBAT).maxCount(32)); @Override public void onInitialize() { Registry.register(Registry.ITEM, new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;end_heart&amp;#34;), END_HEART); } } Registry.ITEM //类别是物品
new Identifier(&amp;ldquo;endarmor&amp;rdquo;, &amp;ldquo;end_heart&amp;rdquo;) //第一个参数是MOD ID 第二个参数是 物品的名字
END_HEART //要注册的物品的变量名
运行看看
发现是一个紫色方块 而且 名字是 item.endarmor.end_heart 紫色方块是没用纹理(材质)
接下来要添加纹理 需要的文件</description></item><item><title>Minecraft Fabric 教程 #1 开发环境配置</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 15 Dec 2019 17:50:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-%231-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDE
首先下载github 上的项目 fabric-example-mod 有以下方法:
用IDE 克隆 库 直接导入IDE 运行bat ./gradlew genSources然后导入IDE 推荐使用IDEA</description></item></channel></rss>