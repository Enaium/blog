<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://blog.enaium.cn/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Jun 2023 09:18:47 +0800</lastBuildDate><atom:link href="https://blog.enaium.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Gradle极简入门</title><link>https://blog.enaium.cn/post/2023-6-2-gradle%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 02 Jun 2023 09:18:47 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-6-2-gradle%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</guid><description>什么是 Gradle Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，而不是传统的XML。Gradle构建脚本是用Groovy编写的，也可以使用Kotlin编写，两者都是基于JVM的语言。
安装 Gradle 在开始之前，想必大家已经学会了Java或者Kotlin，现在大家都在使用Android Studio开发Android应用，Android Studio是基于IntelliJ IDEA开发的，但现在不从Android Studio的角度来讲，也不从IntelliJ IDEA的角度来讲，而是从Gradle的角度来讲，所以我们需要去官网下载Gradle，然后在IntelliJ IDEA中去使用Gradle。
首先去官网下载Gradle，下载地址：https://gradle.org/releases/，之后点击最新版本中的binary-only，这会直接下载一个zip压缩包，下载完成后解压到一个目录，然后再配置环境变量到bin目录，这样就可以在Terminal中使用gradle命令了，因为Java跨平台的缘故，在其他的操作系统上配置环境变量的方式都是大相不差的，这里我就不再赘述了，如果不会配置环境变量的话，可以去网上搜索一下，这里我就不再赘述了。
配置好环境变量之后，打开Terminal，输入gradle -v，如果出现下面的信息，说明Gradle安装成功了。
------------------------------------------------------------ Gradle 8.1 ------------------------------------------------------------ Build time: 2023-04-12 12:07:45 UTC Revision: 40ba32cde9d6daf2b92c39376d2758909dd6b813 Kotlin: 1.8.10 Groovy: 3.0.15 Ant: Apache Ant(TM) version 1.10.11 compiled on July 10 2021 JVM: 17.0.6 (BellSoft 17.0.6+10-LTS) OS: Windows 10 10.0 amd64 创建 Hello World 项目 创建一个文件夹，然后在文件夹中打开Terminal，输入gradle init，之后按照我的步骤来。
Select type of project to generate: 1: basic 2: application 3: library 4: Gradle plugin Enter selection (default: basic) [1.</description></item><item><title>Jimmer VS MyBatisPlus查询自关联表</title><link>https://blog.enaium.cn/post/2023-5-30-jimmer-vs-mybatisplus%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%85%B3%E8%81%94%E8%A1%A8/</link><pubDate>Tue, 30 May 2023 09:48:17 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-30-jimmer-vs-mybatisplus%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%85%B3%E8%81%94%E8%A1%A8/</guid><description>本文是对Jimmer文档中对象抓取器-自关联递归抓取部分的介绍,之后会对比MyBatisPlus的查询自关联表的能力。
对象抓取器是 jimmer-sql 一个非常强大的特征，具备可媲美 GraphQL 的能力。 即使用户不采用任何 GraphQL 相关的技术栈，也能在 SQL 查询层面得到和 GraphQL 相似的对象图查询能力。
准备数据库和实体类 create table tree_node( node_id bigint not null, name varchar(20) not null, parent_id bigint ); alter table tree_node add constraint pk_tree_node primary key(node_id); alter table tree_node add constraint uq_tree_node unique(parent_id, name); alter table tree_node add constraint fk_tree_node__parent foreign key(parent_id) references tree_node(node_id); insert into tree_node( node_id, name, parent_id ) values (1, &amp;#39;Home&amp;#39;, null), (2, &amp;#39;Food&amp;#39;, 1), (3, &amp;#39;Drinks&amp;#39;, 2), (4, &amp;#39;Coca Cola&amp;#39;, 3), (5, &amp;#39;Fanta&amp;#39;, 3), (6, &amp;#39;Bread&amp;#39;, 2), (7, &amp;#39;Baguette&amp;#39;, 6), (8, &amp;#39;Ciabatta&amp;#39;, 6), (9, &amp;#39;Clothing&amp;#39;, 1), (10, &amp;#39;Woman&amp;#39;, 9), (11, &amp;#39;Casual wear&amp;#39;, 10), (12, &amp;#39;Dress&amp;#39;, 11), (13, &amp;#39;Miniskirt&amp;#39;, 11), (14, &amp;#39;Jeans&amp;#39;, 11), (15, &amp;#39;Formal wear&amp;#39;, 10), (16, &amp;#39;Suit&amp;#39;, 15), (17, &amp;#39;Shirt&amp;#39;, 15), (18, &amp;#39;Man&amp;#39;, 9), (19, &amp;#39;Casual wear&amp;#39;, 18), (20, &amp;#39;Jacket&amp;#39;, 19), (21, &amp;#39;Jeans&amp;#39;, 19), (22, &amp;#39;Formal wear&amp;#39;, 18), (23, &amp;#39;Suit&amp;#39;, 22), (24, &amp;#39;Shirt&amp;#39;, 22) ; @Entity public interface TreeNode { @Id @Column(name = &amp;#34;NODE_ID&amp;#34;) long id(); String name(); @Null @ManyToOne TreeNode parent(); @OneToMany(mappedBy = &amp;#34;parent&amp;#34;) List&amp;lt;TreeNode&amp;gt; childNodes(); } 指定查询的深度 我们可以看到，这是一个自关联的表，每个节点都有一个父节点，也可以有多个子节点。</description></item><item><title>Java革命性ORM框架Jimmer简单介绍</title><link>https://blog.enaium.cn/post/2023-5-27-java%E9%9D%A9%E5%91%BD%E6%80%A7orm%E6%A1%86%E6%9E%B6jimmer%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 27 May 2023 10:35:44 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-27-java%E9%9D%A9%E5%91%BD%E6%80%A7orm%E6%A1%86%E6%9E%B6jimmer%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>本文使用Jimmer的官方用例来介绍Jimmer的使用方法,Jimmer同时支持Java和Kotlin,本文使用Java来介绍,实际上Kotlin比Java使用起来更方便,这里为了方便大家理解,使用Java来介绍,本篇文章只是对Jimmer的一个简单介绍,更多的内容请参考官方文档
这里开始就不从实体类开始介绍了,这里简单的把用到的三张表之间的关系介绍一下:
BookStore书店 可以拥有多个Book Book书 可以属于多个BookStore,可以有多个Author Author作者 可以拥有多个Book,多对多书与作者的关系. 查询 Jimmer可以配合SpringData(不是SpringDataJPA),但这里先介绍脱离SpringData的使用方法,但还是在SpringBoot环境下,这里使用H2内存数据库,Jimmer支持H2,MySQL,PostgreSQL,Oracle等数据库,这里使用H2内存数据库.
这里的查询都使用Controller来演示.
查询所有书店 createQuery就是创建一个查询,select就是选择要查询的字段,这里直接传入了BookStoreTable表示查询所有字段.
这里用到的sql就是使用Jimmer的Sql对象,这个对象是Jimmer的核心对象,所有的查询都是通过这个对象来实现的,使用Spring的注入方式注入JSqlClient对象.
final BookStoreTable bookStore = BookStoreTable.$;//这里的$是一个静态方法,返回一个BookStoreTable对象 sql.createQuery(bookStore).select(bookStore).execute(); 查询结果如下:
[ { &amp;#34;createdTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;modifiedTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;O&amp;#39;REILLY&amp;#34;, &amp;#34;website&amp;#34;: null }, { &amp;#34;createdTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;modifiedTime&amp;#34;: &amp;#34;2023-05-27 11:00:37&amp;#34;, &amp;#34;id&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;MANNING&amp;#34;, &amp;#34;website&amp;#34;: null } ] 指定查询字段 如何需要需要查询指定字段就可以这样,这里的name是BookStoreTable的一个字段,但这里的Controller返回的是BookStore对象,所以只好像上面的那样查询所有字段.
sql.createQuery(bookStore).select(bookStore.name()).execute(); 像上面的例子中如果我们非要查询指定字段又不想定义新的DTO对象,那么这种在Jimmer中也可以非常简单的实现,那就是使用Jimmer中的Fetchr
使用BookStore的Fetchr来指定查询的字段
sql.createQuery(bookStore).select(bookStore.fetch(BookStoreFetcher.$.name())).execute(); 查询结果如下:
[ { &amp;#34;id&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;MANNING&amp;#34; }, { &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;O&amp;#39;REILLY&amp;#34; } ] 惊奇的发现,Controller的返回类型是BookStore,但是查询结果中只有id和name字段.</description></item><item><title>使用SolidJS+SpringBoot写一个简单的个人博客</title><link>https://blog.enaium.cn/post/2023-5-23-%E4%BD%BF%E7%94%A8solidjs+springboot%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Tue, 23 May 2023 12:24:52 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-5-23-%E4%BD%BF%E7%94%A8solidjs+springboot%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>前言 前端我们使用了SolidJS来进行开发,它是一个新出的前端框架,它的特点是使用React Hooks的方式来进行开发,并且它的API和React的API非常相似,所以如果你会React的话,那么你就会SolidJS.
后端我们使用了SpringBoot来进行开发,数据库我们使用了MySQL来进行开发,这里我使用的是MariaDB来进行开发,ORM 框架使用的是Jimmer,这个框架它支持Java和Kotlin,这里为了简单起见就使用Java开发,但实际使用Koltin会更方便.
前端环境 首先呢,需要安装一下SolidJS的模板,这里我使用的是TypeScript和Bootstrap的模板
npx degit solidjs/templates/ts-bootstrap website cd website pmpm install # or npm install pmpm dev # or npm run dev 然后我们需要安装一下SolidJS的路由,这是一个官方的路由
pnpm install @solidjs/router 然后我们需要安装一下SolidJS的状态管理,这里我使用的是zustand
pnpm install zustand solid-zustand 然后我们需要安装一下Immer用于修改不可变数据
pnpm install solid-immer 然后我们需要安装solid-toast,这是一个用于显示提示的库
pnpm install solid-toast 最后我们需要安装TanStack Query,这是一个用于进行网络请求的库,同时支持React,Vue,Svelte当然也支持SolidJS
pnpm install @tanstack/solid-query 编写前端基础代码 现在我们开始编写前端代码
首先我们需要删掉模板中自带的样式,并且删除App.tsx中的内容,然后我们需要在App.tsx中引入Router组件,并且使用useRoutes来进行路由的渲染,这里我们需要传入一个路由数组,这个数组中包含了我们的路由信息,然后我们需要在App.tsx中使用Router组件来进行路由的渲染
import type { Component } from &amp;#34;solid-js&amp;#34; import { Router, useRoutes } from &amp;#34;@solidjs/router&amp;#34; import routes from &amp;#34;./router&amp;#34; //这里是路由数组 import { Toaster } from &amp;#34;solid-toast&amp;#34; //这个组件用于显示提示 const App: Component = () =&amp;gt; { const Routes = useRoutes(routes) return ( &amp;lt;&amp;gt; &amp;lt;Toaster /&amp;gt; &amp;lt;Router&amp;gt; &amp;lt;Routes /&amp;gt; &amp;lt;/Router&amp;gt; &amp;lt;/&amp;gt; ) } 之后新建views目录,在其中新家一个Login.</description></item><item><title>解决IDEA创建或打开项目时下载Gradle</title><link>https://blog.enaium.cn/post/2023-2-3-%E8%A7%A3%E5%86%B3idea%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8B%E8%BD%BDgradle/</link><pubDate>Fri, 03 Feb 2023 15:42:31 +0800</pubDate><guid>https://blog.enaium.cn/post/2023-2-3-%E8%A7%A3%E5%86%B3idea%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8B%E8%BD%BDgradle/</guid><description>引言 我们在使用IDEA创建或打开一个Gradle项目时,IDEA会下载一个新或旧的Gradle版本,虽然下载很快,但到下次IDEA更新后又会是一个新版的Gradle版本,这样很影响我们的开发效率,所以我做了一个东西,可以让IDEA在创建或打开一个项目时使用自己指定的版本
使用 我做了一个Agent,可以让他来加载自己写的Transformer大大减少了开发时间,它叫做Cafully
首先下载它到任意位置
接着在给IDEA添加下面JVM参数(idea64.exe.vmoptions),agent的位置就是刚才下载的位置
--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED -javaagent:/absolute/path/to/cafully-agent.jar 安装插件 下载好后放入Agent同级目录下的plugin文件夹里面
cafully-plugin-asm 这个是ASM插件,用来生成和修改字节码
接下来下载解决这个问题的插件
KeepGradleVersion
配置 首先呢这个插件有一个配置,在Agent同级目录下的config文件夹里面放入keep-gradle-version.properties文件即可
#默认 7.6, Gradle的版本 version=7.6 #默认 false, 是否在当打开一个项目时使用指定的版本 open=true 这样IDEA无论在创建或打开一个项目时使用指定的版本了
视频</description></item><item><title>Hugo教程#5遍历页面</title><link>https://blog.enaium.cn/post/2022-12-7-hugo%E6%95%99%E7%A8%8B#5%E9%81%8D%E5%8E%86%E9%A1%B5%E9%9D%A2/</link><pubDate>Wed, 07 Dec 2022 11:28:02 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-12-7-hugo%E6%95%99%E7%A8%8B#5%E9%81%8D%E5%8E%86%E9%A1%B5%E9%9D%A2/</guid><description>引言 前面几期视频学习了一些布局和模板语法,其实Hugo的最终用法就是来写个人博客,需要遍历出所有的博客来呈现在网站的主页,Markdown文件都会创建一个页面,所以只需要把每个页面的地址遍历出来就行了
创建页面 首先在content/post创建多个页面,以此类推创建4个页面
# Post1 布局 因为要使用模板语法来遍历出这些页面,所以这里选择修改主页布局,使用with将当前目录改为/post,接着使用range来遍历.Pages,Title就是每个页面的标题,Permalink就是路径
{{ with .Site.GetPage &amp;#34;/post&amp;#34; }} {{ range .Pages }} &amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;{{ .Permalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt; {{ end }} {{ end }}</description></item><item><title>Hugo教程#4基础布局</title><link>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B#4%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/</link><pubDate>Thu, 24 Nov 2022 11:30:04 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B#4%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/</guid><description>引言 前几期学习了布局,本期学习一下布局更多的用法,比如partial和block,其中partial可以吧每个布局引用,block可作为布局的扩展
布局 layouts/_default里有一个baseof.html布局,初始内容是
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; {{- partial &amp;#34;head.html&amp;#34; . -}} &amp;lt;body&amp;gt; {{- partial &amp;#34;header.html&amp;#34; . -}} &amp;lt;div id=&amp;#34;content&amp;#34;&amp;gt; {{- block &amp;#34;main&amp;#34; . }}{{- end }} &amp;lt;/div&amp;gt; {{- partial &amp;#34;footer.html&amp;#34; . -}} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 除了基本的html代码,还有一些使用{{}}包起来的东西,这些都是hugo的模板语法
partial可以将对应的布局引用过来
block可以让这个部分被扩展,对应的子布局需要使用define来进行扩展
首先来看partial
在static中写一个css
static └── css └── style.css .red { color: red; } 在layouts/partials/head.html的布局中引入css,需要注意的是static是在根目录下,所以不用写,直接从static里的路径开始引用就行了,其实partials就相当于把部分文件内容给放到另一个文件中了,然后使用partial来引用这个文件的内容
&amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/css/style.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; 现在将single.html中的内容改为,别忘了要使用define来扩展baseof.html里的block,不然使用的就是single.html这个布局,而不是使用了扩展了baseof.html布局的single.html布局
{{ define &amp;#34;main&amp;#34; }} &amp;lt;div class=&amp;#34;red&amp;#34;&amp;gt; {{ .Content }} &amp;lt;/div&amp;gt; {{ end }}</description></item><item><title>Hugo教程#3单页面布局</title><link>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B#3%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</link><pubDate>Thu, 24 Nov 2022 10:58:26 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-24-hugo%E6%95%99%E7%A8%8B#3%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</guid><description>引言 上集我们学习了如何创建一个index的布局,那么是不是所有的页面都要创建一个布局,那肯定不是的,那样的话实在太麻烦,因为只显对应页面的markdown里面的内容,所以创建一个single.html布局就可以了,所有的页面都可以使用这个布局
布局 在layouts/_default里有一个single.html的布局,默认是空的,我们只需要读取到markdown的内容,之后呈现在页面中
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;{{ .Title }}&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; {{ .Content }} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 测试 在home.md里面写一些内容
# Home ## Single 好了现在所有的页面都可以使用single.html这个布局了</description></item><item><title>Hugo教程#2布局</title><link>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B#2%E5%B8%83%E5%B1%80/</link><pubDate>Mon, 21 Nov 2022 09:16:06 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B#2%E5%B8%83%E5%B1%80/</guid><description>引言 从本集开始,就开始和布局打交道了,所以我们需要学习Hugo的模板语法,其实也刚开始一步一步来,不需要一次学一堆
那如何知道布局的模板是什么呢,其实hugo内置了一个功能,可以创建一个空白主题
创建主题 hugo new theme default 其中default就是主题名
创建好后我们发目录结构基本上和创建一个site(页面项目)的结构一样,只不过layouts里面有一堆html文件,这个就是默认的模板
检查一些主题的theme.toml文件内容,发现友好多内容,其实都是字面意思,没必要太多纠结
再来看layouts里的index.html文件
像平常写html一样写一些基本内容
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;This is a home page&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 之后在项目的配置文件中使用这个主题
baseURL = &amp;#39;http://example.org/&amp;#39; languageCode = &amp;#39;en-us&amp;#39; title = &amp;#39;My New Hugo Site&amp;#39; baseURL = &amp;#39;http://example.org/&amp;#39; languageCode = &amp;#39;en-us&amp;#39; title = &amp;#39;My New Hugo Site&amp;#39; theme = &amp;#39;default&amp;#39; # 添加的主题 项目运行后可以正常显示我们写的内容
其实也可以直接将主题default中的layouts内容全部复制到site的layouts中
default ├── archetypes │ └── default.</description></item><item><title>Hugo教程#1配置开发环境</title><link>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 21 Nov 2022 08:28:43 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-11-21-hugo%E6%95%99%E7%A8%8B#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>引言 前段时间我把我的博客的生成器从Jekyll换到了Gatsby后来发现并不好用,又想回到Jekyll,最后由于ruby的gem安装老是出错,所以我试了一下Hugo
好了废话不多说,开始配置Hugo的开发环境吧
配置环境 安装 Linux Linux用户可以直接使用包管理器安装apt,yum,dnf,zypper,pacman等等,包名就是hugo
Windows Windows用户可以在GitHub的release下载对应的平台,hugo也支持arm64
创建项目 使用命令hugo new site blog既可在blog下创建一个hugo项目,hugo可以换成自己想在的目录下,如果想在当前目录下创建需要加上--force参数,也就是hugo new site . --force
目录结构 . 当前目录 ├── archetypes 原型模板 使用new 文件名.md参数的时候会在content下创建一个md文件 │ └── default.md 默认模板 ├── config.toml 配置文件 ├── content 内容基本上所有的内容都写在这里面 ├── data 数据 ├── layouts 布局 ├── public 生成的页面 ├── static 静态资源 └── themes 主题 创建内容 使用hugo new 默认创建项目后使用的是yaml的写法,当然也可以使用json和toml的写法,如果是toml的写法那就吧---换成+++
--- title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; # 标题 date: {{ .</description></item><item><title>Contact</title><link>https://blog.enaium.cn/contact/</link><pubDate>Fri, 18 Nov 2022 15:37:34 +0800</pubDate><guid>https://blog.enaium.cn/contact/</guid><description>Contact GitHub BiliBili</description></item><item><title>About</title><link>https://blog.enaium.cn/about/</link><pubDate>Wed, 16 Nov 2022 09:24:55 +0800</pubDate><guid>https://blog.enaium.cn/about/</guid><description>About Generator:Hugo
UI:Bootstrap</description></item><item><title>解决Debian网速慢问题</title><link>https://blog.enaium.cn/post/2022-10-07-%E8%A7%A3%E5%86%B3debian%E7%BD%91%E9%80%9F%E6%85%A2%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 07 Oct 2022 15:12:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-10-07-%E8%A7%A3%E5%86%B3debian%E7%BD%91%E9%80%9F%E6%85%A2%E9%97%AE%E9%A2%98/</guid><description>最近在我的笔记本上换了Debian，装上驱动后发现网速很慢，后来换了Ubuntu，Ubuntu自带了网卡驱动，测试了一下网速发现网速还是很慢，只要是基于Debian的系统，或者基于Ubuntu的Mint也是慢
后来在bing上搜了一下，在Ubuntu的论坛上找到了解决方法，其实内核5.15这个版本有问题，我升级到了5.17后发现好了点，不过网速还是慢，所以我将内核直接升级到6.0，测试了一下网速发现网速是可以跑满了
接下来说下更新方法
进入到Ubuntu的内核列表里，下载找到大于当前5.15的6.0，最近6.0刚更新
进入到6.0后最上面有4个deb文件是amd64的，其他处理器可以在下面找到，下载下来后全部安装后重启就可以了
cd ~/Downloads wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-headers-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-headers-6.0.0-060000_6.0.0-060000.202210022231_all.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-image-unsigned-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0/amd64/linux-modules-6.0.0-060000-generic_6.0.0-060000.202210022231_amd64.deb sudo dpkg -i *.deb 查看内核版本命令
uname -r</description></item><item><title>如何使用Gatsby创建自己的博客</title><link>https://blog.enaium.cn/post/2022-9-28%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gatsby%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</link><pubDate>Wed, 28 Sep 2022 11:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-9-28%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gatsby%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</guid><description>首先使用npm安装gatsby，使用gatsby –version命令可以查看是否安装
npm install -g gatsby-cli 使用new命令后面跟着目录名，即可创建一个gatsby项目
gatsby new website 使用develop参数即可启用gatsby服务
gatsby develop 进入到8000端口后即可访问默认的页面，不过本文章是创建个人博客
在创建项目时后面跟着一个github地址，这个是gatsby官方的一个博客模板
gatsby new blog https://github.com/gatsbyjs/gatsby-starter-blog 这个是项目的目录结构
C:. ├─content │ └─blog │ ├─hello-world │ ├─my-second-post │ └─new-beginnings ├─src │ ├─components │ ├─images │ ├─pages │ └─templates └─static content下主要是markdown文件，但如果要被识别为blog还需要在blog里创建markdown文件
主要看blog里都有哪些文件，每个文件夹下都有一个index.md文件，这里会根据文件夹的名称来决定地址名是什么
C:. ├─hello-world │ index.md │ salty_egg.jpg │ ├─my-second-post │ index.md │ └─new-beginnings index.md 这里可以直接在blog中创建markdown文件，地址名就是markdown文件名
每个markdown文件的前几行都会有用3个横杠抱起来的内容，这个就是Front-matter格式，博客的信息都会从这里获取，title是博客的标题，date是发布时间，description是描述，其中时间必须遵守正确的格式
--- title: &amp;#34;如何使用Gatsby创建自己的博客&amp;#34; date: 2022-09-28T11:16:00+0800 categroy: javascript --- 现在来介绍如何使用GitHub的pages服务，首先需要在项目下安装gh-pages
npm install gh-pages --save-dev 在项目的gatsby的config文件中添加pathPrefix，这里选择没前缀</description></item><item><title>Netty手写RPC框架</title><link>https://blog.enaium.cn/post/2022-3-14-netty%E6%89%8B%E5%86%99rpc%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 14 Mar 2022 14:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-14-netty%E6%89%8B%E5%86%99rpc%E6%A1%86%E6%9E%B6/</guid><description>协议就用上篇文章的协议
public class Message implements Serializable { private final long order; public Message(long order) { this.order = order; } public long getOrder() { return order; } } 只不过Message加了个Order熟悉,
创建Request类,继承Message,klass是调用的Class目标,name,parameterType,argument分别是方法名称,参数类型,参数
public class Request extends Message { private final String klass; private final String name; private final Class&amp;lt;?&amp;gt;[] parameterType; private final Object[] argument; public Request(long order, String klass, String name, Class&amp;lt;?&amp;gt;[] parameterType, Object[] argument) { super(order); this.klass = klass; this.name = name; this.</description></item><item><title>Netty自定义协议</title><link>https://blog.enaium.cn/post/2022-3-12-netty%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 12 Mar 2022 19:21:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-12-netty%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</guid><description>先写一个Messsage类,解码的时候将要把ByteBuf解码为Message
public class Message implements Serializable { private final String data; public Message(String data) { this.data = data; } @Override public String toString() { return &amp;#34;Message{&amp;#34; + &amp;#34;data=&amp;#39;&amp;#34; + data + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 之后创建MessageCodec类,继承MessageToMessageCodec
入站为ByteBuf解码为Message,出站为Message编码为ByteBuf
重写编码的解码方法
public class MessageCodec extends MessageToMessageCodec&amp;lt;ByteBuf, Message&amp;gt; { @Override public void encode(ChannelHandlerContext channelHandlerContext, Message message, List&amp;lt;Object&amp;gt; list) throws Exception { } @Override public void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&amp;lt;Object&amp;gt; list) throws Exception { } } 这里用四个字节表示内容的长度,最后是所有内容,这里使用JDK来序列化</description></item><item><title>Token+Redis登录认证</title><link>https://blog.enaium.cn/post/2022-3-10-token-redis%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</link><pubDate>Thu, 10 Mar 2022 19:17:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-3-10-token-redis%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</guid><description>首先需要了解一下大概的步骤
登录生成一个Token存入Redis有效期为30分钟,返回到前端 之后前端每次请求,带上登录时返回的Token 服务器判断前端带来的Token是否在Redis服务器中 存在放行并且重置Token有效期,不存在拦截 一个简简单单的登录请求
@RequestMapping(&amp;#34;/login&amp;#34;) @ResponseBody public Result&amp;lt;String&amp;gt; login(@RequestBody UserDTO userDTO) { var byUsernameAndPassword = mapper.getByUsernameAndPassword(userDTO.getUsername(), userDTO.getPassword()); if (byUsernameAndPassword != null) { return new Result&amp;lt;&amp;gt;(true, &amp;#34;login success&amp;#34;); } return new Result&amp;lt;&amp;gt;(false, &amp;#34;wrong username or password&amp;#34;); } 生成一个UUID存入Redis,值为用户的ID,并且设置有效期为30分钟
var uuid = &amp;#34;user-token:&amp;#34; + UUID.randomUUID(); redisTemplate.opsForValue().set(uuid, byUsernameAndPassword.getId().toString(), 30, TimeUnit.MINUTES); return new Result&amp;lt;&amp;gt;(true, uuid); 接下来直写拦截器,重写addInterceptors方法
@Configuration public class RequestInterceptor implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { } } 使用HandlerInterceptor重写preHandle方法,登录和注册不用拦截</description></item><item><title>实现JPanel切换</title><link>https://blog.enaium.cn/post/2022-2-28-%E5%AE%9E%E7%8E%B0jpanel%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 28 Feb 2022 17:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-2-28-%E5%AE%9E%E7%8E%B0jpanel%E5%88%87%E6%8D%A2/</guid><description>public static void main(String[] args) { JFrame jFrame = new JFrame(&amp;#34;Test&amp;#34;); jFrame.setSize(500, 500); jFrame.setLocationRelativeTo(jFrame.getOwner()); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jFrame.setLayout(new BorderLayout()); var jPanel = new JPanel(new BorderLayout()); jFrame.add(jPanel, BorderLayout.CENTER); AtomicBoolean b = new AtomicBoolean(false); jFrame.add(new JButton(&amp;#34;Switch&amp;#34;) { { addActionListener(e -&amp;gt; { b.set(!b.get()); jPanel.removeAll(); jPanel.repaint(); jPanel.revalidate(); jPanel.add(b.get() ? new JPanel() { @Override protected void paintComponent(Graphics g) { setBackground(Color.RED); super.paintComponent(g); } } : new JPanel() { @Override protected void paintComponent(Graphics g) { setBackground(Color.GREEN); super.paintComponent(g); } }); jPanel.</description></item><item><title>Minecraft模组加载器开发教程#1基本介绍</title><link>https://blog.enaium.cn/post/2022-1-21-minecraft%E6%A8%A1%E7%BB%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B#1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link><pubDate>Fri, 21 Jan 2022 12:23:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2022-1-21-minecraft%E6%A8%A1%E7%BB%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B#1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid><description>学习之前，应该先了解一下这些东西
一、	什么是模组加载器
二、	他们是如何修改Minecraft的
三、	修改Minecraft的原理是什么
四、	什么是混淆
五、	如何修改Minecraft
1．	类似于Fabric、Forge，等等，这些都是模组加载器
2．	他们都会通过重新设置类加载器，而重新加载所有类，除了java.lang，java.xxx 之类的核心类，因为java不允许这些类重新加载，当然也可以通过bootclasspath来强制修改java核心类，这些都是后话了, 我们可以使用Mojang官方的LegacyLauncher，这个依赖来在运行的时候重新加载，但年代太久没更新，已经不支持Java9以上的版本，不过修复它也很简单
3．	当类被重新加载的时候，有一个过程，会将二进制文件读取，在读取后我们可以对它进行修改，可以通过ASM等框架，或者基于ASM框架的Mixin框架，之前我制作过这些ASM和Mixin的基础视频
4．	混淆就是把一个类名或者其他可见名，改为不能分辨的名字，比如一个Minecraft类，混淆之后会变成abc这个名字，并且所有的包名都会被去掉， Minecraft原版Jar文件都是混淆后的，只有类名、方法名、字段名被混淆了，再加上近几年官方都在放出每个版本的混淆映射，我们可以通过映射来返混淆，映射就是把每个混淆的名字，告诉你它之前是什么名字，Mojang不允许我们把反混淆后的源码放出来，所以一些客户端比如LiquidBounce使用Forge以Mod的形式来修改客户端
5．	我们可以先把Jar反混淆，之后我们依赖这个类，这样我们就可以正常依赖这个Jar，之后在用官方给的映射列表把写好的东西给重新混淆，这仅仅是不行的，我们还需要修改Java类，使用ASM或者Mixin，比如需要在游戏的onUpdate等方法里插入调用，来实现事件Event，这些操作都需要Gradle来完成，可以写一个Gradle插件来帮我们完成这些操作，比如在编译之后打包Jar之前，我们就可以对这些类重新混淆</description></item><item><title>Netty Http服务器接收请求</title><link>https://blog.enaium.cn/post/2021-7-19-netty-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82/</link><pubDate>Mon, 19 Jul 2021 15:38:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-19-netty-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82/</guid><description>public class Server { public static void main(String[] args) { EventLoopGroup eventLoopGroup = new NioEventLoopGroup(); ServerBootstrap serverBootstrap = new ServerBootstrap(); try { serverBootstrap.group(eventLoopGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new HttpRequestDecoder()); ch.pipeline().addLast(new HttpResponseEncoder()); ch.pipeline().addLast(new HttpObjectAggregator(65535)); ch.pipeline().addLast(new SimpleChannelInboundHandler&amp;lt;FullHttpRequest&amp;gt;() { @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception { ByteBuf byteBuf = Unpooled.wrappedBuffer(&amp;#34;Hello world!&amp;#34;.getBytes(StandardCharsets.UTF_8)); FullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf); fullHttpResponse.headers().set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain;charset=UTF-8&amp;#34;); fullHttpResponse.headers().set(&amp;#34;Content-Length&amp;#34;, byteBuf.readableBytes()); ctx.writeAndFlush(fullHttpResponse).addListener(ChannelFutureListener.CLOSE); } }); } }).</description></item><item><title>Java实现Autowired自动注入</title><link>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0autowired%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</link><pubDate>Fri, 16 Jul 2021 21:22:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0autowired%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</guid><description>继续使用上个文章的类容器
创建一个注解
@Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Autowired { } 遍历所有字段包括私有的
private void autowired() { for (Map.Entry&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; classObjectEntry : classes.entrySet()) { for (Field declaredField : classObjectEntry.getKey().getDeclaredFields()) { declaredField.setAccessible(true); if (classes.get(declaredField.getType()) != null) {//容器内是否有这个类的对象 try { //赋值 declaredField.set(classObjectEntry.getValue(), classes.get(declaredField.getType())); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } } 在加入到容器后就调用autowired
public ClassContainer() { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; scanClasses = new ArrayList&amp;lt;&amp;gt;(List.of(Test1.class, Test2.class));//注意这里Test2也被加入到了容器里 scanClasses.forEach(it -&amp;gt; { try { classes.put(it, it.getConstructor().newInstance()); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { e.</description></item><item><title>Java 实现一个类容器</title><link>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%B9%E5%99%A8/</link><pubDate>Fri, 16 Jul 2021 20:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%B9%E5%99%A8/</guid><description>新建2个类
public class Test1 { } public class Test2 { public void render() { System.out.println(&amp;#34;Test2&amp;#34;); } } public class ClassContainer { private final HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; classes = new HashMap&amp;lt;&amp;gt;(); public ClassContainer() { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; scanClasses = new ArrayList&amp;lt;&amp;gt;(List.of(Test1.class));//被扫描到的类 上个文章介绍了如何遍历类路径所有类 scanClasses.forEach(it -&amp;gt; { try { classes.put(it, it.getConstructor().newInstance());//创建对象 直接newInstance的方法被弃用 所以需要获取无参构造方法再创建对象 } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { e.printStackTrace(); } }); } public &amp;lt;T&amp;gt; T create(Class&amp;lt;T&amp;gt; klass, Object instance) { classes.</description></item><item><title>Java遍历类路径所有类</title><link>https://blog.enaium.cn/post/2021-7-16-java%E9%81%8D%E5%8E%86%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%80%E6%9C%89%E7%B1%BB/</link><pubDate>Fri, 16 Jul 2021 09:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-7-16-java%E9%81%8D%E5%8E%86%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%80%E6%9C%89%E7%B1%BB/</guid><description>public class WalkClasspathAllClasses { public static void main(String[] args) throws URISyntaxException, IOException { List&amp;lt;URL&amp;gt; urls = new ArrayList&amp;lt;&amp;gt;(); //获取Classpath if (WalkClasspathAllClasses.class.getClassLoader() instanceof URLClassLoader) { Collections.addAll(urls, ((URLClassLoader) WalkClasspathAllClasses.class.getClassLoader()).getURLs()); } else { for (String s : System.getProperty(&amp;#34;java.class.path&amp;#34;).split(&amp;#34;;&amp;#34;)) { urls.add(new File(s).toURI().toURL()); } } //遍历所有类 walkAllClasses(urls).forEach(System.out::println); } private static Set&amp;lt;String&amp;gt; walkAllClasses(List&amp;lt;URL&amp;gt; urls) throws URISyntaxException, IOException { Set&amp;lt;String&amp;gt; classes = new HashSet&amp;lt;&amp;gt;(); for (URL url : urls) { if (url.toURI().getScheme().equals(&amp;#34;file&amp;#34;)) {//判断Scheme是不是file File file = new File(url.</description></item><item><title>Minecraft启动器开发#7正版登录</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#7%E6%AD%A3%E7%89%88%E7%99%BB%E5%BD%95/</link><pubDate>Sun, 16 May 2021 21:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#7%E6%AD%A3%E7%89%88%E7%99%BB%E5%BD%95/</guid><description>public static String doPost(URL url, String post) throws IOException { byte[] bytes = post.getBytes(StandardCharsets.UTF_8); HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.setRequestMethod(&amp;#34;POST&amp;#34;); con.setDoOutput(true); con.setRequestProperty(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json; charset=utf-8&amp;#34;); con.setRequestProperty(&amp;#34;Content-Length&amp;#34;, String.valueOf(bytes.length)); IOUtils.write(bytes, con.getOutputStream()); return IOUtils.toString(con.getInputStream(), StandardCharsets.UTF_8); } 发送post请求
请求地址https://authserver.mojang.com/authenticate
类型为application/json
{ &amp;#34;agent&amp;#34;: { // defaults to Minecraft &amp;#34;name&amp;#34;: &amp;#34;Minecraft&amp;#34;, // For Mojang&amp;#39;s other game Scrolls, &amp;#34;Scrolls&amp;#34; should be used &amp;#34;version&amp;#34;: 1 // This number might be increased // by the vanilla client in the future }, &amp;#34;username&amp;#34;: &amp;#34;mojang account name&amp;#34;, // Can be an email address or player name for // unmigrated accounts &amp;#34;password&amp;#34;: &amp;#34;mojang account password&amp;#34;, &amp;#34;clientToken&amp;#34;: &amp;#34;client identifier&amp;#34;, // optional &amp;#34;requestUser&amp;#34;: true // optional; default: false; true adds the user object to the response } 参数</description></item><item><title>Minecraft启动器开发#6下载Native</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#6%E4%B8%8B%E8%BD%BDnative/</link><pubDate>Sun, 16 May 2021 13:49:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#6%E4%B8%8B%E8%BD%BDnative/</guid><description>if (downloads.has(&amp;#34;classifiers&amp;#34;)) { var classifiers = downloads.get(&amp;#34;classifiers&amp;#34;).getAsJsonObject(); var nativeName = &amp;#34;natives-linux&amp;#34;; var osName = System.getProperty(&amp;#34;os.name&amp;#34;).toLowerCase(Locale.ROOT); if (osName.contains(&amp;#34;win&amp;#34;)) { nativeName = &amp;#34;natives-windows&amp;#34;; if (!classifiers.has(nativeName)) { nativeName = &amp;#34;natives-windows-64&amp;#34;; } } else if (osName.contains(&amp;#34;mac&amp;#34;)) { nativeName = &amp;#34;natives-osx&amp;#34;; if (!classifiers.has(nativeName)) { nativeName = &amp;#34;natives-macos&amp;#34;; } } if (!classifiers.has(&amp;#34;nativeName&amp;#34;)) { continue; } var path = new File(libraryDir, classifiers.get(nativeName).getAsJsonObject().get(&amp;#34;path&amp;#34;).getAsString()); var url = classifiers.get(nativeName).getAsJsonObject().get(&amp;#34;url&amp;#34;).getAsString(); if (!path.exists()) { FileUtils.writeByteArrayToFile(path, IOUtils.toByteArray(new URL(url))); } } 下载库的时候下载Native，osx在以后的版本会变成macos需要再次判断，windows还需要判断系统架构
if (!path.exists()) { FileUtils.</description></item><item><title>Minecraft启动器开发#5下载资源</title><link>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#5%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</link><pubDate>Sun, 16 May 2021 11:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-16-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#5%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/</guid><description>var assetsDir = new File(gameDir, &amp;#34;assets&amp;#34;); 将资源目录改为.minecraft的assets目录
var indexDir = new File(assetsDir, &amp;#34;indexes&amp;#34;); if (!indexDir.exists()) { indexDir.mkdir(); } var objectDir = new File(assetsDir, &amp;#34;objects&amp;#34;); if (!objectDir.exists()) { objectDir.mkdir(); } 创建indexes和objects目录
public class AssetObject { private final String hash; private final long size; public AssetObject(String hash, long size) { this.hash = hash; this.size = size; } public String getHash() { return hash; } public long getSize() { return size; } } 创建AssetObject类</description></item><item><title>Minecraft启动器开发#4下载库</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#4%E4%B8%8B%E8%BD%BD%E5%BA%93/</link><pubDate>Sat, 15 May 2021 19:49:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#4%E4%B8%8B%E8%BD%BD%E5%BA%93/</guid><description>var libraryDir = new File(gameDir,&amp;#34;libraries&amp;#34;); 设置库的路径
for (JsonElement jsonElement : gameJson.get(&amp;#34;libraries&amp;#34;).getAsJsonArray()) { var downloads = jsonElement.getAsJsonObject().get(&amp;#34;downloads&amp;#34;).getAsJsonObject(); if (downloads.has(&amp;#34;artifact&amp;#34;)) { var artifact = downloads.get(&amp;#34;artifact&amp;#34;).getAsJsonObject(); var path = new File(libraryDir, artifact.get(&amp;#34;path&amp;#34;).getAsString()); if (!path.exists()) { FileUtils.writeByteArrayToFile(path,IOUtils.toByteArray(new URL(artifact.get(&amp;#34;url&amp;#34;).getAsString()))); } } } 遍历出所有库 获取url下载到指定路径
var libraryDir = new File(gameDir,&amp;#34;libraries&amp;#34;); for (JsonElement jsonElement : gameJson.get(&amp;#34;libraries&amp;#34;).getAsJsonArray()) { var downloads = jsonElement.getAsJsonObject().get(&amp;#34;downloads&amp;#34;).getAsJsonObject(); if (downloads.has(&amp;#34;artifact&amp;#34;)) { var artifact = downloads.get(&amp;#34;artifact&amp;#34;).getAsJsonObject(); var path = new File(libraryDir, artifact.get(&amp;#34;path&amp;#34;).getAsString()); libraries.append(path).append(&amp;#34;;&amp;#34;); if (!path.exists()) { FileUtils.</description></item><item><title>Minecraft启动器开发#3下载游戏</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#3%E4%B8%8B%E8%BD%BD%E6%B8%B8%E6%88%8F/</link><pubDate>Sat, 15 May 2021 16:31:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#3%E4%B8%8B%E8%BD%BD%E6%B8%B8%E6%88%8F/</guid><description>gameVersion改为titleVersion var gameVersion = &amp;quot;1.8.9&amp;quot;;声明变量，指定游戏版本
引入commons-io和gson
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 读取游戏列表访问https://launchermeta.mojang.com/mc/game/version_manifest_v2.json
var gson = new Gson(); var gameListJson = IOUtils.toString(new URL(&amp;#34;https://launchermeta.mojang.com/mc/game/version_manifest_v2.json&amp;#34;), StandardCharsets.UTF_8); var gameList = gson.fromJson(gameListJson, JsonObject.class).get(&amp;#34;versions&amp;#34;).getAsJsonArray(); var gameJsonURL = &amp;#34;&amp;#34;; for (JsonElement jsonElement : gameList) { if (jsonElement.getAsJsonObject().get(&amp;#34;id&amp;#34;).getAsString().equals(gameVersion)) { gameJsonURL = jsonElement.getAsJsonObject().get(&amp;#34;url&amp;#34;).getAsString(); } } if (gameJsonURL.equals(&amp;#34;&amp;#34;)) { throw new RuntimeException(gameVersion + &amp;#34; Not Found!&amp;#34;); } 获取versions遍历出所以版本，之后获取指定版本的json
如果没找到版本就抛出异常
var gameJson = gson.fromJson(IOUtils.toString(new URL(gameJsonURL), StandardCharsets.UTF_8), JsonObject.</description></item><item><title>Minecraft启动器开发#2启动游戏</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#2%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</link><pubDate>Sat, 15 May 2021 13:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#2%E5%90%AF%E5%8A%A8%E6%B8%B8%E6%88%8F/</guid><description>var name = &amp;#34;mcc&amp;#34;; var version = &amp;#34;1.0&amp;#34;; var java = System.getProperty(&amp;#34;java.home&amp;#34;); var jvmArgs = &amp;#34;-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:G1NewSizePercent=20 -XX:G1ReservePercent=20 -XX:MaxGCPauseMillis=50 -XX:G1HeapRegionSize=16M -XX:-UseAdaptiveSizePolicy -XX:-OmitStackTraceInFastThrow -Xmn128m -Xmx1792m&amp;#34;; var natives = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/versions/1.8.9/natives&amp;#34;; var libraries = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/netty/1.6/netty-1.6.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/oshi-project/oshi-core/1.1/oshi-core-1.1.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/dev/jna/jna/3.4.0/jna-3.4.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/dev/jna/platform/3.4.0/platform-3.4.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/ibm/icu/icu4j-core-mojang/51.2/icu4j-core-mojang-51.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/codecjorbis/20101023/codecjorbis-20101023.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/codecwav/20101023/codecwav-20101023.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/libraryjavasound/20101123/libraryjavasound-20101123.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/librarylwjglopenal/20100824/librarylwjglopenal-20100824.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/paulscode/soundsystem/20120107/soundsystem-20120107.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/google/guava/guava/17.0/guava-17.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-io/commons-io/2.4/commons-io-2.4.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-codec/commons-codec/1.9/commons-codec-1.9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/jinput/jinput/2.0.5/jinput-2.0.5.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/net/java/jutils/jutils/1.0.0/jutils-1.0.0.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/authlib/1.5.21/authlib-1.5.21.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/com/mojang/realms/1.7.59/realms-1.7.59.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/httpcomponents/httpclient/4.3.3/httpclient-4.3.3.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/httpcomponents/httpcore/4.3.2/httpcore-4.3.2.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/logging/log4j/log4j-api/2.0-beta9/log4j-api-2.0-beta9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/apache/logging/log4j/log4j-core/2.0-beta9/log4j-core-2.0-beta9.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl/2.9.4-nightly-20150209/lwjgl-2.9.4-nightly-20150209.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl_util/2.9.4-nightly-20150209/lwjgl_util-2.9.4-nightly-20150209.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/libraries/tv/twitch/twitch/6.5/twitch-6.5.jar;C:/Users/Enaium/AppData/Roaming/.minecraft/versions/1.8.9/1.8.9.jar&amp;#34;; var mainClass = &amp;#34;net.minecraft.client.main.Main&amp;#34;; var username = &amp;#34;Enaium&amp;#34;; var gameVersion = &amp;#34;\&amp;#34; &amp;#34; + name + &amp;#34; &amp;#34; + version + &amp;#34; \&amp;#34;&amp;#34;; var gameDir = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft&amp;#34;; var assetsDir = &amp;#34;C:/Users/Enaium/AppData/Roaming/.minecraft/assets&amp;#34;; var assetIndex = &amp;#34;1.8&amp;#34;; var uuid = &amp;#34;0&amp;#34;; var accessToken = &amp;#34;0&amp;#34;; var text = java + &amp;#34;/bin/java.</description></item><item><title>Minecraft启动器开发#1分析启动脚本</title><link>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#1%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</link><pubDate>Sat, 15 May 2021 11:11:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-5-15-minecraft%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91#1%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</guid><description>用HMCL生成启动脚本
var java = System.getProperty(&amp;#34;java.home&amp;#34;); 获取运行的java路径
-Dminecraft.client.jar=xxx没用可以删掉
-XX:xxJVM参数 可能需要
-Dfml.ignoreInvalidMinecraftCertificates=true -Dfml.ignorePatchDiscrepancies=true -XX:HeapDumpPath=MojangTricksIntelDriversForPerformance_javaw.exe_minecraft.exe.heapdump
这段可以直接删掉
-Djava.library.path navite 启动需要的native
-Dminecraft.launcher.brand启动器
-Dminecraft.launcher.version启动器版本
-cp classpath 启动需要的库
net.minecraft.client.main.Main 启动的主类
--username用户名(玩家名)
--version游戏左下角显示的版本
--gameDir游戏运行的目录save、log等文件会生成在这里
--assetsDir游戏资源路径
--assetIndex游戏资源的Index文件名
--uuid玩家的UUID
--accessToken Token会过期 每次登录都会重新生成
--userProperties {}玩家的资产 不用管
--userType玩家类型 mojang表示是mojang账户
--width 854 --height 480窗口的大小</description></item><item><title>[ASM教程]#6树API</title><link>https://blog.enaium.cn/post/2021-4-27-asm%E6%95%99%E7%A8%8B#6%E6%A0%91api/</link><pubDate>Tue, 27 Apr 2021 15:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-27-asm%E6%95%99%E7%A8%8B#6%E6%A0%91api/</guid><description>使用树API来生成一个类
public static void main(String[] args) { ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); ClassNode classNode = new ClassNode(); classNode.visit(V1_8, ACC_PUBLIC, &amp;#34;cn/enaium/learn/asm/learn6/Learn6Test&amp;#34;, null, &amp;#34;java/lang/Object&amp;#34;, null); MethodNode methodNode = new MethodNode(ACC_PUBLIC + ACC_STATIC, &amp;#34;render&amp;#34;, &amp;#34;()V&amp;#34;, null, null);//一个方法 methodNode.instructions.add(new FieldInsnNode(GETSTATIC, &amp;#34;java/lang/System&amp;#34;, &amp;#34;out&amp;#34;, &amp;#34;Ljava/io/PrintStream;&amp;#34;)); methodNode.instructions.add(new LdcInsnNode(&amp;#34;Hello ASM!&amp;#34;)); methodNode.instructions.add(new MethodInsnNode(INVOKEVIRTUAL, &amp;#34;java/io/PrintStream&amp;#34;, &amp;#34;println&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false)); methodNode.visitMaxs(2, 1); methodNode.instructions.add(new InsnNode(RETURN)); classNode.methods.add(methodNode);//添加方法 classNode.accept(classWriter); String name = Learn2.class.getResource(&amp;#34;/cn/enaium/learn/asm/learn6/&amp;#34;).getPath() + &amp;#34;Learn6Test.class&amp;#34;; try { FileOutputStream out = new FileOutputStream(name); out.write(classWriter.toByteArray()); out.close(); } catch (Exception e) { e.</description></item><item><title>120行代码手写一个简单的MyBatis实现简单的CRUD</title><link>https://blog.enaium.cn/post/2021-4-21-120%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mybatis%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84crud/</link><pubDate>Wed, 21 Apr 2021 20:57:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-21-120%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mybatis%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84crud/</guid><description>不用XML只用注解
首先需要创建6个注解
SQL用于输入SQL语句
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface SQL { String[] value(); } 用来表示这个方法是Update
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Update { } 用来表示这个方法是Select
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Select { } 用来表示这个方法是Insert
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Insert { } 用来表示这个方法是Delete
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Delete { } 用来表示方法参数名
@Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface Param { String value(); } 好了注解写完了
开始写主类
用map实现简单的配置，然后读取配置连接数据库，然后程序关闭的时候关闭连接。
public class Satis { private final Statement statement; public Satis(Map&amp;lt;String, String&amp;gt; config) throws Exception { Class.</description></item><item><title>详细介绍如何发布到Maven中央仓库</title><link>https://blog.enaium.cn/post/2021-4-15-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</link><pubDate>Thu, 15 Apr 2021 11:10:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-4-15-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</guid><description>注册账户 https://issues.sonatype.org
发布问题(创建新的工程) https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;amp;pid=10134
摘要:项目名称
Group Id:组名 这里要用自己的域名的话一定要保证有域名的所有权,后面会让你添加dns记录来验证
Project URL仓库地址 SCM URL git地址
之后创建
等待回复 会让你添加DNS记录
添加后回复,这个地址要使用这个工具才能访问,直接执行命令后面跟着地址就行
等待回复之后就能上传了,他说上传之后回复
这里我使用Gradle
加上这2个插件
plugins { id &amp;#39;maven-publish&amp;#39; id &amp;#39;signing&amp;#39; } doc 和 source
java { withJavadocJar() withSourcesJar() } 发布配置 配置后先别刷新
publishing { //配置仓库 repositories { //本地仓库 def ENV = System.getenv() if (ENV.MAVEN_URL) { maven { url ENV.MAVEN_URL } } //远程仓库 maven { url &amp;#34;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&amp;#34; credentials { username ossrhUsername password ossrhPassword } } } publications { mavenJava(MavenPublication) { groupId project.</description></item><item><title>[ASM教程]#5字符串混淆</title><link>https://blog.enaium.cn/post/2021-3-19-asm%E6%95%99%E7%A8%8B#5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/</link><pubDate>Fri, 19 Mar 2021 20:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-19-asm%E6%95%99%E7%A8%8B#5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/</guid><description>测试类，需要混淆这里所有的字符串，上一期我们学习了如果插入一个常量，那么拦截插入常量的时候判断是不是字符串，如果是就混淆它。
public class Learn5Test { private final String name = &amp;#34;Enaium&amp;#34;; private Learn5Test() { render(name); } private void render() { System.out.println(&amp;#34;obfuscatory by &amp;#34; + name); } private void render(String text) { System.out.println(text); } } 重写方法访问。
@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { return new MethodVisitor(api, super.visitMethod(access, name, desc, signature, exceptions)) { }; } 重写常量访问。
@Override public void visitLdcInsn(Object cst) { } @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { return new MethodVisitor(api, super.</description></item><item><title>[ASM教程]#4创建对象和数组</title><link>https://blog.enaium.cn/post/2021-3-3-asm%E6%95%99%E7%A8%8B#4%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</link><pubDate>Wed, 03 Mar 2021 14:13:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-3-asm%E6%95%99%E7%A8%8B#4%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</guid><description>这期我们要创建一个对象和数组。
MethodVisitor methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;()V&amp;#34;, null, null); methodVisitor.visitTypeInsn(NEW, &amp;#34;java/lang/String&amp;#34;);//插入一个对象，操作码是NEW，类型是String。 methodVisitor.visitLdcInsn(&amp;#34;Enaium&amp;#34;);//插入一个LDC常量。 methodVisitor.visitMethodInsn(INVOKESPECIAL, &amp;#34;java/lang/String&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false);//插入方法调用，调用String的构造方法。 //用刚才的方法创建。 methodVisitor.visitTypeInsn(NEW, &amp;#34;cn/enaium/learn/asm/learn4/Bean&amp;#34;); methodVisitor.visitLdcInsn(&amp;#34;Enaium&amp;#34;); methodVisitor.visitMethodInsn(INVOKESPECIAL, &amp;#34;cn/enaium/learn/asm/learn4/Bean&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false); methodVisitor.visitIntInsn(SIPUSH, 2);//先需要给一个数组长度。 methodVisitor.visitIntInsn(NEWARRAY, T_BYTE);//插入一个数组，类型是byte。 methodVisitor.visitInsn(DUP);//插入一个操作，将数据压入站。 methodVisitor.visitIntInsn(SIPUSH, 0);//插入数组0的位置。 methodVisitor.visitIntInsn(SIPUSH, 1);//插入一。 methodVisitor.visitInsn(AASTORE);//保存数据。 //重复这四个操作，在数组1的位置插入二。 methodVisitor.visitInsn(DUP); methodVisitor.visitIntInsn(SIPUSH, 1); methodVisitor.visitIntInsn(SIPUSH, 2); methodVisitor.visitInsn(AASTORE); methodVisitor.visitEnd(); Bean
public class Bean { private final String name; public Bean(String name) { this.name = name; } public String getName() { return name; } }</description></item><item><title>[ASM教程]#3增加移除类成员</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#3%E5%A2%9E%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%B1%BB%E6%88%90%E5%91%98/</link><pubDate>Tue, 02 Mar 2021 23:24:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#3%E5%A2%9E%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%B1%BB%E6%88%90%E5%91%98/</guid><description>可以委托一个ClassWriter。
public class MyClassVisitor extends ClassVisitor { public MyClassVisitor(ClassWriter classWriter) { super(ASM5, classWriter); } } 这样就可以把读取到的类转换为二进制文件了。
ClassReader classReader = new ClassReader(Learn3Test.class.getName()); ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); MyClassVisitor myClassVisitor = new MyClassVisitor(classWriter); classReader.accept(myClassVisitor, 0); classWriter.toByteArray(); 重写字段访问方法，如果字段的名字一致，就返回null。
@Override public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) { if (name.equals(&amp;#34;aBoolean&amp;#34;)) { return null; } return super.visitField(access, name, desc, signature, value); } 移除方法也是一样。
@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { if (name.</description></item><item><title>[ASM教程]#2生成类</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#2%E7%94%9F%E6%88%90%E7%B1%BB/</link><pubDate>Tue, 02 Mar 2021 15:31:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#2%E7%94%9F%E6%88%90%E7%B1%BB/</guid><description>public class Learn2 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); classWriter.visit(V1_8, ACC_PUBLIC, &amp;#34;cn/enaium/learn/asm/learn2/Learn2Test&amp;#34;, null, &amp;#34;java/lang/Object&amp;#34;, null);//类信息 MethodVisitor methodVisitor = classWriter.visitMethod(ACC_PUBLIC + ACC_STATIC, &amp;#34;render&amp;#34;, &amp;#34;()V&amp;#34;, null, null);//插入方法 methodVisitor.visitFieldInsn(GETSTATIC, &amp;#34;java/lang/System&amp;#34;, &amp;#34;out&amp;#34;, &amp;#34;Ljava/io/PrintStream;&amp;#34;);//插入字段 methodVisitor.visitLdcInsn(&amp;#34;Hello ASM!&amp;#34;);//插入LDC methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &amp;#34;java/io/PrintStream&amp;#34;, &amp;#34;println&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;, false);//插入方法 methodVisitor.visitMaxs(2, 1);//设置栈和局部变量大小 methodVisitor.visitInsn(RETURN);//插入返回 methodVisitor.visitEnd();//结束 classWriter.visitEnd();//结束 //生成类 try { FileOutputStream out = new FileOutputStream(Learn2.class.getResource(&amp;#34;/cn/enaium/learn/asm/learn2/&amp;#34;).getPath() + &amp;#34;Learn2Test.class&amp;#34;); out.write(classWriter.toByteArray()); out.close(); } catch (Exception e) { e.printStackTrace(); } } }</description></item><item><title>[ASM教程]#1分析类</title><link>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#1%E5%88%86%E6%9E%90%E7%B1%BB/</link><pubDate>Tue, 02 Mar 2021 14:07:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-3-2-asm%E6%95%99%E7%A8%8B#1%E5%88%86%E6%9E%90%E7%B1%BB/</guid><description>ASM是一种通用Java字节码操作和分析框架，它可以用于修改现有的class文件或动态生成class文件。
直接进入主题，分析这个类。
public class Learn1Test { public boolean aBoolean = false; public void render() { System.out.println(&amp;#34;Hello ASM&amp;#34;); } } 先创建一个MyClassVisitor类，继承ClassVisitor。
public class MyClassVisitor extends ClassVisitor { public MyClassVisitor() { super(ASM5); } @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) { System.out.println(name + &amp;#34; extends &amp;#34; + superName + &amp;#34; {&amp;#34;); super.visit(version, access, name, signature, superName, interfaces); } @Override public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) { System.</description></item><item><title>[LWJGL3 2D教程]#6VBO</title><link>https://blog.enaium.cn/post/2021-2-28-lwjgl3-2d%E6%95%99%E7%A8%8B#6vbo/</link><pubDate>Sun, 28 Feb 2021 21:33:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-28-lwjgl3-2d%E6%95%99%E7%A8%8B#6vbo/</guid><description>创建一个Model类
public class Model { private int draw_count; private int v_id; private int t_id; public Model(float[] vertices, float[] tex_coords) { draw_count = vertices.length / 3; v_id = glGenBuffers(); glBindBuffer(GL_ARRAY_BUFFER, v_id);//绑定 glBufferData(GL_ARRAY_BUFFER, createFloatBuffer(vertices), GL_STATIC_DRAW);//静态绘制 t_id = glGenBuffers(); glBindBuffer(GL_ARRAY_BUFFER, t_id);//绑定 glBufferData(GL_ARRAY_BUFFER, createFloatBuffer(tex_coords), GL_STATIC_DRAW);//静态绘制 glBindBuffer(GL_ARRAY_BUFFER, 0);//取消绑定 } public void render() { glEnableClientState(GL_VERTEX_ARRAY);//启用顶点数组 glEnableClientState(GL_TEXTURE_COORD_ARRAY);//启用坐标数组 glBindBuffer(GL_ARRAY_BUFFER, v_id);//绑定 glVertexPointer(3, GL_FLOAT, 0, 0);//顶点 glBindBuffer(GL_ARRAY_BUFFER, t_id);//绑定 glTexCoordPointer(2, GL_FLOAT, 0, 0);// 坐标 glDrawArrays(GL_TRIANGLES, 0, draw_count);//绘制数组 glBindBuffer(GL_ARRAY_BUFFER, 0);//取消绑定 glDisableClientState(GL_VERTEX_ARRAY);//禁用顶点数组 glDisableClientState(GL_TEXTURE_COORD_ARRAY);//禁用坐标数组 } //创建缓冲区 private FloatBuffer createFloatBuffer(float[] data) { FloatBuffer buffer = BufferUtils.</description></item><item><title>自写一个EventBus</title><link>https://blog.enaium.cn/post/2021-2-23-%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAeventbus/</link><pubDate>Tue, 23 Feb 2021 22:09:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-23-%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAeventbus/</guid><description>EventBus，什么是EventBus。
EventBus是事件发布-订阅总线，简单来说监听一个事件，一个方法订阅这个事件，如果事件调用，那么订阅了这个事件的方法也会跟着调用，这就是EventBus。
创建一个注解，用于订阅事件，名字可以随便起，当然也可以叫Subscribe，我这里叫Event。
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Event { } 创建Listener监听器。
public class Listener { } 创建MethodBean类，来储存订阅方法，Object是订阅类的对象，Method就是被订阅的方法。
public class MethodBean { private final Object object; private final Method method; public MethodBean(Object object, Method method) { this.object = object; this.method = method; } public Object getObject() { return object; } public Method getMethod() { return method; } } 创建一个EventManager，来管理订阅的事件。
public class EventManager { } 创建一个HashMap合集K是监听器，V是被调用的方法，因为一个监听器可能有多个方法，并且要保证线程安全，需要使用CopyOnWriteArrayList。
public class EventManager { private final HashMap&amp;lt;Class&amp;lt;?</description></item><item><title>[CF4M教程]#5扩展</title><link>https://blog.enaium.cn/post/2021-2-22-cf4m%E6%95%99%E7%A8%8B#5%E6%89%A9%E5%B1%95/</link><pubDate>Mon, 22 Feb 2021 23:30:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-22-cf4m%E6%95%99%E7%A8%8B#5%E6%89%A9%E5%B1%95/</guid><description>现在CF4M已经更新到了1.4.7版本，现在不需用调用stop了。
public enum Example { INSTANCE; public void run() { CF4M.INSTANCE.run(this, Minecraft.getMinecraft().mcDataDir.toString() + &amp;#34;/Example&amp;#34;); } } 只需用在Module中创建一个变量，加上Setting注解即可。
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Setting(&amp;#34;test1&amp;#34;) private EnableSetting test1 = new EnableSetting(false); } CF4M没有附带Setting，需要自定义一个Setting。
public class EnableSetting { private boolean enable; public EnableSetting(boolean enable) { this.enable = enable; } public boolean getEnable() { return enable; } public void setEnable(boolean enable) { this.enable = enable; } } 自定义Event，继承Listener，要注意是CF4M的Listener，At这个参数是枚举型，分别是HEAD、TAIL和NONE，表示监听的位置，如果没有确定位置就用NONE。
要调用Call才能使Event监听这个事件。
public class Render2DEvent extends Listener { public Render2DEvent() { super(At.</description></item><item><title>[LWJGL3 2D教程]#5绘制纹理</title><link>https://blog.enaium.cn/post/2021-2-22-lwjgl3-2d%E6%95%99%E7%A8%8B#5%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 22 Feb 2021 15:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-22-lwjgl3-2d%E6%95%99%E7%A8%8B#5%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86/</guid><description>先说原理
读取一张图片，然后获取图片所有的像素，根据像素的rgba来绘制
先创建一个Texture类
public class Texture { private int id; public Texture (String path) { try { BufferedImage image = ImageIO.read(Texture.class.getResource(path)); int[] pixels = new int[image.getWidth() * image.getHeight()];//创建像素列表 image.getRGB(0, 0, image.getWidth(), image.getHeight(), pixels, 0, image.getWidth());//获取图片像素 ByteBuffer buffer = BufferUtils.createByteBuffer(image.getWidth() * image.getHeight() * 4);//创建字节缓冲区，*4是包含alpha *3不包含 //遍历图片像素转换为RGBA for (int y = 0; y &amp;lt; image.getHeight(); y++) { for (int x = 0; x &amp;lt; image.getWidth(); x++) { int pixel = pixels[y * image.</description></item><item><title>[LWJGL3 2D教程]#4按键</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#4%E6%8C%89%E9%94%AE/</link><pubDate>Sun, 21 Feb 2021 18:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#4%E6%8C%89%E9%94%AE/</guid><description>按键很简单，如果K按下，就会输出“K press“
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); if (glfwGetKey(window, GLFW_KEY_K) == GLFW_TRUE) { System.out.println(&amp;#34;K press&amp;#34;); } } 如果鼠标左键按下，就会输出“MouseLeft press“
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_TRUE) { System.out.println(&amp;#34;MouseLeft press&amp;#34;); } }</description></item><item><title>[LWJGL3 2D教程]#3绘制一个矩形</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#3%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2/</link><pubDate>Sun, 21 Feb 2021 17:50:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#3%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2/</guid><description>做一个当前上下文，创建一个createCapabilities。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); long window = glfwCreateWindow(640, 480, &amp;#34;My LWJGL Program&amp;#34;, 0, 0); if (window == NULL) { throw new RuntimeException(&amp;#34;Failed to create the GLFW window&amp;#34;); } glfwShowWindow(window); glfwMakeContextCurrent(window);//上下文 GL.createCapabilities();//createCapabilities while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } } 绘制一个矩形
while (!glfwWindowShouldClose(window)) { glfwPollEvents(); glClear(GL_COLOR_BUFFER_BIT);//清除缓冲区 glBegin(GL_QUADS);//绘制的形状(矩形) glColor4f(1, 0, 0, 0);//颜色 glVertex2d(-0.5f, 0.5f);//第一个点 glVertex2d(0.5f, 0.5f);//第二个点 glVertex2d(0.5f, -0.5f);//第三个点 glVertex2d(-0.5f, -0.5f);//第四个点 glEnd();//结束 glfwSwapBuffers(window);//交换缓冲区 }</description></item><item><title>[LWJGL3 2D教程]#2创建一个窗口</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</link><pubDate>Sun, 21 Feb 2021 16:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</guid><description>随便创建一个类，直接在main方法里执行就可以。
public static void main(String[] args) { } 先初始化，如果初始化失败，抛出异常。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } } 设置窗口默认状态。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); } 创建窗口，设置长、宽、标题，如果创建失败抛出异常。
public static void main(String[] args) { if (!glfwInit()) { throw new IllegalStateException(&amp;#34;Unable to initialize GLFW&amp;#34;); } glfwDefaultWindowHints(); long window = glfwCreateWindow(640, 480, &amp;#34;My LWJGL Program&amp;#34;, NULL, NULL); if (window == NULL) { throw new RuntimeException(&amp;#34;Failed to create the GLFW window&amp;#34;); } glfwShowWindow(window); } 创建了一个窗口，但是很快就关闭了，可以在创建窗口后，使用死循环来保证窗口不会消失，当检测到窗口关闭时，退出循环。</description></item><item><title>[LWJGL3 2D教程]#1配置开发环境</title><link>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 21 Feb 2021 16:12:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-lwjgl3-2d%E6%95%99%E7%A8%8B#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>进入LWJGL下载
我这里选：Natives全选 使用Gradle Presets选择minimal OpenGL 版本3.2.3。
然后下面出现gradle的模板
新建一个Gradle项目，就叫lwjgl吧。
我的 build.gradle
plugins { id &amp;#39;java&amp;#39; } group &amp;#39;cn.enaium.learn&amp;#39; version &amp;#39;1.0-SNAPSHOT&amp;#39; import org.gradle.internal.os.OperatingSystem project.ext.lwjglVersion = &amp;#34;3.2.3&amp;#34; switch (OperatingSystem.current()) { case OperatingSystem.LINUX: def osArch = System.getProperty(&amp;#34;os.arch&amp;#34;) project.ext.lwjglNatives = osArch.startsWith(&amp;#34;arm&amp;#34;) || osArch.startsWith(&amp;#34;aarch64&amp;#34;) ? &amp;#34;natives-linux-${osArch.contains(&amp;#34;64&amp;#34;) || osArch.startsWith(&amp;#34;armv8&amp;#34;) ? &amp;#34;arm64&amp;#34; : &amp;#34;arm32&amp;#34;}&amp;#34; : &amp;#34;natives-linux&amp;#34; break case OperatingSystem.MAC_OS: project.ext.lwjglNatives = &amp;#34;natives-macos&amp;#34; break case OperatingSystem.WINDOWS: project.ext.lwjglNatives = System.getProperty(&amp;#34;os.arch&amp;#34;).contains(&amp;#34;64&amp;#34;) ? &amp;#34;natives-windows&amp;#34; : &amp;#34;natives-windows-x86&amp;#34; break } repositories { mavenCentral() } dependencies { implementation platform(&amp;#34;org.</description></item><item><title>[CF4M教程]#4写一个简单的Config</title><link>https://blog.enaium.cn/post/2021-2-21-cf4m%E6%95%99%E7%A8%8B#4%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84config/</link><pubDate>Sun, 21 Feb 2021 14:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-21-cf4m%E6%95%99%E7%A8%8B#4%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84config/</guid><description>创建一个ModuleConfig类。
public class ModuleConfig { } 加上Config注解。
@Config(&amp;#34;Modules&amp;#34;) public class ModuleConfig { } 加入2个方法，分别写上Load和Save注解，分别是启动和退出的时候调用。
@Config(&amp;#34;Modules&amp;#34;) public class ModuleConfig { @Load public void load() { } @Save public void save() { } } 这是加载的方法。
@Load public void load() { for (ModuleProvider module : CF4M.MODULE.getAll()) {//遍历所有Module JsonArray jsonArray = new JsonArray(); try { jsonArray = new Gson().fromJson(read(CF4M.CONFIG.getByInstance(this).getPath()), JsonArray.class);//读取配置文件并存入JsonArray } catch (IOException e) { e.printStackTrace(); } for (JsonElement jsonElement : jsonArray) {//遍历JsonArray JsonObject jsonObject = jsonElement.</description></item><item><title>[CF4M教程]#3写一个简单的Command</title><link>https://blog.enaium.cn/post/2021-2-18-cf4m%E6%95%99%E7%A8%8B#3%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84command/</link><pubDate>Thu, 18 Feb 2021 14:41:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-18-cf4m%E6%95%99%E7%A8%8B#3%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84command/</guid><description>创建一个简单的Command，就叫“ToggleCommand”吧。
public class ToggleCommand { } 添加一个Command注解，只有一个参数，所以value不用写，String数组类型，就是使用这个Command的命令，可以使用“h”或者“help”来使用，当然，也可以添加更多的。
@Command({&amp;#34;t&amp;#34;, &amp;#34;toggle&amp;#34;}) public class ToggleCommand { } 只需要一个方法，加上Exec注解，命令有几个参数，方法写几个参数，就可以。
@Command({&amp;#34;t&amp;#34;, &amp;#34;toggle&amp;#34;}) public class ToggleCommand { @Exec private void exec(@Param(&amp;#34;module&amp;#34;) String name) { Object module = CF4M.INSTANCE.module.getModule(name); if (module == null) { CF4M.INSTANCE.configuration.message(&amp;#34;The module with the name &amp;#34; + name + &amp;#34; does not exist.&amp;#34;); return; } CF4M.INSTANCE.module.enable(module); } } 那么这个“configuration.message”是什么呢？
我们需要重写配置接口，来进行文本输出，默认是在控制台输出，注意要加上“Configuration”
@Configuration public class ExampleConfig implements IConfiguration { @Override public void message(String message) { MinecraftClient.</description></item><item><title>[CF4M教程]#1准备</title><link>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B#1%E5%87%86%E5%A4%87/</link><pubDate>Tue, 16 Feb 2021 13:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B#1%E5%87%86%E5%A4%87/</guid><description>访问CF4M文档
CF4M(Client Minecraft for Minecraft)是Minecraft的客户端框架可以它可以便捷的写Module,Setting,Command,Config.等等
导入 添加maven仓库
allprojects { repositories { maven { url &amp;#39;https://maven.enaium.cn&amp;#39; } } } 使用最新的CF4M 写这个文档的时候最新版是 1.8.1
dependencies { implementation &amp;#39;cn.enaium.cf4m:cf4m:1.8.1&amp;#39; } Fabric 导入 如果您用的是Fabric请导入下面的
dependencies { modImplementation &amp;#39;cn.enaium.cf4m:cf4m-fabric:1.8.1&amp;#39; } 还需要您在fabric.mod.json文件里添加
&amp;#34;depends&amp;#34;: { &amp;#34;cf4m&amp;#34;: &amp;#34;&amp;gt;=1.8.1&amp;#34; } 当然还需用在mods文件夹放入这个mod
使用 public void run() { CF4M.run(this); //参数1:当前的主类,参数2:客户端的目录(游戏目录/客户端名) // CF4M.run(this, Minecraft.getMinecraft().mcDataDir.toString() + &amp;#34;/&amp;#34; + name); } public void stop() { CF4M.stop(); } 在游戏的启动和停止的时候调用run
之后写的Module Command Config 等等都要和主类在同一包下
需要注意的是,如果您使用的是Mixin注入的方式也要这样做. mixins的包也不要和主类在同一个包下.
✔正确示范</description></item><item><title>[CF4M教程]#2写一个简单的Module</title><link>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B#2%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84module/</link><pubDate>Tue, 16 Feb 2021 13:02:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-2-16-cf4m%E6%95%99%E7%A8%8B#2%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84module/</guid><description>创建一个Sprint类.
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { } 加上了一个@Module注解.
默认参数value 就是Module的名字.
打开或关闭 在加上2个方法 分别加上@Enable和@Disbale.
@Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Enable public void onEnable() { System.out.println(&amp;#34;onEnable&amp;#34;); } @Disable public void onDisable() { System.out.println(&amp;#34;onDisable&amp;#34;); } } 在这个Module打开或者关闭的时候,分别调用onEnable和onDisable. 当然方法名可以随别写.
事件 @Module(&amp;#34;Sprint&amp;#34;) public class Sprint { @Event private void onUpdate(UpdateEvent updateEvent) { Minecraft.getMinecraft().thePlayer.setSprinting(true);//设置疾跑状态为true } @Enable public void onEnable() { System.out.println(&amp;#34;onEnable&amp;#34;); } @Disable public void onDisable() { System.out.println(&amp;#34;onDisable&amp;#34;); } } 在已经打开这个Module的前提下,如果触发了这个事件,那么就会执行这个方法.
快捷键,分类,默认启用 @Module注解有4个值,其中3个值都有默认值
String value();//Module名无默认值,必须填写 boolean enable() default false;//如果需要默认启用的话那么就设置为true int key() default 0;//快捷键 Category category() default Category.</description></item><item><title>[BlocklyNukkit入门]#10高级工作台合成</title><link>https://blog.enaium.cn/post/2021-1-19-blocklynukkit%E5%85%A5%E9%97%A8#10%E9%AB%98%E7%BA%A7%E5%B7%A5%E4%BD%9C%E5%8F%B0%E5%90%88%E6%88%90/</link><pubDate>Tue, 19 Jan 2021 18:34:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-1-19-blocklynukkit%E5%85%A5%E9%97%A8#10%E9%AB%98%E7%BA%A7%E5%B7%A5%E4%BD%9C%E5%8F%B0%E5%90%88%E6%88%90/</guid><description>创建一个物品
item = blockitem.buildItem(280, 0, 1); item.setCustomName(&amp;#34;棍&amp;#34;); blockitem.setItemLore(item, &amp;#34;第一行;第二行;第三行;第四行&amp;#34;); 添加高级工作台合成，背包里有材料才会显示
参数1类别，参数2描述，参数3材料，参数4合成的东西，参数5用时，参数6概率最大为1
blockitem.addBNCraft(&amp;#34;锻造&amp;#34;, &amp;#34;合成棍&amp;#34;, Java.to([item = blockitem.buildItem(264, 0, 1), item = blockitem.buildItem(41, 0, 2)], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), Java.to([item], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), 160, 1.0) 打开高级工作台合成
manager.newCommand(&amp;#34;dz&amp;#34;, &amp;#34;锻造&amp;#34;, function (sender, args) { blockitem.openBNCraftForPlayer(&amp;#34;锻造&amp;#34;, sender.getPlayer()); })</description></item><item><title>[BlocklyNukkit入门]#9实体</title><link>https://blog.enaium.cn/post/2021-1-15-blocklynukkit%E5%85%A5%E9%97%A8#9%E5%AE%9E%E4%BD%93/</link><pubDate>Fri, 15 Jan 2021 15:03:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2021-1-15-blocklynukkit%E5%85%A5%E9%97%A8#9%E5%AE%9E%E4%BD%93/</guid><description>当玩家使用铁锭时,把掉落物传送到玩家的位置.
事件PlayerInteractEvent 玩家交互,比如使用等等.
function PlayerInteractEvent(e) { player = e.getPlayer()//获取事件的玩家 item = blockitem.getItemInHand(player)//获取玩家手中的物品 dropItems = blockitem.getDropItems(player.getPosition())//获取玩家所在世界的掉落物 if (item.getId() == 265) {//获取物品ID是否为铁锭 for (let index = 0; index &amp;lt; dropItems.length; index++) { const element = dropItems[index]; element.setPosition(player.getPosition())//设置物品位置到玩家的位置 } } }</description></item><item><title>[BlocklyNukkit入门]#8高级窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#8%E9%AB%98%E7%BA%A7%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:10:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#8%E9%AB%98%E7%BA%A7%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;test&amp;#34;, &amp;#34;test&amp;#34;, function (sender, args) { var test = window.getCustomWindowBuilder(&amp;#34;Title&amp;#34;);//创建一个高级窗口 test.buildLabel(&amp;#34;Label&amp;#34;);//创建一个标签,参数1标题 test.buildInput(&amp;#34;Input&amp;#34;, &amp;#34;Input&amp;#34;);//创建一个输入框,参数1标题,参数2提示 test.buildToggle(&amp;#34;Toggle&amp;#34;);//创建一个开关,参数1标题 test.buildDropdown(&amp;#34;Dropdown&amp;#34;, &amp;#34;A;B;C;D;E;F;G&amp;#34;);//创建一个下拉框,参数1标题,参数2元素列表,用分号隔开 test.buildSlider(&amp;#34;Slider&amp;#34;, 0.0, 100.0, 1.0);//创建一个滑块条,参数1标题,参数2最小的值,参数3最大的值,参数4刻度 test.buildStepSlider(&amp;#34;StepSlider&amp;#34;, &amp;#34;A;B;C;D&amp;#34;);//创建一个 步骤滑块条,参数1标题,参数2元素列表,用分号隔开 test.showToPlayer(sender, &amp;#34;Call&amp;#34;); }) function Call(e) { logger.info(window./* 获取元素,参数2元素位置,从0开始,参数3元素类型 */getEventCustomVar(e, 1, &amp;#34;input&amp;#34;)); logger.info(window.getEventCustomVar(e, 2, &amp;#34;dropdown&amp;#34;)); logger.info(window.getEventCustomVar(e, 3, &amp;#34;slider&amp;#34;)); logger.info(window.getEventCustomVar(e, 4, &amp;#34;stepSlider&amp;#34;)); logger.info(window.getEventCustomVar(e, 5, &amp;#34;toggle&amp;#34;)); }</description></item><item><title>[BlocklyNukkit入门]#7选择窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#7%E9%80%89%E6%8B%A9%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:07:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#7%E9%80%89%E6%8B%A9%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;test&amp;#34;, &amp;#34;test&amp;#34;, function (sender, args) { var test = window.getModalWindowBuilder(&amp;#34;Test&amp;#34;, &amp;#34;Select&amp;#34;);//创建选择窗口 test.setButton1(&amp;#34;A&amp;#34;);//设置按钮1 test.setButton2(&amp;#34;B&amp;#34;);//设置按钮2 test.showToPlayer(sender, &amp;#34;Call&amp;#34;);//显示给玩家 }); function Call(e) { e.getPlayer().sendMessage(window.getEventResponseModal(e));//给玩家发送选择的按钮的消息 }</description></item><item><title>[BlocklyNukkit入门]#6简单窗口</title><link>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#6%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3/</link><pubDate>Sat, 31 Oct 2020 23:05:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-31-blocklynukkit%E5%85%A5%E9%97%A8#6%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3/</guid><description>manager.newCommand(&amp;#34;pa&amp;#34;, &amp;#34;pa&amp;#34;, function (sender, args) { var pa = window.getSimpleWindowBuilder(&amp;#34;Pa&amp;#34;, &amp;#34;选择一个玩家&amp;#34;);//创建一个简单的窗口 //遍历全服玩家 onlines = Java.type(&amp;#34;cn.nukkit.Server&amp;#34;).getInstance().getOnlinePlayers().values().toArray(); for (let index = 0; index &amp;lt; onlines.length; index++) { const element = onlines[index]; pa.buildButton(element.getName(), &amp;#34;&amp;#34;);//添加按钮 参数1标题 参数2图片 没有留空 } pa.showToPlayer(sender, &amp;#34;Call&amp;#34;);//参数1显示的玩家 参数2函数名 });//创建命令 function Call(e)//显示给玩家的函数 { server.getPlayer(window.getEventResponseText(e)/* 获取按下的按钮名 */)/* 获取玩家 */.sendMessage(&amp;#34;Pa!&amp;#34;);//给玩家发送消息 }</description></item><item><title>[BlocklyNukkit入门]#5自定义物品</title><link>https://blog.enaium.cn/post/2020-10-19-blocklynukkit%E5%85%A5%E9%97%A8#5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E5%93%81/</link><pubDate>Mon, 19 Oct 2020 19:51:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-19-blocklynukkit%E5%85%A5%E9%97%A8#5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E5%93%81/</guid><description>自定义物品 创建一个木棍 item = blockitem.buildItem(280, 0, 1); 设置名字
item.setCustomName(&amp;#34;棍&amp;#34;); 设置信息,用分号隔开换行
blockitem.setItemLore(item, &amp;#34;第一行;第二行;第三行;第四行&amp;#34;); 添加有序合成 添加有序合成,设置G为橡木原木的键,G就代表原木. 参数1用字符串数组类型,3个字符串代表合成台的3行,每一行有3个物品,用键来代表,空格代表没物品. 参数2是合成后的物品. 参数3是追加结果物品，物品数组类型，比如合成蛋糕会返给3个桶.
manager.putEasy(&amp;#34;G&amp;#34;, blockitem.buildItemFromBlock(blockitem.buildBlock(17, 0))); blockitem.addShapedCraft(Java.to([&amp;#34;G &amp;#34;, &amp;#34;G &amp;#34;, &amp;#34;G &amp;#34;], &amp;#34;java.lang.String[]&amp;#34;), item, Java.to([], &amp;#34;cn.nukkit.item.Item[]&amp;#34;)); 创建第二个木棍 superItem = blockitem.buildItem(369, 0, 1); superItem.setCustomName(&amp;#34;Super棍&amp;#34;); blockitem.setItemLore(superItem, &amp;#34;第五行;第六行;第七行;第八行;第九行&amp;#34;); 添加无序合成 参数1就是需要合成的配方，参数2就是合成后的物品
blockitem.addShapelessCraft(Java.to([item, blockitem.buildItemFromBlock(blockitem.buildBlock(41, 0))], &amp;#34;cn.nukkit.item.Item[]&amp;#34;), superItem);</description></item><item><title>[BlocklyNukkit入门]#4创建命令</title><link>https://blog.enaium.cn/post/2020-10-18-blocklynukkit%E5%85%A5%E9%97%A8#4%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 18 Oct 2020 22:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-18-blocklynukkit%E5%85%A5%E9%97%A8#4%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</guid><description>喊话 创建一个命令
manager.newCommand(&amp;#34;shout&amp;#34;, &amp;#34;喊话&amp;#34;, function (sender, args) { }); Python可以吧function改为方法名 比如
manager.createCommand(&amp;#34;shout&amp;#34;, u&amp;#34;喊话&amp;#34;, &amp;#34;myCallBack&amp;#34;) def myCallBack(sender, args): pass 遍历全服玩家
alllist = Java.type(&amp;#34;cn.nukkit.Server&amp;#34;).getInstance().getOnlinePlayers().values().toArray(); 向全服玩家发送消息
for (var i = 0; i &amp;lt; alllist.length; i++) { alllist[i].sendMessage(args[0]); }</description></item><item><title>[BlocklyNukkit入门]#3玩家进服欢迎</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#3%E7%8E%A9%E5%AE%B6%E8%BF%9B%E6%9C%8D%E6%AC%A2%E8%BF%8E/</link><pubDate>Sat, 03 Oct 2020 21:09:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#3%E7%8E%A9%E5%AE%B6%E8%BF%9B%E6%9C%8D%E6%AC%A2%E8%BF%8E/</guid><description>进服欢迎 我们可以在bn的文档里查到PlayerJoinEvent玩家进入服务器的事件 这样我们就可以很“方便”的编写插件了
JavaScript function PlayerJoinEvent(e) { e.getPlayer().sendMessage(&amp;#34;欢迎&amp;#34; + e.getPlayer().getName() + &amp;#34;进入服务器！JavaScript&amp;#34;); } Python def PlayerJoinEvent(e): e.getPlayer().sendMessage(u&amp;#34;欢迎&amp;#34; + e.getPlayer().getName() + u&amp;#34;进入服务器！Python&amp;#34;) Lua function PlayerJoinEvent(e) e:getPlayer():sendMessage(&amp;#34;欢迎&amp;#34; .. e:getPlayer():getName() .. &amp;#34;进入服务器！Lua&amp;#34;) end</description></item><item><title>[BlocklyNukkit入门]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 03 Oct 2020 20:32:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>配置Nukkit 这里用PowerNukkit举例
下载好之后用java -jar nukkit.jar运行客户端 语言选自选
如果没正版把server.properties里的xbox-auth=on改成xbox-auth=off
配置BlocklyNukkit 下载BlocklyNukkit放到./plugins文件夹里面
完成</description></item><item><title>[BlocklyNukkit入门]#2HelloWorld</title><link>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#2helloworld/</link><pubDate>Sat, 03 Oct 2020 20:32:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-10-3-blocklynukkit%E5%85%A5%E9%97%A8#2helloworld/</guid><description>编写插件 BlocklyNukkit以下简称bn
bn支持JavaScript、Python和Lua等脚本语言 也有图形编辑器
JavaScript logger.info(&amp;#34;Hello JavaScript!&amp;#34;); Python 注意！ 如果有汉字等特殊字符要加上# -*- encoding: utf-8 -*-注释
print u&amp;#34;Hello Python!&amp;#34; Lua logger:info(&amp;#34;Hello Lua!&amp;#34;) 使用插件 放入文件夹./plugin/BlocklyNukkit里面</description></item><item><title>[30天自制操作系统]第一天错误解决</title><link>https://blog.enaium.cn/post/2020-9-25-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E5%A4%A9%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</link><pubDate>Fri, 25 Sep 2020 17:14:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-25-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E5%A4%A9%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</guid><description>书里的
; hello-os ; TAB=4 ; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code DB	0xeb, 0x4e, 0x90 DB	&amp;#34;HELLOIPL&amp;#34;	; 启动扇区名称（8字节） DW	512	; 每个扇区（sector）大小（必须512字节） DB	1	; 簇（cluster）大小（必须为1个扇区） DW	1	; FAT起始位置（一般为第一个扇区） DB	2	; FAT个数（必须为2） DW	224	; 根目录大小（一般为224项） DW	2880	; 该磁盘大小（必须为2880扇区1440*1024/512） DB	0xf0	; 磁盘类型（必须为0xf0） DW	9	; FAT的长度（必须是9扇区） DW	18	; 一个磁道（track）有几个扇区（必须为18） DW	2	; 磁头数（必须是2） DD	0	; 不使用分区，必须是0 DD	2880	; 重写一次磁盘大小 DB	0,0,0x29	; 意义不明（固定） DD	0xffffffff	; （可能是）卷标号码 DB	&amp;#34;HELLO-OS &amp;#34;	; 磁盘的名称（必须为11字节，不足填空格） DB	&amp;#34;FAT12 &amp;#34;	; 磁盘格式名称（必须是8字节，不足填空格） RESB	18	; 先空出18字节 ; 程序主体 DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb DB	0xee, 0xf4, 0xeb, 0xfd ; 信息显示部分 DB	0x0a, 0x0a	; 换行两次 DB	&amp;#34;hello, world&amp;#34; DB	0x0a	; 换行 DB	0 RESB	RESB 0x1fe-$	; 填写0x00直到0x001fe DB	0x55, 0xaa ; 启动扇区以外部分输出 DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB	4600 DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB	1469432 作者用的是nask 那么用nasm的话会出现 问题 .</description></item><item><title>[Jekyll入门]#4条件、循环</title><link>https://blog.enaium.cn/post/2020-9-24-jekyll%E5%85%A5%E9%97%A8#4%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Thu, 24 Sep 2020 19:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-24-jekyll%E5%85%A5%E9%97%A8#4%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>条件 循环</description></item><item><title>[Jekyll入门]#3布局</title><link>https://blog.enaium.cn/post/2020-9-23-jekyll%E5%85%A5%E9%97%A8#3%E5%B8%83%E5%B1%80/</link><pubDate>Wed, 23 Sep 2020 19:14:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-23-jekyll%E5%85%A5%E9%97%A8#3%E5%B8%83%E5%B1%80/</guid><description>布局 自定义 创建_layouts目录 创建布局post.html 布局使用布局 在布局中也能使用其他布局
默认布局 所有布局都会使用一个default的布局</description></item><item><title>[Jekyll入门]#2配置、帖子、页面</title><link>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8#2%E9%85%8D%E7%BD%AE%E5%B8%96%E5%AD%90%E9%A1%B5%E9%9D%A2/</link><pubDate>Tue, 22 Sep 2020 22:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8#2%E9%85%8D%E7%BD%AE%E5%B8%96%E5%AD%90%E9%A1%B5%E9%9D%A2/</guid><description>配置 title: Myblog #标题 email: Myblog@example.com #邮箱 description: &amp;gt;- #说明 This is my blog. baseurl: &amp;#34;&amp;#34; #仓库名 比如 myblog url: &amp;#34;&amp;#34; #域名 twitter_username: Myblog #推特 github_username: Myblog #github # Build settings theme: minima #主题 plugins: #插件 - jekyll-feed 帖子 文件名 日期-文件名(标题) 用-代表空格
头部信息 --- layout: post #布局 title: &amp;#34;My first post!&amp;#34; #标题 date: 2020-09-22 22:19 #时间 categroy: jekyll update #分类 --- 页面 文件名 文件名和链接名一致
头部信息 --- layout: page #布局 title: Donation #标题 permalink: /donation/ #永久链接 ---</description></item><item><title>[Jekyll入门]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 22 Sep 2020 19:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-9-22-jekyll%E5%85%A5%E9%97%A8#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>安装Ruby RubyInstaller
安装Jekyll jekyll new myblog cd myblog jekyll serve 预览 http://127.0.0.1:4000/</description></item><item><title>Java插件化开发</title><link>https://blog.enaium.cn/post/2020-5-4-java%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 04 May 2020 09:17:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-5-4-java%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>在java程序开发过程中. 可能需要加载插件的功能. 所以要动态加载Jar文件来实现插件的加载.
我这边用了Kotlin
一. 创建接口 interface PluginInitializer { fun onInitialize()//插件初始化 } 二. 加载插件 加载的插件可能会抛出什么异常所以要用try
private val file = File(&amp;#34;plugins&amp;#34;) private val plugins: ArrayList&amp;lt;PluginInitializer&amp;gt; = ArrayList() init { try { if (file.listFiles().isNotEmpty()) { for (f in file.listFiles()) { if (f.name.endsWith(&amp;#34;.jar&amp;#34;) {//判断文件后缀是否为.jar val u = URLClassLoader(arrayOf&amp;lt;URL&amp;gt;(f.toURL()), Thread.currentThread().contextClassLoader)//加载Jar plugins.add(u.loadClass(&amp;#34;cn.enaium.plugin.Test&amp;#34;).newInstance() as PluginInitializer)//加载主类 } } } if (plugins.isNotEmpty()) { for (p in plugins) { p.onInitialize()//初始化插件 } } } catch (e: Exception) { } } 三.</description></item><item><title>使用 SpringBoot+Vue 实现留言版</title><link>https://blog.enaium.cn/post/2020-4-20-%E4%BD%BF%E7%94%A8-springboot+vue-%E5%AE%9E%E7%8E%B0%E7%95%99%E8%A8%80%E7%89%88/</link><pubDate>Mon, 20 Apr 2020 17:29:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-4-20-%E4%BD%BF%E7%94%A8-springboot+vue-%E5%AE%9E%E7%8E%B0%E7%95%99%E8%A8%80%E7%89%88/</guid><description>完成源码 一.新建Vue项目和SpringBoot项目 新建Vue项目 新建文件夹SpringBoot-Vue-MessageBoard 创建Vue项目使用vue ui命令(需要vue 3.0 选择刚才的目录 名字为Vue创建后V还是小写 创建后可以改为大写 取消git初始化 手动配置 取消 打开 创建项目，不保存预设
新建SpringBoot项目 用IDEA打开SpringBoot-Vue-MessageBoard这个目录 创建SpringBoot项目 右键 选择Spring Initializr 选择这四个 名字改为SpringBoot
二. 后端 配置application.properties #Mysql spring.datasource.url=jdbc:mysql://localhost:3306/enaium?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.jpa.show-sql= true spring.jpa.properties.hibernate.format_sql = true #Server server.port=8181 写实体类 package cn.enaium.message.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.Entity; import javax.persistence.Id; /** * Project: message * ----------------------------------------------------------- * Copyright © 2020 | Enaium | All rights reserved. */ @Data @Entity @NoArgsConstructor @AllArgsConstructor public class Message { @Id private Long id; private String author; private String message; private String time; } 实体类Jpa package cn.</description></item><item><title>[全民写端第二季]#2移植</title><link>https://blog.enaium.cn/post/2020-3-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3#2%E7%A7%BB%E6%A4%8D/</link><pubDate>Sat, 28 Mar 2020 18:43:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3#2%E7%A7%BB%E6%A4%8D/</guid><description>一. 把第一季的源码复制过来
二. 注入
注入run 和 top @Mixin(Minecraft.class) public class MinecraftMixin { @Inject(at = @At(&amp;#34;RETURN&amp;#34;), method = &amp;#34;startGame&amp;#34;) private void startGame(CallbackInfo info) { FoxBase.instance.run(); } @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;shutdownMinecraftApplet&amp;#34;) private void stop(CallbackInfo info) { FoxBase.instance.stop(); } } 注入EventUpdate EventKeyboard EventRender2D @Mixin(Minecraft.class) public class MinecraftMixin { @Inject(at = @At(&amp;#34;RETURN&amp;#34;), method = &amp;#34;dispatchKeypresses&amp;#34;) private void dispatchKeypresses(CallbackInfo info) { if (Keyboard.getEventKeyState() &amp;amp;&amp;amp; Minecraft().getMinecraft().currentScreen == null) new EventKeyboard(Keyboard.getEventKey() == 0 ? Keyboard.getEventCharacter() + 256 : Keyboard,getEventKey()).</description></item><item><title>[全民写端第二季]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-3-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Wed, 25 Mar 2020 19:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>下载FoxBase 如果你想修改名字可以在gradle.build文件修改archivesBaseName
从项目的根目录运行以下命令: ./gradlew setupDevWorkspace idea genIntellijRuns build 打开 IntelliJ IDEA. Open Open =&amp;gt; Select FoxBase folder Click Import gradle project 添加VM options -Dfml.coreMods.load=cn.enaium.foxbase.injection.MixinLoader 完成！</description></item><item><title>[全民写端]#12绘制ClickGUI</title><link>https://blog.enaium.cn/post/2020-3-14-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#12-%E7%BB%98%E5%88%B6clickgui/</link><pubDate>Sat, 14 Mar 2020 17:52:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-14-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#12-%E7%BB%98%E5%88%B6clickgui/</guid><description>一. 先复制进去FontUtils
FontUtils package cn.enaium.coreium.utils; import net.minecraft.client.Minecraft; import net.minecraft.client.gui.FontRenderer; import net.minecraft.util.StringUtils; public class FontUtils { private static FontRenderer fontRenderer; public static void setupFontUtils() { fontRenderer = Minecraft.getMinecraft().fontRendererObj; } public static int getStringWidth(String text) { return fontRenderer.getStringWidth(StringUtils.stripControlCodes(text)); } public static int getFontHeight() { return fontRenderer.FONT_HEIGHT; } public static void drawString(String text, int x, int y, int color) { fontRenderer.drawString(text, x, y, color); } public static void drawStringWithShadow(String text, double x, double y, int color) { fontRenderer.</description></item><item><title>[全民写端]#11绘制主菜单</title><link>https://blog.enaium.cn/post/2020-3-3-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#11%E7%BB%98%E5%88%B6%E4%B8%BB%E8%8F%9C%E5%8D%95/</link><pubDate>Tue, 03 Mar 2020 11:01:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-3-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#11%E7%BB%98%E5%88%B6%E4%B8%BB%E8%8F%9C%E5%8D%95/</guid><description>一. 搜索GuiMainMenu这个类
二. 删除drawScreen方法内所有
三. 删除无用方法(显示为灰色的方法)
四. 在drawScreen方法绘制
public void drawScreen(int mouseX, int mouseY, float partialTicks) { //获取屏幕长和高 ScaledResolution s = new ScaledResolution(mc); //绑定纹理(材质) mc.getTextureManager().bindTexture(new ResourceLocation(&amp;#34;coreium/background.jpg&amp;#34;)); //绘制纹理(材质) Gui.drawModalRectWithCustomSizedTexture(0, 0, 0, 0, s.getScaledWidth(), s.getScaledHeight(), s.getScaledWidth(), s.getScaledHeight()); //绘制标题 fontRendererObj.drawString(Coreium.INSTANCE.name, s.getScaledWidth() / 2 - fontRendererObj.getStringWidth(Coreium.INSTANCE.name) / 2, 30, new Color(30, 0, 255).getRGB()); super.drawScreen(mouseX, mouseY, partialTicks); } 五. 放入纹理(材质) 在assets.minecraft新建一个coreium包 放入背景 完成</description></item><item><title>用Gitee搭建私有Maven仓库</title><link>https://blog.enaium.cn/post/2020-3-1-%E7%94%A8gitee%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89maven%E4%BB%93%E5%BA%93/</link><pubDate>Sun, 01 Mar 2020 19:53:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-3-1-%E7%94%A8gitee%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89maven%E4%BB%93%E5%BA%93/</guid><description>一. 新建仓库
二. 上传index
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Enaium&amp;#39;s maven repository &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 三. 开通Gitee Pages
四. 上传文件
五. 部署
⚠上传的文件部署后才能从Gitee Pages中下载到</description></item><item><title>[全民写端]#10绘制ToggleModules</title><link>https://blog.enaium.cn/post/2020-2-29%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#10%E7%BB%98%E5%88%B6togglemodules/</link><pubDate>Sat, 29 Feb 2020 18:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-29%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#10%E7%BB%98%E5%88%B6togglemodules/</guid><description>一.添加EventRender2D
public class EventRender2D extends Event { public EventRender2D() { super(Type.PRE); } } 二.钩子
搜索GuiIngame这个类打开 找到renderGameOverlay这个类 在if (this.mc.playerController.isSpectator()){[...]}else{[...]}后面添加 GlStateManager.pushMatrix(); new EventRender2D().call(); GlStateManager.popMatrix(); 三. 绘制HUD
新建HUD类 在onRender方法里面写绘制 添加到loadModsthis.addModule(new HUD()); package cn.enaium.coreium.module.render; import cn.enaium.coreium.event.EventTarget; import cn.enaium.coreium.event.events.EventRender2D; import cn.enaium.coreium.module.Category; import cn.enaium.coreium.module.Module; import org.lwjgl.input.Keyboard; public class HUD extends Module { public HUD() { super(&amp;#34;HUD&amp;#34;, Keyboard.KEY_P, Category.RENDER); } @EventTarget public void onRender(EventRender2D e) { } } //字体 FontRenderer fr = mc.fontRendererObj; //获取屏幕长和高 ScaledResolution sr = new ScaledResolution(mc); ArrayList&amp;lt;Module&amp;gt; modules = new ArrayList(); for (Module m : Coreium.</description></item><item><title>[全民写端]#9添加配置</title><link>https://blog.enaium.cn/post/2020-2-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#9%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 28 Feb 2020 12:21:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-28-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#9%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/</guid><description>一. 添加Config
下载Config解压到你想要的目录
二.添加到Start
[...] public ConfigManager configManager; public void start() { [...] configManager = new ConfigManager(); Display.setTitle(Coreium.INSTANCE.name); [...] configManager.loadConfig(); } public void stop() { configManager.saveConfig(); }</description></item><item><title>[全民写端]#8简化代码</title><link>https://blog.enaium.cn/post/2020-2-26-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#8%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</link><pubDate>Wed, 26 Feb 2020 16:46:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-26-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#8%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</guid><description>一. 简化端名和版本
在INSTANCE写
public String name = &amp;#34;Coreium&amp;#34;; public String version = &amp;#34;B1&amp;#34;; 就可以直接使用Coreium.INSTANCE.name来获取
二. 简化Module
在Module类中加入protected Minecraft mc = Minecraft.getMinecraft(); mc.thePlayer.setSprinting(true);直接使用
三. 简化addSetting
protected void addSetting(Setting setting) { Coreium.INSTANCE.settingManager.addSetting(setting); }</description></item><item><title>[全民写端]#7添加Command</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#7%E6%B7%BB%E5%8A%A0command/</link><pubDate>Tue, 25 Feb 2020 18:34:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#7%E6%B7%BB%E5%8A%A0command/</guid><description>一. 添加Command
下载Command解压到你想要的目录
二. 添加到Start
[...] public CommandManager commandManager; public void start() { [...] commandManager = new CommandManager(); Display.setTitle(&amp;#34;Coreium&amp;#34;); moduleManager.loadMods(); commandManager.loadCommands(); [...] } [...] 三. 在ModuleManager中添加getModule方法
[...] public Module getModule(String name) { for (Module m : modules) { if (m.getName().equalsIgnoreCase(name)) return m; } return null; } [...] 四. 新建一个PlayerUtils类
package cn.enaium.coreium.utils; import com.mojang.realmsclient.gui.ChatFormatting; import net.minecraft.client.Minecraft; public class PlayerUtils { public static void tellPlayer(String text) { Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(new ChatComponentText( ChatFormatting.WHITE + &amp;#34;[&amp;#34; + ChatFormatting.</description></item><item><title>[全民写端]#6添加Setting</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#6%E6%B7%BB%E5%8A%A0setting/</link><pubDate>Tue, 25 Feb 2020 18:00:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#6%E6%B7%BB%E5%8A%A0setting/</guid><description>一. 写Setting类
package cn.enaium.coreium.setting; import cn.enaium.coreium.module.Module; import java.util.ArrayList; public class Setting { private Module module; private String name; private boolean toggle; private double currentValueDouble, minValueDouble, maxValueDouble; private int currentValueInt, minValueInt, maxValueInt; private float currentValueFloat, minValueFloat, maxValueFloat; private ArrayList&amp;lt;String&amp;gt; modes; private String currentMode; private Category category; public enum Category { BOOLEAN, VALUE_INT, VALUE_DOUBLE, VALUE_FLOAT, MODE; } public Setting(Module module, String name, boolean toggle) { this.module = module; this.name = name; this.toggle = toggle; this.</description></item><item><title>[全民写端]#5自动疾跑</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#5%E8%87%AA%E5%8A%A8%E7%96%BE%E8%B7%91/</link><pubDate>Tue, 25 Feb 2020 13:40:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#5%E8%87%AA%E5%8A%A8%E7%96%BE%E8%B7%91/</guid><description>一. 新建Sprint类
package cn.enaium.coreium.module.movement; import cn.enaium.coreium.event.EventTarget; import cn.enaium.coreium.event.events.EventUpdate; import cn.enaium.coreium.module.Category; import cn.enaium.coreium.module.Module; import net.minecraft.client.Minecraft; import org.lwjgl.input.Keyboard; public class Sprint extends Module { public Sprint() { super(&amp;#34;Sprint&amp;#34;, Keyboard.KEY_V, Category.MOVEMENT); } @EventTarget public void onUpdate(EventUpdate e) { Minecraft.getMinecraft().thePlayer.setSprinting(true); } } 二. 添加到loadModules
public void loadMods() { this.addModule(new Sprint()); } 三. 运行
按V打开</description></item><item><title>[全民写端]#4添加Event和Module</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#4%E6%B7%BB%E5%8A%A0event%E5%92%8Cmodule/</link><pubDate>Tue, 25 Feb 2020 13:03:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#4%E6%B7%BB%E5%8A%A0event%E5%92%8Cmodule/</guid><description>一. 添加Event
下载Event解压到你想要的目录 修改Event 二. 钩子
在EntityPlayerSP类里面找到onUpdate方法 在第一行写 new EventUpdate().call(); 在Minecraft类里找到runTick方法 找到Keyboard.next()循环 在if (k == 62 &amp;amp;&amp;amp; this.entityRenderer != null)下面写 new EventKeyboard(k).call(); public void onUpdate() { new EventUpdate().call(); if (k == 62 &amp;amp;&amp;amp; this.entityRenderer != null) { this.entityRenderer.switchUseShader(); } new EventKeyboard(k).call(); if (this.currentScreen != null) 三. 写Category枚举
package cn.enaium.coreium.module; public enum Category { COMBAT, RENDER, MOVEMENT, PLAYER, OTHER } 四. 写Module类
package cn.enaium.coreium.module; import cn.enaium.coreium.Coreium; public class Module { private boolean toggle; private String name; private int keyCode; private Category category; public Module(String name, int keyCode, Category category) { this.</description></item><item><title>[全民写端]#3添加OptiFine</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#3%E6%B7%BB%E5%8A%A0optifine/</link><pubDate>Tue, 25 Feb 2020 12:16:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#3%E6%B7%BB%E5%8A%A0optifine/</guid><description>一. 下载Optifine本站下载
二. 删除src\minecraft所有内容 将Optifine解压进去(保留你写的包)
三. 根据#2的方法修改Minecraft类调用Start 和 Stop
四. 导入vecmath包
五. 修改类名net.minecraft.client.renderer包下的EntityRenderer$1 EntityRenderer$2 改为EntityRenderer1 EntityRenderer2
六. 启动</description></item><item><title>[全民写端]#2设置启动和停止</title><link>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#2%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</link><pubDate>Tue, 25 Feb 2020 10:42:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-25-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#2%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</guid><description>一. 写启动和停止
在你想要的地方新建一个类 改为enum 写一个枚举 INSTANCE; 写两个方法分别是 start 和 stop
public enum Coreium { INSTANCE; public void start() { } public void stop() { } } 在启动和退出游戏的时候调用这2个类 搜索Minecraft 找到startGame在这个方法在最后面写Coreium.INSTANCE.start(); 找到shutdownMinecraftApplet在logger.info(&amp;quot;Stopping!&amp;quot;);后面写Coreium.INSTANCE.stop();
[...] this.renderGlobal.makeEntityOutlineShader(); Coreium.INSTANCE.start(); } private void registerMetadataSerializers() { [...] public void shutdownMinecraftApplet() { try { this.stream.shutdownStream(); logger.info(&amp;#34;Stopping!&amp;#34;); Coreium.INSTANCE.stop(); [...] 二. 修改游戏标题
在Minecraft类中我们搜索Display.Title会找到Display.setTitle(&amp;quot;Minecraft 1.8.8&amp;quot;);这个就是修改标题 我们现在知道了修改标题的方法
在start里面写Display.setTitle(&amp;quot;Coreium&amp;quot;);就是吧标题改为Coreium 运行</description></item><item><title>[全民写端]#1配置开发环境</title><link>https://blog.enaium.cn/post/2020-2-24-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 24 Feb 2020 18:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-%E5%85%A8%E6%B0%91%E5%86%99%E7%AB%AF#1%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDEA
一. 下载MCP
二. 解压到你想要的路径,文件名你想起什么名字就起什么名字
三. 打开文件夹运行decompile.bat,Linux 或者Mac OS 运行decompile.sh(这一步必有正版启动器,而且默认目录%APPDATA%.minecraft\versions 必须要有MC1.8.8版本,运行前还要运行过1.8.8MC.)
反编译完成 四. 导入IDEA
Next Next Next Finish 填写你的导入的目录 这个目录将你以后的所有写端项目的目录,删除后除了重新设置目录你将无法读取到lib,(以后新建项目不会提示填写目录).
提示的1.6什么什么的错误信息不用管点OK就行了 五. 设置项目
全部点× 六. 运行
打开Start 选右上角的Setup SDK选中1.8 运行 七. 启动设置
运行后出现错误需要设置启动 -Djava.library.path=versions\1.8.8\1.8.8-natives</description></item><item><title>Minecraft Fabric 进阶教程 #2 绘制界面</title><link>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-#2-%E7%BB%98%E5%88%B6%E7%95%8C%E9%9D%A2/</link><pubDate>Mon, 24 Feb 2020 16:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-#2-%E7%BB%98%E5%88%B6%E7%95%8C%E9%9D%A2/</guid><description>绘制界面不需用注入Mixin
新建一个类 ExampleGui.java
继承Screen构造器
public ExampleGui() { super(new LiteralText(&amp;#34;&amp;#34;)); } 绘制 这是绘制一个背景
绘制背景这种全部覆盖时要在super上面不然按钮或者其他东西会被背景盖住
@Override public void render(int mouseX, int mouseY, float delta) { renderBackground(); super.render(mouseX, mouseY, delta); } 我们也可以添加一个按钮
@Override public void init() { super.init(); this.addButton(new ButtonWidget(20,20,100,20,&amp;#34;Done&amp;#34;,(action)-&amp;gt;{ })); } 打开界面
将上集绘制的按钮的action改为打开这个界面
@Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { this.addButton(new ButtonWidget(20,20,200,20,&amp;#34;233&amp;#34;,(action)-&amp;gt;{ MinecraftClient.getInstance().openScreen(new ExampleGui()); })); } 打开界面后我们发现只能用ESC来关闭界面
接下来我们要写返回上一界面的功能
在构造器里传入上个界面Screen
private Screen screen; public ExampleGui(Screen screen) { super(new LiteralText(&amp;#34;&amp;#34;)); this.</description></item><item><title>Minecraft Fabric 进阶教程 #1 绘制按钮</title><link>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-#1-%E7%BB%98%E5%88%B6%E6%8C%89%E9%92%AE/</link><pubDate>Mon, 24 Feb 2020 13:56:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-24-minecraft-fabric-%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B-#1-%E7%BB%98%E5%88%B6%E6%8C%89%E9%92%AE/</guid><description>在Mixin包里新建一个类 注入到TitleScreen.class里
注入到这个类的init的方法的头部也就是最上面所以at是HEAD
因为init方法没有参数所以方法就是init()V
因为注入都有一个回调信息所以要有一个回调参数CallbackInfo
@Mixin(TitleScreen.class) public class TitleMixin { @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { } } 用IDEA反编译TitleScreen.classinit方法可以看到this.addButton这个就是添加按钮
所以我们要在Mixin里面写添加按钮
需要继承Screen类
按照提示生成构造器就行了
protected TitleMixin(Text title) { super(title); } 现在添加按钮 @Inject(at = @At(&amp;#34;HEAD&amp;#34;), method = &amp;#34;init()V&amp;#34;) private void init(CallbackInfo info) { this.addButton(new ButtonWidget(20,20,200,20,&amp;#34;233&amp;#34;,(action)-&amp;gt;{ System.out.println(&amp;#34;By Enaium&amp;#34;); })); } 在x20 y20处绘制一个长200高20(高必须为20)的按钮标题为“233”点击触发action输出By Enaium
添加到mixin.json
我们运行一下看看
成功</description></item><item><title>星露谷MOD开发教程 #1 配置开发环境</title><link>https://blog.enaium.cn/post/2020-2-9-%E6%98%9F%E9%9C%B2%E8%B0%B7-mod-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 09 Feb 2020 19:00:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-9-%E6%98%9F%E9%9C%B2%E8%B0%B7-mod-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>要求 安装了SMAPI IDE (推荐使用Visual Studio或者Rider) 准备 创建一个类库项目 引用Pathoschild.Stardew.ModBuildConfigNuget包 创建一个类 新建manifest.json文件 格式
{ &amp;#34;Name&amp;#34;: &amp;#34;&amp;lt;your project name&amp;gt;&amp;#34;, &amp;#34;Author&amp;#34;: &amp;#34;&amp;lt;your name&amp;gt;&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;Description&amp;#34;: &amp;#34;&amp;lt;One or two sentences about the mod&amp;gt;&amp;#34;, &amp;#34;UniqueID&amp;#34;: &amp;#34;&amp;lt;your name&amp;gt;.&amp;lt;your project name&amp;gt;&amp;#34;, &amp;#34;EntryDll&amp;#34;: &amp;#34;&amp;lt;your project name&amp;gt;.dll&amp;#34;, &amp;#34;MinimumApiVersion&amp;#34;: &amp;#34;2.10.0&amp;#34;, &amp;#34;UpdateKeys&amp;#34;: [] } 开始 继承父类Mod
添加一个事件
using StardewModdingAPI; using StardewModdingAPI.Events; namespace NewMod { public class NewMod : Mod { public override void Entry(IModHelper helper) { helper.Events.Input.ButtonPressed += onButtonPressed; } private void onButtonPressed(object sender, ButtonPressedEventArgs e) { //如果世界没有完成返回 if(!</description></item><item><title>使用WPF设计工具-MaterialDesignInXamlToolkit</title><link>https://blog.enaium.cn/post/2020-2-3-%E4%BD%BF%E7%94%A8wpf%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7-materialdesigninxamltoolkit/</link><pubDate>Mon, 03 Feb 2020 10:18:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-2-3-%E4%BD%BF%E7%94%A8wpf%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7-materialdesigninxamltoolkit/</guid><description>MaterialDesignInXamlToolkit
安装Nuget包MaterialDesignThemes 添加到App.xaml &amp;lt;ResourceDictionary&amp;gt; &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml&amp;#34; /&amp;gt; &amp;lt;ResourceDictionary Source=&amp;#34;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml&amp;#34; /&amp;gt; &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;/ResourceDictionary&amp;gt; 加入Window中 xmlns:materialDesign=&amp;quot;http://materialdesigninxaml.net/winfx/xaml/themes&amp;quot;
完成</description></item><item><title>Minecraft Fabric Client 教程 #5 添加Event、Sprint和ToggleCommand</title><link>https://blog.enaium.cn/post/2020-1-20-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#5-%E6%B7%BB%E5%8A%A0eventsprint%E5%92%8Ctogglecommand/</link><pubDate>Mon, 20 Jan 2020 13:27:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-20-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#5-%E6%B7%BB%E5%8A%A0eventsprint%E5%92%8Ctogglecommand/</guid><description>添加Event 下载
放在cn.enaium.excel里
然后在Excel.java里面添加EventManager
public enum Excel { [...] public EventManager eventManager; public void onEnable() { eventManager = new EventManager(); commandManager = new CommandManager(); moduleManager = new ModuleManager(); moduleManager.loadModules(); } [...] } 在Module.java里面添加Event、onEnable()、onDisable()、Toggle()
public class Module { [...] public void Toggle() { this.toggled = !this.toggled; if (this.toggled) { onEnable(); } else { onDisable(); } } public void onEnable() { Excel.INSTANCE.eventManager.register(this); } public void onDisable() { Excel.INSTANCE.eventManager.unregister(this); } } 注入Mixin 在 ClientPlayerEntityMixin.</description></item><item><title>解决Gradle不能构建问题</title><link>https://blog.enaium.cn/post/2020-1-12-%E8%A7%A3%E5%86%B3gradle%E4%B8%8D%E8%83%BD%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 12 Jan 2020 15:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-12-%E8%A7%A3%E5%86%B3gradle%E4%B8%8D%E8%83%BD%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98/</guid><description>绝大数的gradle项目用的都是私服并且换上镜像也没用因为私服的东西镜像没有
而且非私服的速度也不是很慢
我这里找到了一个解决办法就是用国际浏览手机自带的国际上网功能
购买国际上网的国内流量也不贵也就是5元3G左右
购买流量后开启它然后打开手机热点给电脑供网 USB/热点 供网
开始构建
虽然不是很快但是总比以前的不能构建强很多</description></item><item><title>Minecraft Fabric Client 教程 #4 添加Modules</title><link>https://blog.enaium.cn/post/2020-1-9-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#4-%E6%B7%BB%E5%8A%A0modules/</link><pubDate>Thu, 09 Jan 2020 10:58:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-9-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#4-%E6%B7%BB%E5%8A%A0modules/</guid><description>在cn.enaium.excel下新建一个包module
在module包里新建Module、ModuleManager这2个类 然后再新建一个Category枚举
Module内容
package cn.enaium.excel.module; /** * @Author Enaium * @Date 2020/1/9 11:03 */ public class Module { private String name; private Category category; private boolean toggled; public Module(String name,Category category) { this.name = name; this.category = category; this.toggled = false; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Category getCategory() { return category; } public void setCategory(Category category) { this.</description></item><item><title>解决IDEA Push rejected问题</title><link>https://blog.enaium.cn/post/2020-1-6-%E8%A7%A3%E5%86%B3idea-push-rejected%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 06 Jan 2020 11:25:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-6-%E8%A7%A3%E5%86%B3idea-push-rejected%E9%97%AE%E9%A2%98/</guid><description>右击目录选择Git Bash Here
依次输入以下命令
git pull git pull origin master git pull origin master --allow-unrelated-histories 再次推送</description></item><item><title>Minecraft Fabric Client 教程 #3 添加自定义Command</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#3-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89command/</link><pubDate>Sun, 05 Jan 2020 12:52:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#3-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89command/</guid><description>添加ChatUtils 先在cn.enaium.excel里新建一个包utils
然后创建一个ChatUtils.java类
内容
package cn.enaium.excel.utils; import net.minecraft.client.MinecraftClient; import net.minecraft.client.gui.hud.ChatHud; import net.minecraft.text.LiteralText; import net.minecraft.text.Text; /** * @Author Enaium * @Date 2020/1/5 12:54 */ public class ChatUtils { public static void component(Text component) { ChatHud chatHud = MinecraftClient.getInstance().inGameHud.getChatHud(); LiteralText prefix = new LiteralText(&amp;#34;\u00a7c[\u00a76Excel\u00a7c]\u00a7r &amp;#34;); chatHud.addMessage(prefix.append(component)); } public static void message(String message) { component(new LiteralText(message)); } } 添加自定义command 先在cn.enaium.excel里新建一个包command
下载
将压缩包里面的内容全部放进去
然后再Excel.java里添加command
public CommandManager commandManager; public void onEnable() { commandManager = new CommandManager(); commandManager.</description></item><item><title>Minecraft Fabric Client 教程 #2 修改文件和目录名添加run和stop</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#2-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%90%8D%E6%B7%BB%E5%8A%A0run%E5%92%8Cstop/</link><pubDate>Sat, 04 Jan 2020 23:08:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#2-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%90%8D%E6%B7%BB%E5%8A%A0run%E5%92%8Cstop/</guid><description>修改 包名、json文件、添加run stop 首先先修改包名
将ExampleMod.java改为ExcelInitializer.java
修改json文件modid.mixins.json和fabric.mod.json
将modid.mixins.json改为excel.mixins.json
excel.mixins.json内容：
{ &amp;#34;required&amp;#34;: true, &amp;#34;package&amp;#34;: &amp;#34;cn.enaium.excel.mixin&amp;#34;, &amp;#34;compatibilityLevel&amp;#34;: &amp;#34;JAVA_8&amp;#34;, &amp;#34;mixins&amp;#34;: [ ], &amp;#34;client&amp;#34;: [ &amp;#34;ExampleMixin&amp;#34;, &amp;#34;MinecraftClientMixin&amp;#34; ], &amp;#34;injectors&amp;#34;: { &amp;#34;defaultRequire&amp;#34;: 1 } } packagemixin的包名
client mixin的类名
compatibilityLevel java版本
fabric.mod.json内容：
{ &amp;#34;schemaVersion&amp;#34;: 1, &amp;#34;id&amp;#34;: &amp;#34;excel&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Excel&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;!&amp;#34;, &amp;#34;authors&amp;#34;: [ &amp;#34;Enaium!&amp;#34; ], &amp;#34;contact&amp;#34;: { &amp;#34;homepage&amp;#34;: &amp;#34;https://fabricmc.net/&amp;#34;, &amp;#34;sources&amp;#34;: &amp;#34;https://github.com/FabricMC/fabric-example-mod&amp;#34; }, &amp;#34;license&amp;#34;: &amp;#34;CC0-1.0&amp;#34;, &amp;#34;icon&amp;#34;: &amp;#34;assets/excel/icon.png&amp;#34;, &amp;#34;environment&amp;#34;: &amp;#34;*&amp;#34;, &amp;#34;entrypoints&amp;#34;: { &amp;#34;main&amp;#34;: [ &amp;#34;cn.enaium.excel.ExcelInitializer&amp;#34; ] }, &amp;#34;mixins&amp;#34;: [ &amp;#34;excel.</description></item><item><title>Minecraft Fabric Client 教程 #1 配置开发环境</title><link>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 04 Jan 2020 22:08:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-4-minecraft-fabric-client-%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDE
首先下载github 上的项目 fabric-example-mod 有以下方法:
用IDE 克隆 库 直接导入IDE 运行bat ./gradlew idea然后导入IDE 推荐使用IDEA</description></item><item><title>Minecraft 搭建一个Paper服务器</title><link>https://blog.enaium.cn/post/2020-1-2-minecraft-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AApaper%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Thu, 02 Jan 2020 18:44:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2020-1-2-minecraft-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AApaper%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>下载核心 Downloads – PaperMC
我这里是1.15.1的版本
选最新版本就行了
运行 下载好后放到一个文件夹然后放到一个文件夹然后再新建一个bat文件Launcher.bat里面写
java -Xms512M -Xmx1024M -jar paper.jar
然后发现下载好后瞬间退出了是因为要同意一些eula
打开eula.exe将eula=false改成就好了
然后再次运行
这样一个服务器就开好了</description></item><item><title>Linux下制作Windows启动U盘</title><link>https://blog.enaium.cn/post/2019-12-28-linux%E4%B8%8B%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8u%E7%9B%98/</link><pubDate>Sat, 28 Dec 2019 21:24:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-28-linux%E4%B8%8B%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8u%E7%9B%98/</guid><description>安装WoeUsb sudo apt-get install woeusb
或者
WosUsb
找一个U盘 格式化为NTFS格式
制作 sudo woeusb -d /media/e/Enaium/镜像/windows64/win101909.iso /dev/sdb --target-filesystem NTFS
注意路径！
接下来等就好了</description></item><item><title>Minecraft Fabric 教程 #9 添加盔甲</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#9-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</link><pubDate>Mon, 16 Dec 2019 17:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#9-%E6%B7%BB%E5%8A%A0%E7%9B%94%E7%94%B2/</guid><description>创建一个盔甲类
public class EndArmorMaterials implements ArmorMaterial { [...] } 复制一下内容
private static final int[] BASE_DURABILITY = {13, 15, 16, 11}; private final String name; private final int durabilityMultiplier; private final int[] protectionAmounts; private final int enchantability; private final SoundEvent equipSound; private final float toughness; private final Lazy&amp;lt;Ingredient&amp;gt; repairIngredientSupplier; public EndArmorMaterials(String name, int durabilityMultiplier, int[] armorValueArr, int enchantability, SoundEvent soundEvent, float toughness, Supplier&amp;lt;Ingredient&amp;gt; repairIngredient) { this.name = name; this.durabilityMultiplier = durabilityMultiplier; this.</description></item><item><title>Minecraft Fabric 教程 #8 添加附魔书</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#8-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</link><pubDate>Mon, 16 Dec 2019 13:45:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#8-%E6%B7%BB%E5%8A%A0%E9%99%84%E9%AD%94%E4%B9%A6/</guid><description>创建一个附魔书类
public class FireBoomEnchantment extends Enchantment { [...] } 在类中添一下
@Override public int getMinimumPower(int level) { return 15; } @Override public int getMaximumLevel() { return 1; } @Override public void onTargetDamaged(LivingEntity user, Entity target, int level) { if(target instanceof LivingEntity) { World world = user.world; boolean bl = world.getGameRules().getBoolean(GameRules.MOB_GRIEFING); world.createExplosion(target, target.prevX, target.prevY, target.prevZ, 1.0f, bl, bl ? Explosion.DestructionType.DESTROY : Explosion.DestructionType.NONE); world.spawnEntity(target); } } 这就创建了一个FireBoom附魔书
onTargetDamaged //当目标被攻击
在mc FireballEntity类有一个 方法就是当火球碰撞了就创建一个火焰爆炸的效果
protected void onCollision(HitResult hitResult) { super.</description></item><item><title>Minecraft Fabric 教程 #7 添加工具提示</title><link>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#7-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</link><pubDate>Mon, 16 Dec 2019 12:30:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-16-minecraft-fabric-%E6%95%99%E7%A8%8B-#7-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA/</guid><description>添加工具提示 在EndHeart类中添加
@Override public void appendTooltip(ItemStack stack, World world, List&amp;lt;Text&amp;gt; tooltip, TooltipContext context) { tooltip.add(new TranslatableText(&amp;#34;tooltip.endarmor.end_heart&amp;#34;)); }</description></item><item><title>Minecraft Fabric 教程 #6 添加合成表</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#6-%E6%B7%BB%E5%8A%A0%E5%90%88%E6%88%90%E8%A1%A8/</link><pubDate>Sun, 15 Dec 2019 20:48:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#6-%E6%B7%BB%E5%8A%A0%E5%90%88%E6%88%90%E8%A1%A8/</guid><description>位置 src\main\resources\data\endarmor\recipes\end_heart_block.json
{ &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shaped&amp;#34;, &amp;#34;pattern&amp;#34;: [ &amp;#34;WWW&amp;#34;, &amp;#34;WWW&amp;#34;, &amp;#34;WWW&amp;#34; ], &amp;#34;key&amp;#34;: { &amp;#34;W&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;endarmor:end_heart&amp;#34; } }, &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;endarmor:end_heart_block&amp;#34;, &amp;#34;count&amp;#34;: 4 } } W就是key里面的物品如果是空的就打一个空格比如W W</description></item><item><title>Minecraft Fabric 教程 #5 添加语言文件</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#5-%E6%B7%BB%E5%8A%A0%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 15 Dec 2019 20:26:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#5-%E6%B7%BB%E5%8A%A0%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6/</guid><description>创建语言文件 lang也就是你模组的翻译比如 中文简体 zh_cn 中文正體 zh_tw 英文 en_us
resources/assets/endarmor/lang/zh_cn.json
{ &amp;#34;item.endarmor.end_heart&amp;#34;: &amp;#34;End心&amp;#34;, &amp;#34;block.endarmor.end_heart_block&amp;#34;: &amp;#34;End心块&amp;#34;, [...] } 格式 &amp;lt;object-type&amp;gt;.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt;
block.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; item.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; itemGroup.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; fluid.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; sound_event.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; mob_effect.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; enchantment.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; entity_type.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; potion.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; biome.&amp;lt;modid&amp;gt;.&amp;lt;registry-id&amp;gt; 获取翻译文件的翻译
new TranslatableText(&amp;#34;item.tutorial.fabric_item.tooltip_1&amp;#34;)</description></item><item><title>Minecraft Fabric 教程 #4 添加分组</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#4-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%BB%84/</link><pubDate>Sun, 15 Dec 2019 19:56:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#4-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%BB%84/</guid><description>在 ItemGroup 显示 使用 FabricItemGroupBuilder
public static final ItemGroup END_ITEM_GROUP = FabricItemGroupBuilder.create( new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;endarmor&amp;#34;)) .icon(() -&amp;gt; new ItemStack(END_HEART)) .appendItems(stacks -&amp;gt; { stacks.add(new ItemStack(END_HEART)); stacks.add(new ItemStack(END_HEART_BLOCK)); }) .build(); 直接创建即可
new Identifier(&amp;ldquo;endarmor&amp;rdquo;, &amp;ldquo;endarmor&amp;rdquo;) //第一个参数modid 第二个参数名字 只能用的 [a-z0-9_.-] 不要使用其他符号</description></item><item><title>Minecraft Fabric 教程 #3 添加方块</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#3-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</link><pubDate>Sun, 15 Dec 2019 19:36:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#3-%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%9D%97/</guid><description>创建方块 public class ExampleMod implements ModInitializer { // an instance of our new block public static final Block END_HEART_BLOCK = new Block(FabricBlockSettings.of(Material.METAL).build()); [...] } 注册 public class ExampleMod implements ModInitializer { // block creation […] @Override public void onInitialize() { Registry.register(Registry.BLOCK, new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;end_heart_block&amp;#34;), END_HEART_BLOCK); } } 运行游戏发现无法找到方块是因为没有创建方块物品 但是可以使用命令在创建这个方块
创建方块物品 直接注册就行
public class ExampleMod implements ModInitializer { // block creation […] @Override public void onInitialize() { // block registration [...] Registry.</description></item><item><title>Minecraft Fabric 教程 #2 添加物品</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#2-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</link><pubDate>Sun, 15 Dec 2019 19:06:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#2-%E6%B7%BB%E5%8A%A0%E7%89%A9%E5%93%81/</guid><description>创建物品 public class ExampleMod implements ModInitializer { private static final Item END_HEART = new Item(new Item.Settings().group(ItemGroup.COMBAT).maxCount(32)); [...] } ItemGroup.COMBAT //分类为COMBAT
maxCount(32) //一组最大堆叠数 一组最大只能叠32个物品
注册物品 public class ExampleMod implements ModInitializer { private static final Item END_HEART = new Item(new Item.Settings().group(ItemGroup.COMBAT).maxCount(32)); @Override public void onInitialize() { Registry.register(Registry.ITEM, new Identifier(&amp;#34;endarmor&amp;#34;, &amp;#34;end_heart&amp;#34;), END_HEART); } } Registry.ITEM //类别是物品
new Identifier(&amp;ldquo;endarmor&amp;rdquo;, &amp;ldquo;end_heart&amp;rdquo;) //第一个参数是MOD ID 第二个参数是 物品的名字
END_HEART //要注册的物品的变量名
运行看看
发现是一个紫色方块 而且 名字是 item.endarmor.end_heart 紫色方块是没用纹理(材质)
接下来要添加纹理 需要的文件</description></item><item><title>Minecraft Fabric 教程 #1 开发环境配置</title><link>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 15 Dec 2019 17:50:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-15-minecraft-fabric-%E6%95%99%E7%A8%8B-#1-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>需要 JAVA8+ 和 IDE
首先下载github 上的项目 fabric-example-mod 有以下方法:
用IDE 克隆 库 直接导入IDE 运行bat ./gradlew genSources然后导入IDE 推荐使用IDEA</description></item><item><title>解决Github release 被墙问题</title><link>https://blog.enaium.cn/post/2019-12-14-%E8%A7%A3%E5%86%B3github-release-%E8%A2%AB%E5%A2%99%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 14 Dec 2019 19:46:00 +0800</pubDate><guid>https://blog.enaium.cn/post/2019-12-14-%E8%A7%A3%E5%86%B3github-release-%E8%A2%AB%E5%A2%99%E9%97%AE%E9%A2%98/</guid><description>添加hosts52.216.186.155 github-production-release-asset-2e65be.s3.amazonaws.com就好了
Windwos 位置 c:\windows\system32\drivers\etc\
Linux 位置 /etc</description></item></channel></rss>